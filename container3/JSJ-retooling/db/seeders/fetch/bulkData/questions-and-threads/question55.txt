{"body":"<p>I'd like to store a JavaScript object in HTML5 <code>localStorage</code>, but my object is apparently being converted to a string.</p>\n\n<p>I can store and retrieve primitive JavaScript types and arrays using <code>localStorage</code>, but objects don't seem to work.  Should they? </p>\n\n<p>Here's my code:</p>\n\n<pre><code>var testObject = { 'one': 1, 'two': 2, 'three': 3 };\nconsole.log('typeof testObject: ' + typeof testObject);\nconsole.log('testObject properties:');\nfor (var prop in testObject) {\n    console.log('  ' + prop + ': ' + testObject[prop]);\n}\n\n// Put the object into storage\nlocalStorage.setItem('testObject', testObject);\n\n// Retrieve the object from storage\nvar retrievedObject = localStorage.getItem('testObject');\n\nconsole.log('typeof retrievedObject: ' + typeof retrievedObject);\nconsole.log('Value of retrievedObject: ' + retrievedObject);\n</code></pre>\n\n<p>The console output is</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>typeof testObject: object\ntestObject properties:\n  one: 1\n  two: 2\n  three: 3\ntypeof retrievedObject: string\nValue of retrievedObject: [object Object]\n</code></pre>\n\n<p>It looks to me like the <code>setItem</code> method is converting the input to a string before storing it.</p>\n\n<p>I see this behavior in Safari, Chrome, and Firefox, so I assume it's my misunderstanding of the <a href=\"http://www.w3.org/TR/webstorage/\" rel=\"noreferrer\">HTML5 Web Storage</a> spec, not a browser-specific bug or limitation.</p>\n\n<p>I've tried to make sense of the <em>structured clone</em> algorithm described in <a href=\"http://www.w3.org/TR/html5/infrastructure.html\" rel=\"noreferrer\">http://www.w3.org/TR/html5/infrastructure.html</a>.  I don't fully understand what it's saying, but maybe my problem has to do with my object's properties not being enumerable (???)  </p>\n\n<p>Is there an easy workaround?</p>\n\n<hr>\n\n<p>Update: The W3C eventually changed their minds about the structured-clone specification, and decided to change the spec to match the implementations.  See <a href=\"https://www.w3.org/Bugs/Public/show_bug.cgi?id=12111\" rel=\"noreferrer\">https://www.w3.org/Bugs/Public/show_bug.cgi?id=12111</a>. So this question is no longer 100% valid, but the answers still may be of interest.</p>\n","title":"Storing Objects in HTML5 localStorage","answers":[{"score":3310,"body":"<p>Looking at the <a href=\"https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/SafariJSDatabaseGuide/Name-ValueStorage/Name-ValueStorage.html\" rel=\"noreferrer\">Apple</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API\" rel=\"noreferrer\">Mozilla</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Storage/setItem\" rel=\"noreferrer\">Mozilla again</a> documentation, the functionality seems to be limited to handle only string key/value pairs.</p>\n\n<p>A workaround can be to <a href=\"https://www.w3schools.com/js/js_json_stringify.asp\" rel=\"noreferrer\"><em>stringify</em></a> your object before storing it, and later parse it when you retrieve it:</p>\n\n<pre><code>var testObject = { 'one': 1, 'two': 2, 'three': 3 };\n\n// Put the object into storage\nlocalStorage.setItem('testObject', JSON.stringify(testObject));\n\n// Retrieve the object from storage\nvar retrievedObject = localStorage.getItem('testObject');\n\nconsole.log('retrievedObject: ', JSON.parse(retrievedObject));\n</code></pre>\n"},{"score":225,"body":"<p>You might find it useful to extend the Storage object with these handy methods:</p>\n\n<pre><code>Storage.prototype.setObject = function(key, value) {\n    this.setItem(key, JSON.stringify(value));\n}\n\nStorage.prototype.getObject = function(key) {\n    return JSON.parse(this.getItem(key));\n}\n</code></pre>\n\n<p>This way you get the functionality that you really wanted even though underneath the API only supports strings.</p>\n"},{"score":636,"body":"<p>A minor improvement on a <a href=\"https://stackoverflow.com/a/2010994/59087\">variant</a>:</p>\n\n<pre><code>Storage.prototype.setObject = function(key, value) {\n    this.setItem(key, JSON.stringify(value));\n}\n\nStorage.prototype.getObject = function(key) {\n    var value = this.getItem(key);\n    return value &amp;&amp; JSON.parse(value);\n}\n</code></pre>\n\n<p>Because of <a href=\"http://en.wikipedia.org/wiki/Short-circuit_evaluation\" rel=\"noreferrer\">short-circuit evaluation</a>, <code>getObject()</code> will <em>immediately</em> return <code>null</code> if <code>key</code> is not in Storage. It also will not throw a <code>SyntaxError</code> exception if <code>value</code> is <code>\"\"</code> (the empty string; <code>JSON.parse()</code> cannot handle that).</p>\n"},{"score":75,"body":"<p>Extending the Storage object is an awesome solution. For my API, I have created a facade for localStorage and then check if it is an object or not while setting and getting.</p>\n\n<pre><code>var data = {\n  set: function(key, value) {\n    if (!key || !value) {return;}\n\n    if (typeof value === \"object\") {\n      value = JSON.stringify(value);\n    }\n    localStorage.setItem(key, value);\n  },\n  get: function(key) {\n    var value = localStorage.getItem(key);\n\n    if (!value) {return;}\n\n    // assume it is an object that has been stringified\n    if (value[0] === \"{\") {\n      value = JSON.parse(value);\n    }\n\n    return value;\n  }\n}\n</code></pre>\n"},{"score":28,"body":"<p>In theory, it is possible to store objects with functions:</p>\n\n<pre><code>function store (a)\n{\n  var c = {f: {}, d: {}};\n  for (var k in a)\n  {\n    if (a.hasOwnProperty(k) &amp;&amp; typeof a[k] === 'function')\n    {\n      c.f[k] = encodeURIComponent(a[k]);\n    }\n  }\n\n  c.d = a;\n  var data = JSON.stringify(c);\n  window.localStorage.setItem('CODE', data);\n}\n\nfunction restore ()\n{\n  var data = window.localStorage.getItem('CODE');\n  data = JSON.parse(data);\n  var b = data.d;\n\n  for (var k in data.f)\n  {\n    if (data.f.hasOwnProperty(k))\n    {\n      b[k] = eval(\"(\" + decodeURIComponent(data.f[k]) + \")\");\n    }\n  }\n\n  return b;\n}\n</code></pre>\n\n<p><strong>However, Function serialization/deserialization is unreliable because <a href=\"http://ecma-international.org/ecma-262/5.1/#sec-15.3.4\">it is implementation-dependent</a>.</strong></p>\n"},{"score":52,"body":"<p>There is a great library that wraps many solutions so it even supports older browsers called <a href=\"https://github.com/andris9/jStorage\" rel=\"nofollow noreferrer\">jStorage</a></p>\n\n<p>You can set an object</p>\n\n<pre><code>$.jStorage.set(key, value)\n</code></pre>\n\n<p>And retrieve it easily</p>\n\n<pre><code>value = $.jStorage.get(key)\nvalue = $.jStorage.get(key, \"default value\")\n</code></pre>\n"},{"score":25,"body":"<p>I arrived at this post after hitting on another post that has been closed as a duplicate of this - titled 'how to store an array in localstorage?'.  Which is fine except neither thread actually provides a full answer as to how you can maintain an array in localStorage - however I have managed to craft a solution based on information contained in both threads.</p>\n\n<p>So if anyone else is wanting to be able to push/pop/shift items within an array, and they want that array stored in localStorage or indeed sessionStorage, here you go:</p>\n\n<pre><code>Storage.prototype.getArray = function(arrayName) {\n  var thisArray = [];\n  var fetchArrayObject = this.getItem(arrayName);\n  if (typeof fetchArrayObject !== 'undefined') {\n    if (fetchArrayObject !== null) { thisArray = JSON.parse(fetchArrayObject); }\n  }\n  return thisArray;\n}\n\nStorage.prototype.pushArrayItem = function(arrayName,arrayItem) {\n  var existingArray = this.getArray(arrayName);\n  existingArray.push(arrayItem);\n  this.setItem(arrayName,JSON.stringify(existingArray));\n}\n\nStorage.prototype.popArrayItem = function(arrayName) {\n  var arrayItem = {};\n  var existingArray = this.getArray(arrayName);\n  if (existingArray.length &gt; 0) {\n    arrayItem = existingArray.pop();\n    this.setItem(arrayName,JSON.stringify(existingArray));\n  }\n  return arrayItem;\n}\n\nStorage.prototype.shiftArrayItem = function(arrayName) {\n  var arrayItem = {};\n  var existingArray = this.getArray(arrayName);\n  if (existingArray.length &gt; 0) {\n    arrayItem = existingArray.shift();\n    this.setItem(arrayName,JSON.stringify(existingArray));\n  }\n  return arrayItem;\n}\n\nStorage.prototype.unshiftArrayItem = function(arrayName,arrayItem) {\n  var existingArray = this.getArray(arrayName);\n  existingArray.unshift(arrayItem);\n  this.setItem(arrayName,JSON.stringify(existingArray));\n}\n\nStorage.prototype.deleteArray = function(arrayName) {\n  this.removeItem(arrayName);\n}\n</code></pre>\n\n<p>example usage - storing simple strings in localStorage array:</p>\n\n<pre><code>localStorage.pushArrayItem('myArray','item one');\nlocalStorage.pushArrayItem('myArray','item two');\n</code></pre>\n\n<p>example usage - storing objects in sessionStorage array:</p>\n\n<pre><code>var item1 = {}; item1.name = 'fred'; item1.age = 48;\nsessionStorage.pushArrayItem('myArray',item1);\n\nvar item2 = {}; item2.name = 'dave'; item2.age = 22;\nsessionStorage.pushArrayItem('myArray',item2);\n</code></pre>\n\n<p>common methods to manipulate arrays:</p>\n\n<pre><code>.pushArrayItem(arrayName,arrayItem); -&gt; adds an element onto end of named array\n.unshiftArrayItem(arrayName,arrayItem); -&gt; adds an element onto front of named array\n.popArrayItem(arrayName); -&gt; removes &amp; returns last array element\n.shiftArrayItem(arrayName); -&gt; removes &amp; returns first array element\n.getArray(arrayName); -&gt; returns entire array\n.deleteArray(arrayName); -&gt; removes entire array from storage\n</code></pre>\n"},{"score":2,"body":"<p><a href=\"https://github.com/adrianmay/rhaboo\" rel=\"nofollow noreferrer\">https://github.com/adrianmay/rhaboo</a> is a localStorage sugar layer that lets you write things like this:</p>\n\n<pre><code>var store = Rhaboo.persistent('Some name');\nstore.write('count', store.count ? store.count+1 : 1);\nstore.write('somethingfancy', {\n  one: ['man', 'went'],\n  2: 'mow',\n  went: [  2, { mow: ['a', 'meadow' ] }, {}  ]\n});\nstore.somethingfancy.went[1].mow.write(1, 'lawn');\n</code></pre>\n\n<p>It doesn't use JSON.stringify/parse because that would be inaccurate and slow on big objects. Instead, each terminal value has its own localStorage entry.</p>\n\n<p>You can probably guess that I might have something to do with rhaboo.</p>\n"},{"score":66,"body":"<h2>Stringify doesn't solve all problems</h2>\n\n<p>It seems that the answers here don't cover all types that are possible in JavaScript, so here are some short examples on how to deal with them correctly: </p>\n\n<pre><code>//Objects and Arrays:\n    var obj = {key: \"value\"};\n    localStorage.object = JSON.stringify(obj);  //Will ignore private members\n    obj = JSON.parse(localStorage.object);\n//Boolean:\n    var bool = false;\n    localStorage.bool = bool;\n    bool = (localStorage.bool === \"true\");\n//Numbers:\n    var num = 42;\n    localStorage.num = num;\n    num = +localStorage.num;    //short for \"num = parseFloat(localStorage.num);\"\n//Dates:\n    var date = Date.now();\n    localStorage.date = date;\n    date = new Date(parseInt(localStorage.date));\n//Regular expressions:\n    var regex = /^No\\.[\\d]*$/i;     //usage example: \"No.42\".match(regex);\n    localStorage.regex = regex;\n    var components = localStorage.regex.match(\"^/(.*)/([a-z]*)$\");\n    regex = new RegExp(components[1], components[2]);\n//Functions (not recommended):\n    function func(){}\n    localStorage.func = func;\n    eval( localStorage.func );      //recreates the function with the name \"func\"\n</code></pre>\n\n<p><strong>I do not recommend</strong> to store functions because <code>eval()</code> is evil can lead to issues regarding security, optimisation and debugging.\n        In general, <code>eval()</code> should never be used in JavaScript code.</p>\n\n<h2>Private members</h2>\n\n<p>The problem with using <code>JSON.stringify()</code> for storing objects is, that this function can not serialise private members.\nThis issue can be solved by overwriting the <code>.toString()</code> method (which is called implicitly when storing data in web storage):</p>\n\n<pre><code>//Object with private and public members:\n    function MyClass(privateContent, publicContent){\n        var privateMember = privateContent || \"defaultPrivateValue\";\n        this.publicMember = publicContent  || \"defaultPublicValue\";\n\n        this.toString = function(){\n            return '{\"private\": \"' + privateMember + '\", \"public\": \"' + this.publicMember + '\"}';\n        };\n    }\n    MyClass.fromString = function(serialisedString){\n        var properties = JSON.parse(serialisedString || \"{}\");\n        return new MyClass( properties.private, properties.public );\n    };\n//Storing:\n    var obj = new MyClass(\"invisible\", \"visible\");\n    localStorage.object = obj;\n//Loading:\n    obj = MyClass.fromString(localStorage.object);\n</code></pre>\n\n<h2>Circular references</h2>\n\n<p>Another problem <code>stringify</code> can't deal with are circular references:</p>\n\n<pre><code>var obj = {};\nobj[\"circular\"] = obj;\nlocalStorage.object = JSON.stringify(obj);  //Fails\n</code></pre>\n\n<p>In this example, <code>JSON.stringify()</code> will throw a <code>TypeError</code> <em>\"Converting circular structure to JSON\"</em>.\n        If storing circular references should be supported, the second parameter of <code>JSON.stringify()</code> might be used:</p>\n\n<pre><code>var obj = {id: 1, sub: {}};\nobj.sub[\"circular\"] = obj;\nlocalStorage.object = JSON.stringify( obj, function( key, value) {\n    if( key == 'circular') {\n        return \"$ref\"+value.id+\"$\";\n    } else {\n        return value;\n    }\n});\n</code></pre>\n\n<p>However, finding an efficient solution for storing circular references highly depends on the tasks that need to be solved, and restoring such data is not trivial either.</p>\n\n<p>There are already some question on SO dealing with this problem: <a href=\"https://stackoverflow.com/questions/10392293/stringify-javascript-object-with-circular-reference/12659424#12659424\">Stringify (convert to JSON) a JavaScript object with circular reference</a></p>\n"},{"score":1,"body":"<p>Here some extented version of the code posted by @danott</p>\n\n<p>It'll also implement <strong>delete</strong> value from localstorage \nand shows how to adds a Getter and Setter layer so instead of</p>\n\n<p><code>localstorage.setItem(preview, true)</code> </p>\n\n<p>you can write</p>\n\n<p><code>config.preview = true</code></p>\n\n<p>Okay here were go:</p>\n\n<pre><code>var PT=Storage.prototype\n\nif (typeof PT._setItem &gt;='u') PT._setItem = PT.setItem;\nPT.setItem = function(key, value)\n{\n  if (typeof value &gt;='u')//..ndefined\n    this.removeItem(key)\n  else\n    this._setItem(key, JSON.stringify(value));\n}\n\nif (typeof PT._getItem &gt;='u') PT._getItem = PT.getItem;\nPT.getItem = function(key)\n{  \n  var ItemData = this._getItem(key)\n  try\n  {\n    return JSON.parse(ItemData);\n  }\n  catch(e)\n  {\n    return ItemData;\n  }\n}\n\n// Aliases for localStorage.set/getItem \nget =   localStorage.getItem.bind(localStorage)\nset =   localStorage.setItem.bind(localStorage)\n\n// Create ConfigWrapperObject\nvar config = {}\n\n// Helper to create getter &amp; setter\nfunction configCreate(PropToAdd){\n    Object.defineProperty( config, PropToAdd, {\n      get: function ()      { return (  get(PropToAdd)      ) },\n      set: function (val)   {           set(PropToAdd,  val ) }\n    })\n}\n//------------------------------\n\n// Usage Part\n// Create properties\nconfigCreate('preview')\nconfigCreate('notification')\n//...\n\n// Config Data transfer\n//set\nconfig.preview = true\n\n//get\nconfig.preview\n\n// delete\nconfig.preview = undefined\n</code></pre>\n\n<p>Well you may strip the aliases part with <code>.bind(...)</code>. However I just put it in since it's really good to know about this. I tooked me hours to find out why a simple <code>get = localStorage.getItem;</code> don't work</p>\n"},{"score":14,"body":"<p>Recommend using an abstraction library for many of the features discussed here as well as better compatibility. Lots of options:</p>\n\n<ul>\n<li><a href=\"https://github.com/andris9/jStorage\">jStorage</a> or <a href=\"https://github.com/andris9/simpleStorage\">simpleStorage</a> &lt;&lt; my preference</li>\n<li><a href=\"https://github.com/mozilla/localForage\">localForage</a></li>\n<li><a href=\"https://github.com/alekseykulikov/storage\">alekseykulikov/storage</a></li>\n<li><a href=\"https://github.com/brianleroux/lawnchair\">Lawnchair</a></li>\n<li><a href=\"https://github.com/marcuswestin/store.js\">Store.js</a> &lt;&lt; another good option</li>\n<li><a href=\"https://github.com/aaronagray/omg\">OMG</a></li>\n</ul>\n"},{"score":1,"body":"<p>I made a thing that doesn't break the existing Storage objects, but creates a wrapper so you can do what you want. The result is a normal object, no methods, with access like any object.</p>\n\n<p><a href=\"https://github.com/rudiedirkx/ObjectStorage\" rel=\"nofollow\">The thing I made.</a></p>\n\n<p>If you want 1 <code>localStorage</code> property to be magic:</p>\n\n<pre><code>var prop = ObjectStorage(localStorage, 'prop');\n</code></pre>\n\n<p>If you need several:</p>\n\n<pre><code>var storage = ObjectStorage(localStorage, ['prop', 'more', 'props']);\n</code></pre>\n\n<p>Everything you do to <code>prop</code>, or the objects <strong>inside</strong> <code>storage</code> will be automatically saved into <code>localStorage</code>. You're always playing with a real object, so you can do stuff like this:</p>\n\n<pre><code>storage.data.list.push('more data');\nstorage.another.list.splice(1, 2, {another: 'object'});\n</code></pre>\n\n<p>And every new object <strong>inside</strong> a tracked object will be automatically tracked.</p>\n\n<p><strong>The very big downside:</strong> it depends on <code>Object.observe()</code> so it has very limited browser support. And it doesn't look like it'll be coming for Firefox or Edge anytime soon.</p>\n"},{"score":0,"body":"<p>To store an object, you could make a letters that you can use to get an object from a string to an object (may not make sense). For example</p>\n\n<pre><code>var obj = {a: \"lol\", b: \"A\", c: \"hello world\"};\nfunction saveObj (key){\n    var j = \"\";\n    for(var i in obj){\n        j += (i+\"|\"+obj[i]+\"~\");\n    }\n    localStorage.setItem(key, j);\n} // Saving Method\nfunction getObj (key){\n    var j = {};\n    var k = localStorage.getItem(key).split(\"~\");\n    for(var l in k){\n        var m = k[l].split(\"|\");\n        j[m[0]] = m[1];\n    }\n    return j;\n}\nsaveObj(\"obj\"); // undefined\ngetObj(\"obj\"); // {a: \"lol\", b: \"A\", c: \"hello world\"}\n</code></pre>\n\n<p>This technique will cause some glitches if you use the letter that you used to split the object, and it's also very experimental.</p>\n"},{"score":4,"body":"<p>Another option would be to use an existing plugin.</p>\n\n<p>For example <a href=\"https://github.com/mar10/persisto\" rel=\"nofollow noreferrer\">persisto</a> is an open source project that provides an easy interface to localStorage/sessionStorage and automates persistence for form fields (input, radio buttons, and checkboxes).</p>\n\n<p><a href=\"https://i.stack.imgur.com/cU5V0.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/cU5V0.png\" alt=\"persisto features\"></a></p>\n\n<p>(Disclaimer: I am the author.)</p>\n"},{"score":4,"body":"<p>You can use <a href=\"https://docs.meteor.com/api/ejson.html\" rel=\"nofollow\">ejson</a> to store the objects as strings.</p>\n\n<blockquote>\n  <p>EJSON is an extension of JSON to support more types. It supports all JSON-safe types, as well as:</p>\n  \n  <ul>\n  <li>Date (JavaScript <code>Date</code>)</li>\n  <li>Binary (JavaScript <code>Uint8Array</code> or the result of <a href=\"https://docs.meteor.com/api/ejson.html#ejson_new_binary\" rel=\"nofollow\">EJSON.newBinary</a>)</li>\n  <li>User-defined types (see <a href=\"https://docs.meteor.com/api/ejson.html#ejson_add_type\" rel=\"nofollow\">EJSON.addType</a>. For example, <a href=\"https://docs.meteor.com/api/ejson.html#mongo_object_id\" rel=\"nofollow\">Mongo.ObjectID</a> is implemented this way.)</li>\n  </ul>\n  \n  <p>All EJSON serializations are also valid JSON. For example an object with a date and a binary buffer would be serialized in EJSON as:</p>\n\n<pre><code>{\n  \"d\": {\"$date\": 1358205756553},\n  \"b\": {\"$binary\": \"c3VyZS4=\"}\n}\n</code></pre>\n</blockquote>\n\n<p>Here is my localStorage wrapper using ejson</p>\n\n<p><a href=\"https://github.com/UziTech/storage.js\" rel=\"nofollow\">https://github.com/UziTech/storage.js</a></p>\n\n<p>I added some types to my wrapper including regular expressions and functions</p>\n"},{"score":2,"body":"<p>I made another minimalistic wrapper with only 20 lines of code to allow using it like it should:</p>\n\n<pre><code>localStorage.set('myKey',{a:[1,2,5], b: 'ok'});\nlocalStorage.has('myKey');   // --&gt; true\nlocalStorage.get('myKey');   // --&gt; {a:[1,2,5], b: 'ok'}\nlocalStorage.keys();         // --&gt; ['myKey']\nlocalStorage.remove('myKey');\n</code></pre>\n\n<p><a href=\"https://github.com/zevero/simpleWebstorage\" rel=\"nofollow\">https://github.com/zevero/simpleWebstorage</a></p>\n"},{"score":6,"body":"<p>You can use <a href=\"https://github.com/macmcmeans/localDataStorage\" rel=\"noreferrer\">localDataStorage</a> to transparently store javascript data types (Array, Boolean, Date, Float, Integer, String and Object). It also provides lightweight data obfuscation, automatically compresses strings, facilitates query by key (name) as well as query by (key) value, and helps to enforce segmented shared storage within the same domain by prefixing keys.</p>\n\n<p>[DISCLAIMER] I am the author of the utility [/DISCLAIMER]</p>\n\n<p>Examples:</p>\n\n<pre><code>localDataStorage.set( 'key1', 'Belgian' )\nlocalDataStorage.set( 'key2', 1200.0047 )\nlocalDataStorage.set( 'key3', true )\nlocalDataStorage.set( 'key4', { 'RSK' : [1,'3',5,'7',9] } )\nlocalDataStorage.set( 'key5', null )\n\nlocalDataStorage.get( 'key1' )   --&gt;   'Belgian'\nlocalDataStorage.get( 'key2' )   --&gt;   1200.0047\nlocalDataStorage.get( 'key3' )   --&gt;   true\nlocalDataStorage.get( 'key4' )   --&gt;   Object {RSK: Array(5)}\nlocalDataStorage.get( 'key5' )   --&gt;   null\n</code></pre>\n\n<p>As you can see, the primitive values are respected.</p>\n"},{"score":2,"body":"<p>For Typescript users willing to set and get typed properties:</p>\n\n<pre><code>/**\n * Silly wrapper to be able to type the storage keys\n */\nexport class TypedStorage&lt;T&gt; {\n\n    public removeItem(key: keyof T): void {\n        localStorage.removeItem(key);\n    }\n\n    public getItem&lt;K extends keyof T&gt;(key: K): T[K] | null {\n        const data: string | null =  localStorage.getItem(key);\n        return JSON.parse(data);\n    }\n\n    public setItem&lt;K extends keyof T&gt;(key: K, value: T[K]): void {\n        const data: string = JSON.stringify(value);\n        localStorage.setItem(key, data);\n    }\n}\n</code></pre>\n\n<p><a href=\"http://www.typescriptlang.org/play/#src=%2F**%0D%0A%20*%20Silly%20wrapper%20to%20be%20able%20to%20type%20the%20storage%20keys%0D%0A%20*%2F%0D%0Aexport%20class%20TypedStorage%3CT%3E%20%7B%0D%0A%0D%0A%20%20%20%20public%20removeItem(key%3A%20keyof%20T)%3A%20void%20%7B%0D%0A%20%20%20%20%20%20%20%20localStorage.removeItem(key)%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20public%20getItem%3CK%20extends%20keyof%20T%3E(key%3A%20K)%3A%20T%5BK%5D%20%7C%20null%20%7B%0D%0A%20%20%20%20%20%20%20%20const%20data%3A%20string%20%7C%20null%20%3D%20%20localStorage.getItem(key)%3B%0D%0A%20%20%20%20%20%20%20%20return%20JSON.parse(data)%3B%0D%0A%20%20%20%20%7D%0D%0A%0D%0A%20%20%20%20public%20setItem%3CK%20extends%20keyof%20T%3E(key%3A%20K%2C%20value%3A%20T%5BK%5D)%3A%20void%20%7B%0D%0A%20%20%20%20%20%20%20%20const%20data%3A%20string%20%3D%20JSON.stringify(value)%3B%0D%0A%20%20%20%20%20%20%20%20localStorage.setItem(key%2C%20data)%3B%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0A%2F%2F%20write%20an%20interface%20for%20the%20storage%0D%0Ainterface%20MyStore%20%7B%0D%0A%20%20%20age%3A%20number%2C%0D%0A%20%20%20name%3A%20string%2C%0D%0A%20%20%20address%3A%20%7Bcity%3Astring%7D%0D%0A%7D%0D%0A%0D%0Aconst%20storage%3A%20TypedStorage%3CMyStore%3E%20%3D%20new%20TypedStorage%3CMyStore%3E()%3B%0D%0A%0D%0Astorage.setItem(%22wrong%20key%22%2C%20%22%22)%3B%20%2F%2F%20error%20unknown%20key%0D%0Astorage.setItem(%22age%22%2C%20%22hello%22)%3B%20%2F%2F%20error%2C%20age%20should%20be%20number%0D%0Astorage.setItem(%22address%22%2C%20%7Bcity%3A%22Here%22%7D)%3B%20%2F%2F%20ok%0D%0A%0D%0Aconst%20address%3A%20%7Bcity%3Astring%7D%20%3D%20storage.getItem(%22address%22)%3B\" rel=\"nofollow noreferrer\">Example usage</a>:</p>\n\n<pre><code>// write an interface for the storage\ninterface MyStore {\n   age: number,\n   name: string,\n   address: {city:string}\n}\n\nconst storage: TypedStorage&lt;MyStore&gt; = new TypedStorage&lt;MyStore&gt;();\n\nstorage.setItem(\"wrong key\", \"\"); // error unknown key\nstorage.setItem(\"age\", \"hello\"); // error, age should be number\nstorage.setItem(\"address\", {city:\"Here\"}); // ok\n\nconst address: {city:string} = storage.getItem(\"address\");\n</code></pre>\n"},{"score":1,"body":"<p>I found a way to make it work with objects that have cyclic references.</p>\n\n<p>Let's make an object with cyclic references.</p>\n\n<pre><code>obj = {\n    L: {\n        L: { v: 'lorem' },\n        R: { v: 'ipsum' }\n    },\n    R: {\n        L: { v: 'dolor' },\n        R: {\n            L: { v: 'sit' },\n            R: { v: 'amet' }\n        }\n    }\n}\nobj.R.L.uncle = obj.L;\nobj.R.R.uncle = obj.L;\nobj.R.R.L.uncle = obj.R.L;\nobj.R.R.R.uncle = obj.R.L;\nobj.L.L.uncle = obj.R;\nobj.L.R.uncle = obj.R;\n</code></pre>\n\n<p>We can't do <code>JSON.stringify</code> here, because of the circular references.</p>\n\n<p><a href=\"https://i.stack.imgur.com/4taQx.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/4taQx.png\" alt=\"circularUncle\"></a></p>\n\n<p><code>LOCALSTORAGE.CYCLICJSON</code> has <code>.stringify</code> and <code>.parse</code> just like normal <code>JSON</code>, but works with objects with circular references. (\"Works\" meaning parse(stringify(obj)) and obj are deep equal AND have identical sets of 'inner equalities')</p>\n\n<p>But we can just use the shortcuts:</p>\n\n<pre><code>LOCALSTORAGE.setObject('latinUncles', obj)\nrecovered = LOCALSTORAGE.getObject('latinUncles')\n</code></pre>\n\n<p>Then, <code>recovered</code> will be \"the same\" to obj, in the following sense:</p>\n\n<pre><code>[\nobj.L.L.v === recovered.L.L.v,\nobj.L.R.v === recovered.L.R.v,\nobj.R.L.v === recovered.R.L.v,\nobj.R.R.L.v === recovered.R.R.L.v,\nobj.R.R.R.v === recovered.R.R.R.v,\nobj.R.L.uncle === obj.L,\nobj.R.R.uncle === obj.L,\nobj.R.R.L.uncle === obj.R.L,\nobj.R.R.R.uncle === obj.R.L,\nobj.L.L.uncle === obj.R,\nobj.L.R.uncle === obj.R,\nrecovered.R.L.uncle === recovered.L,\nrecovered.R.R.uncle === recovered.L,\nrecovered.R.R.L.uncle === recovered.R.L,\nrecovered.R.R.R.uncle === recovered.R.L,\nrecovered.L.L.uncle === recovered.R,\nrecovered.L.R.uncle === recovered.R\n]\n</code></pre>\n\n<p>Here is the implementation of <code>LOCALSTORAGE</code></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>LOCALSTORAGE = (function(){\r\n  \"use strict\";\r\n  var ignore = [Boolean, Date, Number, RegExp, String];\r\n  function primitive(item){\r\n    if (typeof item === 'object'){\r\n      if (item === null) { return true; }\r\n      for (var i=0; i&lt;ignore.length; i++){\r\n        if (item instanceof ignore[i]) { return true; }\r\n      }\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n  function infant(value){\r\n    return Array.isArray(value) ? [] : {};\r\n  }\r\n  function decycleIntoForest(object, replacer) {\r\n    if (typeof replacer !== 'function'){\r\n      replacer = function(x){ return x; }\r\n    }\r\n    object = replacer(object);\r\n    if (primitive(object)) return object;\r\n    var objects = [object];\r\n    var forest  = [infant(object)];\r\n    var bucket  = new WeakMap(); // bucket = inverse of objects \r\n    bucket.set(object, 0);    \r\n    function addToBucket(obj){\r\n      var result = objects.length;\r\n      objects.push(obj);\r\n      bucket.set(obj, result);\r\n      return result;\r\n    }\r\n    function isInBucket(obj){ return bucket.has(obj); }\r\n    function processNode(source, target){\r\n      Object.keys(source).forEach(function(key){\r\n        var value = replacer(source[key]);\r\n        if (primitive(value)){\r\n          target[key] = {value: value};\r\n        } else {\r\n          var ptr;\r\n          if (isInBucket(value)){\r\n            ptr = bucket.get(value);\r\n          } else {\r\n            ptr = addToBucket(value);\r\n            var newTree = infant(value);\r\n            forest.push(newTree);\r\n            processNode(value, newTree);\r\n          }\r\n          target[key] = {pointer: ptr};\r\n        }\r\n      });\r\n    }\r\n    processNode(object, forest[0]);\r\n    return forest;\r\n  };\r\n  function deForestIntoCycle(forest) {\r\n    var objects = [];\r\n    var objectRequested = [];\r\n    var todo = [];\r\n    function processTree(idx) {\r\n      if (idx in objects) return objects[idx];\r\n      if (objectRequested[idx]) return null;\r\n      objectRequested[idx] = true;\r\n      var tree = forest[idx];\r\n      var node = Array.isArray(tree) ? [] : {};\r\n      for (var key in tree) {\r\n        var o = tree[key];\r\n        if ('pointer' in o) {\r\n          var ptr = o.pointer;\r\n          var value = processTree(ptr);\r\n          if (value === null) {\r\n            todo.push({\r\n              node: node,\r\n              key: key,\r\n              idx: ptr\r\n            });\r\n          } else {\r\n            node[key] = value;\r\n          }\r\n        } else {\r\n          if ('value' in o) {\r\n            node[key] = o.value;\r\n          } else {\r\n            throw new Error('unexpected')\r\n          }\r\n        }\r\n      }\r\n      objects[idx] = node;\r\n      return node;\r\n    }\r\n    var result = processTree(0);\r\n    for (var i = 0; i &lt; todo.length; i++) {\r\n      var item = todo[i];\r\n      item.node[item.key] = objects[item.idx];\r\n    }\r\n    return result;\r\n  };\r\n  var console = {\r\n    log: function(x){\r\n      var the = document.getElementById('the');\r\n      the.textContent = the.textContent + '\\n' + x;\r\n\t},\r\n\tdelimiter: function(){\r\n      var the = document.getElementById('the');\r\n      the.textContent = the.textContent +\r\n\t\t'\\n*******************************************';\r\n\t}\r\n  }\r\n  function logCyclicObjectToConsole(root) {\r\n    var cycleFree = decycleIntoForest(root);\r\n    var shown = cycleFree.map(function(tree, idx) {\r\n      return false;\r\n    });\r\n    var indentIncrement = 4;\r\n    function showItem(nodeSlot, indent, label) {\r\n      var leadingSpaces = ' '.repeat(indent);\r\n      var leadingSpacesPlus = ' '.repeat(indent + indentIncrement);\r\n      if (shown[nodeSlot]) {\r\n        console.log(leadingSpaces + label + ' ... see above (object #' + nodeSlot + ')');\r\n      } else {\r\n        console.log(leadingSpaces + label + ' object#' + nodeSlot);\r\n        var tree = cycleFree[nodeSlot];\r\n        shown[nodeSlot] = true;\r\n        Object.keys(tree).forEach(function(key) {\r\n          var entry = tree[key];\r\n          if ('value' in entry) {\r\n            console.log(leadingSpacesPlus + key + \": \" + entry.value);\r\n          } else {\r\n            if ('pointer' in entry) {\r\n              showItem(entry.pointer, indent + indentIncrement, key);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n\tconsole.delimiter();\r\n    showItem(0, 0, 'root');\r\n  };\r\n  function stringify(obj){\r\n    return JSON.stringify(decycleIntoForest(obj));\r\n  }\r\n  function parse(str){\r\n    return deForestIntoCycle(JSON.parse(str));\r\n  }\r\n  var CYCLICJSON = {\r\n    decycleIntoForest: decycleIntoForest,\r\n    deForestIntoCycle : deForestIntoCycle,\r\n    logCyclicObjectToConsole: logCyclicObjectToConsole,\r\n    stringify : stringify,\r\n    parse : parse\r\n  }\r\n  function setObject(name, object){\r\n    var str = stringify(object);\r\n    localStorage.setItem(name, str);\r\n  }\r\n  function getObject(name){\r\n    var str = localStorage.getItem(name);\r\n    if (str===null) return null;\r\n    return parse(str);\r\n  }\r\n  return {\r\n    CYCLICJSON : CYCLICJSON,\r\n    setObject  : setObject,\r\n    getObject  : getObject\r\n  }\r\n})();\r\nobj = {\r\n\tL: {\r\n\t\tL: { v: 'lorem' },\r\n\t\tR: { v: 'ipsum' }\r\n\t},\r\n\tR: {\r\n\t\tL: { v: 'dolor' },\r\n\t\tR: {\r\n\t\t\tL: { v: 'sit' },\r\n\t\t\tR: { v: 'amet' }\r\n\t\t}\r\n\t}\r\n}\r\nobj.R.L.uncle = obj.L;\r\nobj.R.R.uncle = obj.L;\r\nobj.R.R.L.uncle = obj.R.L;\r\nobj.R.R.R.uncle = obj.R.L;\r\nobj.L.L.uncle = obj.R;\r\nobj.L.R.uncle = obj.R;\r\n\r\n// LOCALSTORAGE.setObject('latinUncles', obj)\r\n// recovered = LOCALSTORAGE.getObject('latinUncles')\r\n// localStorage not available inside fiddle ):\r\nLOCALSTORAGE.CYCLICJSON.logCyclicObjectToConsole(obj)\r\nputIntoLS = LOCALSTORAGE.CYCLICJSON.stringify(obj);\r\nrecovered = LOCALSTORAGE.CYCLICJSON.parse(putIntoLS);\r\nLOCALSTORAGE.CYCLICJSON.logCyclicObjectToConsole(recovered);\r\n\r\nvar the = document.getElementById('the');\r\nthe.textContent = the.textContent + '\\n\\n' +\r\nJSON.stringify(\r\n[\r\nobj.L.L.v === recovered.L.L.v,\r\nobj.L.R.v === recovered.L.R.v,\r\nobj.R.L.v === recovered.R.L.v,\r\nobj.R.R.L.v === recovered.R.R.L.v,\r\nobj.R.R.R.v === recovered.R.R.R.v,\r\nobj.R.L.uncle === obj.L,\r\nobj.R.R.uncle === obj.L,\r\nobj.R.R.L.uncle === obj.R.L,\r\nobj.R.R.R.uncle === obj.R.L,\r\nobj.L.L.uncle === obj.R,\r\nobj.L.R.uncle === obj.R,\r\nrecovered.R.L.uncle === recovered.L,\r\nrecovered.R.R.uncle === recovered.L,\r\nrecovered.R.R.L.uncle === recovered.R.L,\r\nrecovered.R.R.R.uncle === recovered.R.L,\r\nrecovered.L.L.uncle === recovered.R,\r\nrecovered.L.R.uncle === recovered.R\r\n]\r\n)</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;pre id='the'&gt;&lt;/pre&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":3,"body":"<p>You cannot store key value without <strong>String</strong> Format.</p>\n\n<p><strong>LocalStorage</strong> only support String format for key/value.</p>\n\n<p>That is why you should convert your data to string whatever it is <em>Array</em> or <em>Object</em>.</p>\n\n<p>To Store data in localStorage first of all stringify it using <strong>JSON.stringify()</strong> method.</p>\n\n<pre><code>var myObj = [{name:\"test\", time:\"Date 2017-02-03T08:38:04.449Z\"}];\nlocalStorage.setItem('item', JSON.stringify(myObj));\n</code></pre>\n\n<p>Then when you want to retrieve data , you need to parse the String to Object again.</p>\n\n<pre><code>var getObj = JSON.parse(localStorage.getItem('item'));\n</code></pre>\n\n<p>Hope it helps.</p>\n"},{"score":-2,"body":"<p>localStorage.setItem('user', JSON.stringify(user));</p>\n\n<p>Then to retrieve it from the store and convert to an object again:</p>\n\n<p>var user = JSON.parse(localStorage.getItem('user'));</p>\n\n<p>If we need to delete all entries of the store we can simply do:</p>\n\n<p>localStorage.clear();</p>\n"},{"score":0,"body":"<h1>Circular References</h1>\n<p>In this answer I focus on data-only objects (without functions etc.) with circular references and develop ideas mention by <a href=\"https://stackoverflow.com/a/27013704/860099\">maja</a> and <a href=\"https://stackoverflow.com/a/58825573/860099\">mathheadinclouds</a> (I use his test case and\nmy code is several times shorter). Actually we can use JSON.stringify with proper <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\" rel=\"nofollow noreferrer\">replacer</a> - if source object contains multi-references to some object, or contains circular references then we reference it by special path-string (similar to <a href=\"https://jsonpath.com/\" rel=\"nofollow noreferrer\">JSONPath</a>)</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// JSON.strigify replacer for objects with circ ref\nfunction refReplacer() {\n  let m = new Map(), v= new Map(), init = null;\n\n  return function(field, value) {\n    let p= m.get(this) + (Array.isArray(this) ? `[${field}]` : '.' + field); \n    let isComplex= value===Object(value)\n    \n    if (isComplex) m.set(value, p);  \n    \n    let pp = v.get(value)||'';\n    let path = p.replace(/undefined\\.\\.?/,'');\n    let val = pp ? `#REF:${pp[0]=='[' ? '$':'$.'}${pp}` : value;\n    \n    !init ? (init=value) : (val===init ? val=\"#REF:$\" : 0);\n    if(!pp &amp;&amp; isComplex) v.set(value, path);\n   \n    return val;\n  }\n}\n\n\n// ---------------\n// TEST\n// ---------------\n\n// gen obj with duplicate/circular references\nlet obj = {\n    L: {\n        L: { v: 'lorem' },\n        R: { v: 'ipsum' }\n    },\n    R: {\n        L: { v: 'dolor' },\n        R: {\n            L: { v: 'sit' },\n            R: { v: 'amet' }\n        }\n    }\n}\nobj.R.L.uncle = obj.L;\nobj.R.R.uncle = obj.L;\nobj.R.R.L.uncle = obj.R.L;\nobj.R.R.R.uncle = obj.R.L;\nobj.L.L.uncle = obj.R;\nobj.L.R.uncle = obj.R;\ntestObject = obj;\n\nlet json = JSON.stringify(testObject, refReplacer(), 4);\n\nconsole.log(\"Test Object\\n\", testObject);\nconsole.log(\"JSON with JSONpath references\\n\",json);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>Parse such json with JSONpath-like references</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// parse json with JSONpath references to object\nfunction parseRefJSON(json) {\n  let objToPath = new Map();\n  let pathToObj = new Map();\n  let o = JSON.parse(json);\n  \n  let traverse = (parent, field) =&gt; {\n    let obj = parent;\n    let path = '#REF:$';\n\n    if (field !== undefined) {\n      obj = parent[field];\n      path = objToPath.get(parent) + (Array.isArray(parent) ? `[${field}]` : `${field?'.'+field:''}`);\n    }\n\n    objToPath.set(obj, path);\n    pathToObj.set(path, obj);\n    \n    let ref = pathToObj.get(obj);\n    if (ref) parent[field] = ref;\n\n    for (let f in obj) if (obj === Object(obj)) traverse(obj, f);\n  }\n  \n  traverse(o);\n  return o;\n}\n\n\n// ---------------\n// TEST 1\n// ---------------\n\nlet json = `\n{\n    \"L\": {\n        \"L\": {\n            \"v\": \"lorem\",\n            \"uncle\": {\n                \"L\": {\n                    \"v\": \"dolor\",\n                    \"uncle\": \"#REF:$.L\"\n                },\n                \"R\": {\n                    \"L\": {\n                        \"v\": \"sit\",\n                        \"uncle\": \"#REF:$.L.L.uncle.L\"\n                    },\n                    \"R\": {\n                        \"v\": \"amet\",\n                        \"uncle\": \"#REF:$.L.L.uncle.L\"\n                    },\n                    \"uncle\": \"#REF:$.L\"\n                }\n            }\n        },\n        \"R\": {\n            \"v\": \"ipsum\",\n            \"uncle\": \"#REF:$.L.L.uncle\"\n        }\n    },\n    \"R\": \"#REF:$.L.L.uncle\"\n}`;\n\nlet testObject = parseRefJSON(json);\n\nconsole.log(\"Test Object\\n\", testObject);\n\n\n// ---------------\n// TEST 2\n// ---------------\n\nconsole.log('Tests from mathheadinclouds anser:');\n\nlet recovered = testObject;\n\nlet obj = { // original object\n    L: {\n        L: { v: 'lorem' },\n        R: { v: 'ipsum' }\n    },\n    R: {\n        L: { v: 'dolor' },\n        R: {\n            L: { v: 'sit' },\n            R: { v: 'amet' }\n        }\n    }\n}\nobj.R.L.uncle = obj.L;\nobj.R.R.uncle = obj.L;\nobj.R.R.L.uncle = obj.R.L;\nobj.R.R.R.uncle = obj.R.L;\nobj.L.L.uncle = obj.R;\nobj.L.R.uncle = obj.R;\n\n[\n  obj.L.L.v === recovered.L.L.v,\n  obj.L.R.v === recovered.L.R.v,\n  obj.R.L.v === recovered.R.L.v,\n  obj.R.R.L.v === recovered.R.R.L.v,\n  obj.R.R.R.v === recovered.R.R.R.v,\n  obj.R.L.uncle === obj.L,\n  obj.R.R.uncle === obj.L,\n  obj.R.R.L.uncle === obj.R.L,\n  obj.R.R.R.uncle === obj.R.L,\n  obj.L.L.uncle === obj.R,\n  obj.L.R.uncle === obj.R,\n  recovered.R.L.uncle === recovered.L,\n  recovered.R.R.uncle === recovered.L,\n  recovered.R.R.L.uncle === recovered.R.L,\n  recovered.R.R.R.uncle === recovered.R.L,\n  recovered.L.L.uncle === recovered.R,\n  recovered.L.R.uncle === recovered.R\n].forEach(x=&gt; console.log('test pass: '+x));</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>To load/save result json into storage use following code</p>\n<pre><code>localStorage.myObject = JSON.stringify(testObject, refReplacer());  // save\ntestObject = parseRefJSON(localStorage.myObject);                   // load\n</code></pre>\n"}],"score":2627}