{"body":"<p>I have some HTML menus, which I show completely when a user clicks on the head of these menus. I would like to hide these elements when the user clicks outside the menus' area.</p>\n\n<p>Is something like this possible with jQuery?</p>\n\n<pre><code>$(\"#menuscontainer\").clickOutsideThisElement(function() {\n    // Hide the menus\n});\n</code></pre>\n","title":"How do I detect a click outside an element?","answers":[{"score":21,"body":"<p>Check the window click event target (it should propagate to the window, as long as it's not captured anywhere else), and ensure that it's not any of the menu elements.  If it's not, then you're outside your menu.</p>\n\n<p>Or check the position of the click, and see if it's contained within the menu area.</p>\n"},{"score":1863,"body":"<blockquote>\n  <p>NOTE: Using <code>stopEventPropagation()</code> is something that should be avoided as it breaks normal event flow in the DOM. See <a href=\"https://css-tricks.com/dangers-stopping-event-propagation/\" rel=\"noreferrer\">this article</a> for more information. Consider using <a href=\"https://stackoverflow.com/a/3028037/561309\">this method</a> instead</p>\n</blockquote>\n\n<p>Attach a click event to the document body which closes the window. Attach a separate click event to the container which stops propagation to the document body.</p>\n\n<pre><code>$(window).click(function() {\n//Hide the menus if visible\n});\n\n$('#menucontainer').click(function(event){\n    event.stopPropagation();\n});\n</code></pre>\n"},{"score":131,"body":"<p>I have an application that works similarly to Eran's example, except I attach the click event to the body when I open the menu... Kinda like this:</p>\n\n<pre><code>$('#menucontainer').click(function(event) {\n  $('html').one('click',function() {\n    // Hide the menus\n  });\n\n  event.stopPropagation();\n});\n</code></pre>\n\n<p>More information on <a href=\"http://docs.jquery.com/Events/one\" rel=\"noreferrer\">jQuery's <code>one()</code> function</a></p>\n"},{"score":145,"body":"<p>The other solutions here didn't work for me so I had to use:</p>\n\n<pre><code>if(!$(event.target).is('#foo'))\n{\n    // hide menu\n}\n</code></pre>\n"},{"score":8,"body":"<p>If you are scripting for IE and FF 3.* and you just want to know if the click occured within a certain box area, you could also use something like:</p>\n\n<pre><code>this.outsideElementClick = function(objEvent, objElement){   \nvar objCurrentElement = objEvent.target || objEvent.srcElement;\nvar blnInsideX = false;\nvar blnInsideY = false;\n\nif (objCurrentElement.getBoundingClientRect().left &gt;= objElement.getBoundingClientRect().left &amp;&amp; objCurrentElement.getBoundingClientRect().right &lt;= objElement.getBoundingClientRect().right)\n    blnInsideX = true;\n\nif (objCurrentElement.getBoundingClientRect().top &gt;= objElement.getBoundingClientRect().top &amp;&amp; objCurrentElement.getBoundingClientRect().bottom &lt;= objElement.getBoundingClientRect().bottom)\n    blnInsideY = true;\n\nif (blnInsideX &amp;&amp; blnInsideY)\n    return false;\nelse\n    return true;}\n</code></pre>\n"},{"score":42,"body":"<pre><code>$(\"#menuscontainer\").click(function() {\n    $(this).focus();\n});\n$(\"#menuscontainer\").blur(function(){\n    $(this).hide();\n});\n</code></pre>\n\n<p>Works for me just fine.</p>\n"},{"score":38,"body":"<p>Now there is a plugin for that: <a href=\"https://github.com/cowboy/jquery-outside-events\" rel=\"noreferrer\">outside events</a> (<a href=\"http://benalman.com/projects/jquery-outside-events-plugin/\" rel=\"noreferrer\">blog post</a>)</p>\n\n<p>The following happens when a <em>clickoutside</em> handler (WLOG) is bound to an element:</p>\n\n<ul>\n<li>the element is added to an array which holds all elements with <em>clickoutside</em> handlers</li>\n<li>a (<a href=\"http://docs.jquery.com/Namespaced_Events\" rel=\"noreferrer\">namespaced</a>) <em>click</em> handler is bound to the document (if not already there)</li>\n<li>on any <em>click</em> in the document, the <em>clickoutside</em> event is triggered for those elements in that array that are not equal to or a parent of the <em>click</em>-events target</li>\n<li>additionally, the event.target for the <em>clickoutside</em> event is set to the element the user clicked on (so you even know what the user clicked, not just that he clicked outside)</li>\n</ul>\n\n<p>So no events are stopped from propagation and additional <em>click</em> handlers may be used \"above\" the element with the outside-handler.</p>\n"},{"score":2,"body":"<p>This worked perfectly fine in time for me:</p>\n\n<pre><code>$('body').click(function() {\n    // Hide the menus if visible.\n});\n</code></pre>\n"},{"score":1443,"body":"<p>You can listen for a <strong>click</strong> event on <code>document</code> and then make sure <code>#menucontainer</code> is not an ancestor or the target of the clicked element by using  <a href=\"http://api.jquery.com/closest/\" rel=\"noreferrer\"><code>.closest()</code></a>.</p>\n<p>If it is not, then the clicked element is outside of the <code>#menucontainer</code> and you can safely hide it.</p>\n<pre class=\"lang-js prettyprint-override\"><code>$(document).click(function(event) { \n  var $target = $(event.target);\n  if(!$target.closest('#menucontainer').length &amp;&amp; \n  $('#menucontainer').is(&quot;:visible&quot;)) {\n    $('#menucontainer').hide();\n  }        \n});\n</code></pre>\n<h3>Edit – 2017-06-23</h3>\n<p>You can also clean up after the event listener if you plan to dismiss the menu and want to stop listening for events. This function will clean up only the newly created listener, preserving any other click listeners on <code>document</code>. With ES2015 syntax:</p>\n<pre class=\"lang-js prettyprint-override\"><code>export function hideOnClickOutside(selector) {\n  const outsideClickListener = (event) =&gt; {\n    const $target = $(event.target);\n    if (!$target.closest(selector).length &amp;&amp; $(selector).is(':visible')) {\n        $(selector).hide();\n        removeClickListener();\n    }\n  }\n\n  const removeClickListener = () =&gt; {\n    document.removeEventListener('click', outsideClickListener)\n  }\n\n  document.addEventListener('click', outsideClickListener)\n}\n</code></pre>\n<h3>Edit – 2018-03-11</h3>\n<p>For those who don't want to use jQuery. Here's the above code in plain vanillaJS (ECMAScript6).</p>\n<pre class=\"lang-js prettyprint-override\"><code>function hideOnClickOutside(element) {\n    const outsideClickListener = event =&gt; {\n        if (!element.contains(event.target) &amp;&amp; isVisible(element)) { // or use: event.target.closest(selector) === null\n          element.style.display = 'none'\n          removeClickListener()\n        }\n    }\n\n    const removeClickListener = () =&gt; {\n        document.removeEventListener('click', outsideClickListener)\n    }\n\n    document.addEventListener('click', outsideClickListener)\n}\n\nconst isVisible = elem =&gt; !!elem &amp;&amp; !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length ) // source (2018-03-11): https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js \n</code></pre>\n<p><strong>NOTE:</strong>\nThis is based on Alex comment to just use <code>!element.contains(event.target)</code> instead of the jQuery part.</p>\n<p>But <code>element.closest()</code> is now also available in all major browsers (the W3C version differs a bit from the jQuery one).\nPolyfills can be found here: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\" rel=\"noreferrer\">Element.closest()</a></p>\n<h3>Edit – 2020-05-21</h3>\n<p>In the case where you want the user to be able to click-and-drag inside the element, then release the mouse outside the element, without closing the element:</p>\n<pre><code>      ...\n      let lastMouseDownX = 0;\n      let lastMouseDownY = 0;\n      let lastMouseDownWasOutside = false;\n\n      const mouseDownListener = (event: MouseEvent) =&gt; {\n        lastMouseDownX = event.offsetX\n        lastMouseDownY = event.offsetY\n        lastMouseDownWasOutside = !$(event.target).closest(element).length\n      }\n      document.addEventListener('mousedown', mouseDownListener);\n</code></pre>\n<p>And in <code>outsideClickListener</code>:</p>\n<pre><code>const outsideClickListener = event =&gt; {\n        const deltaX = event.offsetX - lastMouseDownX\n        const deltaY = event.offsetY - lastMouseDownY\n        const distSq = (deltaX * deltaX) + (deltaY * deltaY)\n        const isDrag = distSq &gt; 3\n        const isDragException = isDrag &amp;&amp; !lastMouseDownWasOutside\n\n        if (!element.contains(event.target) &amp;&amp; isVisible(element) &amp;&amp; !isDragException) { // or use: event.target.closest(selector) === null\n          element.style.display = 'none'\n          removeClickListener()\n          document.removeEventListener('mousedown', mouseDownListener); // Or add this line to removeClickListener()\n        }\n    }\n</code></pre>\n"},{"score":4,"body":"<p>Function:</p>\n\n<pre><code>$(function() {\n    $.fn.click_inout = function(clickin_handler, clickout_handler) {\n        var item = this;\n        var is_me = false;\n        item.click(function(event) {\n            clickin_handler(event);\n            is_me = true;\n        });\n        $(document).click(function(event) {\n            if (is_me) {\n                is_me = false;\n            } else {\n                clickout_handler(event);\n            }\n        });\n        return this;\n    }\n});\n</code></pre>\n\n<p>Usage:</p>\n\n<pre><code>this.input = $('&lt;input&gt;')\n    .click_inout(\n        function(event) { me.ShowTree(event); },\n        function() { me.Hide(); }\n    )\n    .appendTo(this.node);\n</code></pre>\n\n<p>And functions are very simple:</p>\n\n<pre><code>ShowTree: function(event) {\n    this.data_span.show();\n}\nHide: function() {\n    this.data_span.hide();\n}\n</code></pre>\n"},{"score":18,"body":"<p>I've had success with something like this:</p>\n\n<pre><code>var $menuscontainer = ...;\n\n$('#trigger').click(function() {\n  $menuscontainer.show();\n\n  $('body').click(function(event) {\n    var $target = $(event.target);\n\n    if ($target.parents('#menuscontainer').length == 0) {\n      $menuscontainer.hide();\n    }\n  });\n});\n</code></pre>\n\n<p>The logic is: when <code>#menuscontainer</code> is shown, bind a click handler to the body that hides <code>#menuscontainer</code> only if the target (of the click) isn't a child of it.</p>\n"},{"score":8,"body":"<p>Use:</p>\n\n<pre><code>var go = false;\n$(document).click(function(){\n    if(go){\n        $('#divID').hide();\n        go = false;\n    }\n})\n\n$(\"#divID\").mouseover(function(){\n    go = false;\n});\n\n$(\"#divID\").mouseout(function (){\n    go = true;\n});\n\n$(\"btnID\").click( function(){\n    if($(\"#divID:visible\").length==1)\n        $(\"#divID\").hide(); // Toggle\n    $(\"#divID\").show();\n});\n</code></pre>\n"},{"score":26,"body":"<p>I don't think what you really need is to close the menu when the user clicks outside; what you need is for the menu to close when the user clicks anywhere at all on the page. If you click on the menu, or off the menu it should close right? </p>\n\n<p>Finding no satisfactory answers above prompted me to write <a href=\"http://programming34m0.blogspot.com/2011/05/simplifying-javascript-jump-menu.html\">this blog post</a> the other day. For the more pedantic, there are a number of gotchas to take note of: </p>\n\n<ol>\n<li>If you attach a click event handler to the body element at click time be sure to wait for the 2nd click before closing the menu, and unbinding the event. Otherwise the click event that opened the menu will bubble up to the listener that has to close the menu.</li>\n<li>If you use event.stopPropogation() on a click event, no other elements in your page can have a click-anywhere-to-close feature.</li>\n<li>Attaching a click event handler to the body element indefinitely is not a performant solution</li>\n<li>Comparing the target of the event, and its parents to the handler's creator assumes that what you want is to close the menu when you click off it, when what you really want is to close it when you click anywhere on the page.</li>\n<li>Listening for events on the body element will make your code more brittle. Styling as innocent as this would break it: <code>body { margin-left:auto; margin-right: auto; width:960px;}</code></li>\n</ol>\n"},{"score":14,"body":"<p>I found this method in some jQuery calendar plugin.</p>\n\n<pre><code>function ClickOutsideCheck(e)\n{\n  var el = e.target;\n  var popup = $('.popup:visible')[0];\n  if (popup==undefined)\n    return true;\n\n  while (true){\n    if (el == popup ) {\n      return true;\n    } else if (el == document) {\n      $(\".popup\").hide();\n      return false;\n    } else {\n      el = $(el).parent()[0];\n    }\n  }\n};\n\n$(document).bind('mousedown.popup', ClickOutsideCheck);\n</code></pre>\n"},{"score":6,"body":"<pre><code>$(document).click(function() {\n    $(\".overlay-window\").hide();\n});\n$(\".overlay-window\").click(function() {\n    return false;\n});\n</code></pre>\n\n<p>If you click on the document, hide a given element, unless you click on that same element.</p>\n"},{"score":5,"body":"<p>I did it like this in <a href=\"http://en.wikipedia.org/wiki/Yahoo!_UI_Library\" rel=\"nofollow\">YUI</a>&nbsp;3:</p>\n\n<pre><code>// Detect the click anywhere other than the overlay element to close it.\nY.one(document).on('click', function (e) {\n    if (e.target.ancestor('#overlay') === null &amp;&amp; e.target.get('id') != 'show' &amp;&amp; overlay.get('visible') == true) {\n        overlay.hide();\n    }\n});\n</code></pre>\n\n<p>I am checking if ancestor is not the widget element container, <br/>\nif target is not which open the widget/element, <br/>\nif widget/element I want to close is already open (not that important).</p>\n"},{"score":25,"body":"<p>As another poster said there are a lot of gotchas, especially if the element you are displaying (in this case a menu) has interactive elements.\nI've found the following method to be fairly robust:</p>\n\n<pre><code>$('#menuscontainer').click(function(event) {\n    //your code that shows the menus fully\n\n    //now set up an event listener so that clicking anywhere outside will close the menu\n    $('html').click(function(event) {\n        //check up the tree of the click target to check whether user has clicked outside of menu\n        if ($(event.target).parents('#menuscontainer').length==0) {\n            // your code to hide menu\n\n            //this event listener has done its job so we can unbind it.\n            $(this).unbind(event);\n        }\n\n    })\n});\n</code></pre>\n"},{"score":2,"body":"<p>Here is my code:</p>\n\n<pre><code>// Listen to every click\n$('html').click(function(event) {\n    if ( $('#mypopupmenu').is(':visible') ) {\n        if (event.target.id != 'click_this_to_show_mypopupmenu') {\n            $('#mypopupmenu').hide();\n        }\n    }\n});\n\n// Listen to selector's clicks\n$('#click_this_to_show_mypopupmenu').click(function() {\n\n  // If the menu is visible, and you clicked the selector again we need to hide\n  if ( $('#mypopupmenu').is(':visible') {\n      $('#mypopupmenu').hide();\n      return true;\n  }\n\n  // Else we need to show the popup menu\n  $('#mypopupmenu').show();\n});\n</code></pre>\n"},{"score":4,"body":"<p>This is my solution to this problem:</p>\n\n<pre><code>$(document).ready(function() {\n  $('#user-toggle').click(function(e) {\n    $('#user-nav').toggle();\n    e.stopPropagation();\n  });\n\n  $('body').click(function() {\n    $('#user-nav').hide(); \n  });\n\n  $('#user-nav').click(function(e){\n    e.stopPropagation();\n  });\n});\n</code></pre>\n"},{"score":2,"body":"<pre><code>jQuery().ready(function(){\n    $('#nav').click(function (event) {\n        $(this).addClass('activ');\n        event.stopPropagation();\n    });\n\n    $('html').click(function () {\n        if( $('#nav').hasClass('activ') ){\n            $('#nav').removeClass('activ');\n        }\n    });\n});\n</code></pre>\n"},{"score":6,"body":"<p>Hook a click event listener on the document. Inside the event listener, you can look at the <a href=\"http://api.jquery.com/category/events/event-object/\" rel=\"noreferrer\">event object</a>, in particular, the <a href=\"http://api.jquery.com/event.target/\" rel=\"noreferrer\">event.target</a> to see what element was clicked:</p>\n\n<pre><code>$(document).click(function(e){\n    if ($(e.target).closest(\"#menuscontainer\").length == 0) {\n        // .closest can help you determine if the element \n        // or one of its ancestors is #menuscontainer\n        console.log(\"hide\");\n    }\n});\n</code></pre>\n"},{"score":33,"body":"<p>This worked for me perfectly!!</p>\n\n<pre><code>$('html').click(function (e) {\n    if (e.target.id == 'YOUR-DIV-ID') {\n        //do something\n    } else {\n        //do something\n    }\n});\n</code></pre>\n"},{"score":2,"body":"<p>To be honest, I didn't like any of previous the solutions.</p>\n\n<p>The best way to do this, is binding the \"click\" event to the document, and comparing if that click is really outside the element (just like Art said in his suggestion).</p>\n\n<p>However, you'll have some problems there: You'll never be able to unbind it, and you cannot have an external button to open/close that element.</p>\n\n<p>That's why I wrote <a href=\"http://www.imaginacom.com/eval.php?exec=29\" rel=\"nofollow\">this small plugin (click here to link)</a>, to simplify these tasks. Could it be simpler?</p>\n\n<pre><code>&lt;a id='theButton' href=\"#\"&gt;Toggle the menu&lt;/a&gt;&lt;br/&gt;\n&lt;div id='theMenu'&gt;\n    I should be toggled when the above menu is clicked,\n    and hidden when user clicks outside.\n&lt;/div&gt;\n\n&lt;script&gt;\n$('#theButton').click(function(){\n    $('#theMenu').slideDown();\n});\n$(\"#theMenu\").dClickOutside({ ignoreList: $(\"#theButton\") }, function(clickedObj){\n    $(this).slideUp();\n});\n&lt;/script&gt;\n</code></pre>\n"},{"score":0,"body":"<p>Just a warning that using this:</p>\n\n<pre><code>$('html').click(function() {\n  // Hide the menus if visible\n});\n\n$('#menucontainer').click(function(event){\n  event.stopPropagation();\n});\n</code></pre>\n\n<p>It <strong>prevents</strong> the <a href=\"http://en.wikipedia.org/wiki/Ruby_on_Rails\" rel=\"nofollow\">Ruby on Rails</a> UJS driver from working properly. For example, <code>link_to 'click', '/url', :method =&gt; :delete</code> will not work.</p>\n\n<p>This might be a workaround:</p>\n\n<pre><code>$('html').click(function() {\n  // Hide the menus if visible\n});\n\n$('#menucontainer').click(function(event){\n  if (!$(event.target).data('method')) {\n    event.stopPropagation();\n  }\n});\n</code></pre>\n"},{"score":4,"body":"<p>This should work:</p>\n\n<pre><code>$('body').click(function (event) {\n    var obj = $(event.target);\n    obj = obj['context']; // context : clicked element inside body\n    if ($(obj).attr('id') != \"menuscontainer\" &amp;&amp; $('#menuscontainer').is(':visible') == true) {\n        //hide menu\n    }\n});\n</code></pre>\n"},{"score":-2,"body":"<pre><code> &lt;div class=\"feedbackCont\" onblur=\"hidefeedback();\"&gt;\n        &lt;div class=\"feedbackb\" onclick=\"showfeedback();\" &gt;&lt;/div&gt;\n        &lt;div class=\"feedbackhide\" tabindex=\"1\"&gt; &lt;/div&gt;\n &lt;/div&gt;\n\nfunction hidefeedback(){\n    $j(\".feedbackhide\").hide();\n}\n\nfunction showfeedback(){\n    $j(\".feedbackhide\").show();\n    $j(\".feedbackCont\").attr(\"tabindex\",1).focus();\n}\n</code></pre>\n\n<p>This is the simplest solution I came up with. </p>\n"},{"score":3,"body":"<p>One more solution is here:</p>\n\n<p><a href=\"http://jsfiddle.net/zR76D/\" rel=\"nofollow\">http://jsfiddle.net/zR76D/</a></p>\n\n<p>Usage:</p>\n\n<pre><code>&lt;div onClick=\"$('#menu').toggle();$('#menu').clickOutside(function() { $(this).hide(); $(this).clickOutside('disable'); });\"&gt;Open / Close Menu&lt;/div&gt;\n&lt;div id=\"menu\" style=\"display: none; border: 1px solid #000000; background: #660000;\"&gt;I am a menu, whoa is me.&lt;/div&gt;\n</code></pre>\n\n<p>Plugin:</p>\n\n<pre><code>(function($) {\n    var clickOutsideElements = [];\n    var clickListener = false;\n\n    $.fn.clickOutside = function(options, ignoreFirstClick) {\n        var that = this;\n        if (ignoreFirstClick == null) ignoreFirstClick = true;\n\n        if (options != \"disable\") {\n            for (var i in clickOutsideElements) {\n                if (clickOutsideElements[i].element[0] == $(this)[0]) return this;\n            }\n\n            clickOutsideElements.push({ element : this, clickDetected : ignoreFirstClick, fnc : (typeof(options) != \"function\") ? function() {} : options });\n\n            $(this).on(\"click.clickOutside\", function(event) {\n                for (var i in clickOutsideElements) {\n                    if (clickOutsideElements[i].element[0] == $(this)[0]) {\n                        clickOutsideElements[i].clickDetected = true;\n                    }\n                }\n            });\n\n            if (!clickListener) {\n                if (options != null &amp;&amp; typeof(options) == \"function\") {\n                    $('html').click(function() {\n                        for (var i in clickOutsideElements) {\n                            if (!clickOutsideElements[i].clickDetected) {\n                                clickOutsideElements[i].fnc.call(that);\n                            }\n                            if (clickOutsideElements[i] != null) clickOutsideElements[i].clickDetected = false;\n                        }\n                    });\n                    clickListener = true;\n                }\n            }\n        }\n        else {\n            $(this).off(\"click.clickoutside\");\n            for (var i = 0; i &lt; clickOutsideElements.length; ++i) {\n                if (clickOutsideElements[i].element[0] == $(this)[0]) {\n                    clickOutsideElements.splice(i, 1);\n                }\n            }\n        }\n\n        return this;\n    }\n})(jQuery);\n</code></pre>\n"},{"score":2,"body":"<p>The broadest way to do this is to select everything on the web page except the element where you don't want clicks detected and bind the click event those when the menu is opened. </p>\n\n<p>Then when the menu is closed remove the binding.</p>\n\n<p>Use .stopPropagation to prevent the event from affecting any part of the menuscontainer.</p>\n\n<pre><code>$(\"*\").not($(\"#menuscontainer\")).bind(\"click.OutsideMenus\", function ()\n{\n    // hide the menus\n\n    //then remove all of the handlers\n    $(\"*\").unbind(\".OutsideMenus\");\n});\n\n$(\"#menuscontainer\").bind(\"click.OutsideMenus\", function (event) \n{\n    event.stopPropagation(); \n});\n</code></pre>\n"},{"score":4,"body":"<p>The solutions here work fine <strong>when only one element is to be managed</strong>. If there are multiple elements, however, the problem is much more complicated. Tricks with e.stopPropagation() and all the others will not work.</p>\n\n<p>I came up with a <strong>solution</strong>, and maybe it is not so easy, but it's better than nothing. Have a look:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>$view.on(\"click\", function(e) {\n\n    if(model.isActivated()) return;\n\n        var watchUnclick = function() {\n            rootView.one(\"mouseleave\", function() {\n                $(document).one(\"click\", function() {\n                    model.deactivate();\n                });\n                rootView.one(\"mouseenter\", function() {\n                    watchUnclick();\n                });\n            });\n        };\n        watchUnclick();\n        model.activate();\n    });\n</code></pre>\n"},{"score":8,"body":"<p>Instead using flow interruption, blur/focus event or any other tricky technics, simply match event flow with element's kinship:</p>\n\n<pre><code>$(document).on(\"click.menu-outside\", function(event){\n    // Test if target and it's parent aren't #menuscontainer\n    // That means the click event occur on other branch of document tree\n    if(!$(event.target).parents().andSelf().is(\"#menuscontainer\")){\n        // Click outisde #menuscontainer\n        // Hide the menus (but test if menus aren't already hidden)\n    }\n});\n</code></pre>\n\n<p>To remove click outside event listener, simply:</p>\n\n<pre><code>$(document).off(\"click.menu-outside\");\n</code></pre>\n"},{"score":3,"body":"<p>The answer marked as the accepted answer does not take into account that you can have overlays over the element, like dialogs, popovers, datepickers, etc. Clicks in these should not hide the element.</p>\n\n<p>I have made my own version that does take this into account. It's created as a <a href=\"http://en.wikipedia.org/wiki/KnockoutJS\" rel=\"nofollow\">KnockoutJS</a> binding, but it can easily be converted to jQuery-only.</p>\n\n<p>It works by the first query for all elements with either z-index or absolute position that are visible. It then hit tests those elements against the element I want to hide if click outside. If it's a hit I calculate a new bound rectangle which takes into account the overlay bounds.</p>\n\n<pre><code>ko.bindingHandlers.clickedIn = (function () {\n    function getBounds(element) {\n        var pos = element.offset();\n        return {\n            x: pos.left,\n            x2: pos.left + element.outerWidth(),\n            y: pos.top,\n            y2: pos.top + element.outerHeight()\n        };\n    }\n\n    function hitTest(o, l) {\n        function getOffset(o) {\n            for (var r = { l: o.offsetLeft, t: o.offsetTop, r: o.offsetWidth, b: o.offsetHeight };\n                o = o.offsetParent; r.l += o.offsetLeft, r.t += o.offsetTop);\n            return r.r += r.l, r.b += r.t, r;\n        }\n\n        for (var b, s, r = [], a = getOffset(o), j = isNaN(l.length), i = (j ? l = [l] : l).length; i;\n            b = getOffset(l[--i]), (a.l == b.l || (a.l &gt; b.l ? a.l &lt;= b.r : b.l &lt;= a.r))\n                &amp;&amp; (a.t == b.t || (a.t &gt; b.t ? a.t &lt;= b.b : b.t &lt;= a.b)) &amp;&amp; (r[r.length] = l[i]));\n        return j ? !!r.length : r;\n    }\n\n    return {\n        init: function (element, valueAccessor) {\n            var target = valueAccessor();\n            $(document).click(function (e) {\n                if (element._clickedInElementShowing === false &amp;&amp; target()) {\n                    var $element = $(element);\n                    var bounds = getBounds($element);\n\n                    var possibleOverlays = $(\"[style*=z-index],[style*=absolute]\").not(\":hidden\");\n                    $.each(possibleOverlays, function () {\n                        if (hitTest(element, this)) {\n                            var b = getBounds($(this));\n                            bounds.x = Math.min(bounds.x, b.x);\n                            bounds.x2 = Math.max(bounds.x2, b.x2);\n                            bounds.y = Math.min(bounds.y, b.y);\n                            bounds.y2 = Math.max(bounds.y2, b.y2);\n                        }\n                    });\n\n                    if (e.clientX &lt; bounds.x || e.clientX &gt; bounds.x2 ||\n                        e.clientY &lt; bounds.y || e.clientY &gt; bounds.y2) {\n\n                        target(false);\n                    }\n                }\n                element._clickedInElementShowing = false;\n            });\n\n            $(element).click(function (e) {\n                e.stopPropagation();\n            });\n        },\n        update: function (element, valueAccessor) {\n            var showing = ko.utils.unwrapObservable(valueAccessor());\n            if (showing) {\n                element._clickedInElementShowing = true;\n            }\n        }\n    };\n})();\n</code></pre>\n"},{"score":1,"body":"<p>This is a more general solution that <strong>allows multiple elements to be watched, and dynamically adding and removing elements from the queue</strong>.</p>\n\n<p>It holds a global queue (<strong>autoCloseQueue</strong>) - an object container for elements that should be closed on outside clicks. </p>\n\n<p>Each queue object key should be the DOM Element id, and the value should be an object with 2 callback functions: </p>\n\n<pre><code> {onPress: someCallbackFunction, onOutsidePress: anotherCallbackFunction}\n</code></pre>\n\n<p>Put this in your document ready callback:</p>\n\n<pre><code>window.autoCloseQueue = {}  \n\n$(document).click(function(event) {\n    for (id in autoCloseQueue){\n        var element = autoCloseQueue[id];\n        if ( ($(e.target).parents('#' + id).length) &gt; 0) { // This is a click on the element (or its child element)\n            console.log('This is a click on an element (or its child element) with  id: ' + id);\n            if (typeof element.onPress == 'function') element.onPress(event, id);\n        } else { //This is a click outside the element\n            console.log('This is a click outside the element with id: ' + id);\n            if (typeof element.onOutsidePress == 'function') element.onOutsidePress(event, id); //call the outside callback\n            delete autoCloseQueue[id]; //remove the element from the queue\n        }\n    }\n});\n</code></pre>\n\n<p>Then, when the DOM element with id  '<strong>menuscontainer</strong>' is created, just add this object to the queue: </p>\n\n<pre><code>window.autoCloseQueue['menuscontainer'] = {onOutsidePress: clickOutsideThisElement}\n</code></pre>\n"},{"score":4,"body":"<p>I ended up doing something like this:</p>\n\n<pre><code>$(document).on('click', 'body, #msg_count_results .close',function() {\n    $(document).find('#msg_count_results').remove();\n});\n$(document).on('click','#msg_count_results',function(e) {\n    e.preventDefault();\n    return false;\n});\n</code></pre>\n\n<p>I have a close button within the new container for end users friendly UI purposes. I had to use return false in order to not go through. Of course, having an A HREF on there to take you somewhere would be nice, or you could call some ajax stuff instead. Either way, it works ok for me. Just what I wanted.</p>\n"},{"score":-2,"body":"<p>Try this code:</p>\n\n<pre><code>if ($(event.target).parents().index($('#searchFormEdit')) == -1 &amp;&amp;\n    $(event.target).parents().index($('.DynarchCalendar-topCont')) == -1 &amp;&amp;\n    (_x &lt; os.left || _x &gt; (os.left + 570) || _y &lt; os.top || _y &gt; (os.top + 155)) &amp;&amp;\n    isShowEditForm) {\n\n    setVisibleEditForm(false);\n}\n</code></pre>\n"},{"score":-1,"body":"<p>You can set a tabindex to the <a href=\"http://en.wikipedia.org/wiki/Document_Object_Model\" rel=\"nofollow\">DOM</a> element. This will trigger a blur event when the user click outside the DOM element.</p>\n\n<p><a href=\"http://jsbin.com/fuloqixe/5\" rel=\"nofollow\">Demo</a></p>\n\n<pre><code>&lt;div tabindex=\"1\"&gt;\n    Focus me\n&lt;/div&gt;\n\ndocument.querySelector(\"div\").onblur = function(){\n   console.log('clicked outside')\n}\ndocument.querySelector(\"div\").onfocus = function(){\n   console.log('clicked inside')\n}\n</code></pre>\n"},{"score":0,"body":"<p>This will toggle the Nav menu when you click on/off the element.     </p>\n\n<pre><code>$(document).on('click', function(e) {\n    var elem = $(e.target).closest('#menu'),\n    box = $(e.target).closest('#nav');\n if (elem.length) {\n    e.preventDefault();\n    $('#nav').toggle();\n  } else if (!box.length) {\n    $('#nav').hide();\n }\n});\n\n\n\n&lt;li id=\"menu\"&gt;&lt;a&gt;&lt;/a&gt;&lt;/li&gt;\n&lt;ul id=\"nav\" &gt;  //Nav will toggle when you Click on Menu(it can be an icon in this example)\n        &lt;li class=\"page\"&gt;&lt;a&gt;Page1&lt;/a&gt;&lt;/li&gt;\n        &lt;li class=\"page\"&gt;&lt;a&gt;Pag2&lt;/a&gt;&lt;/li&gt;\n        &lt;li class=\"page\"&gt;&lt;a&gt;Page3&lt;/a&gt;&lt;/li&gt;            \n        &lt;li class=\"page\"&gt;&lt;a&gt;Page4&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n"},{"score":-2,"body":"<p>Standard HTML:</p>\n\n<p>Surround the menus by a <code>&lt;label&gt;</code> and fetch focus state changes.</p>\n\n<p><a href=\"http://jsfiddle.net/bK3gL/\" rel=\"nofollow\">http://jsfiddle.net/bK3gL/</a></p>\n\n<p>Plus: you can unfold the menu by <kbd>Tab</kbd>.</p>\n"},{"score":-1,"body":"<p>As a <a href=\"https://stackoverflow.com/a/3028037/1366033\">wrapper to this great answer from Art</a>, and to use the syntax originally requested by OP, here's a jQuery extension that can record wether a click occured outside of a set element.</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>$.fn.clickOutsideThisElement = function (callback) {\n    return this.each(function () {\n        var self = this;\n        $(document).click(function (e) {\n            if (!$(e.target).closest(self).length) {\n                callback.call(self, e)\n            }\n        })\n    });\n};\n</code></pre>\n\n<p>Then you can call like this:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>$(\"#menuscontainer\").clickOutsideThisElement(function() {\n    // handle menu toggle\n});\n</code></pre>\n\n<h2><a href=\"http://jsfiddle.net/KyleMit/Fv2fY/\" rel=\"nofollow noreferrer\">Here's a demo in fiddle</a></h2>\n"},{"score":16,"body":"<p>As a variant:</p>\n\n<pre><code>var $menu = $('#menucontainer');\n$(document).on('click', function (e) {\n\n    // If element is opened and click target is outside it, hide it\n    if ($menu.is(':visible') &amp;&amp; !$menu.is(e.target) &amp;&amp; !$menu.has(e.target).length) {\n        $menu.hide();\n    }\n});\n</code></pre>\n\n<p>It has no problem with <a href=\"http://css-tricks.com/dangers-stopping-event-propagation/\" rel=\"noreferrer\">stopping event propagation</a> and better supports multiple menus on the same page where clicking on a second menu while a first is open will leave the first open in the stopPropagation solution.</p>\n"},{"score":3,"body":"<p>For touch devices like iPad and iPhone we can use this code:</p>\n\n<pre><code>$(document).on('touchstart', function (event) {\n    var container = $(\"YOUR CONTAINER SELECTOR\");\n\n    if (!container.is(e.target) &amp;&amp;            // If the target of the click isn't the container...\n        container.has(e.target).length === 0) // ... nor a descendant of the container\n    {\n        container.hide();\n    }\n});\n</code></pre>\n"},{"score":-1,"body":"<p>Using not():</p>\n\n<pre><code>$(\"#id\").not().click(function() {\n    alert('Clicked other that #id');\n});\n</code></pre>\n"},{"score":-2,"body":"<pre><code>$(\"body &gt; div:not(#dvid)\").click(function (e) {\n    //your code\n}); \n</code></pre>\n"},{"score":-2,"body":"<pre><code>$(\"html\").click(function(){\n    if($('#info').css(\"opacity\")&gt;0.9) {\n        $('#info').fadeOut('fast');\n    }\n});\n</code></pre>\n"},{"score":22,"body":"<h2><strong>Solution1</strong></h2>\n\n<p>Instead of using event.stopPropagation() which can have some side affects, just define a simple flag variable and add one <code>if</code> condition. I tested this and worked properly without any side affects of stopPropagation:</p>\n\n<pre><code>var flag = \"1\";\n$('#menucontainer').click(function(event){\n    flag = \"0\"; // flag 0 means click happened in the area where we should not do any action\n});\n\n$('html').click(function() {\n    if(flag != \"0\"){\n        // Hide the menus if visible\n    }\n    else {\n        flag = \"1\";\n    }\n});\n</code></pre>\n\n<h2><strong>Solution2</strong></h2>\n\n<p>With just a simple <code>if</code> condition:</p>\n\n<pre><code>$(document).on('click', function(event){\n    var container = $(\"#menucontainer\");\n    if (!container.is(event.target) &amp;&amp;            // If the target of the click isn't the container...\n        container.has(event.target).length === 0) // ... nor a descendant of the container\n    {\n        // Do whatever you want to do when click is outside the element\n    }\n});\n</code></pre>\n"},{"score":13,"body":"<p>Here is the vanilla JavaScript solution for future viewers.</p>\n\n<p>Upon clicking any element within the document, if the clicked element's id is toggled, or the hidden element is not hidden and the hidden element does not contain the clicked element, toggle the element.</p>\n\n<pre><code>(function () {\n    \"use strict\";\n    var hidden = document.getElementById('hidden');\n    document.addEventListener('click', function (e) {\n        if (e.target.id == 'toggle' || (hidden.style.display != 'none' &amp;&amp; !hidden.contains(e.target))) hidden.style.display = hidden.style.display == 'none' ? 'block' : 'none';\n    }, false);\n})();\n</code></pre>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>(function () {\r\n    \"use strict\";\r\n    var hidden = document.getElementById('hidden');\r\n    document.addEventListener('click', function (e) {\r\n        if (e.target.id == 'toggle' || (hidden.style.display != 'none' &amp;&amp; !hidden.contains(e.target))) hidden.style.display = hidden.style.display == 'none' ? 'block' : 'none';\r\n    }, false);\r\n})();</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;a href=\"javascript:void(0)\" id=\"toggle\"&gt;Toggle Hidden Div&lt;/a&gt;\r\n&lt;div id=\"hidden\" style=\"display: none;\"&gt;This content is normally hidden. click anywhere other than this content to make me disappear&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>If you are going to have multiple toggles on the same page you can use something like this:</p>\n\n<ol>\n<li>Add the class name <code>hidden</code> to the collapsible item.</li>\n<li>Upon document click, close all hidden elements which do not contain the clicked element and are not hidden</li>\n<li>If the clicked element is a toggle, toggle the specified element.</li>\n</ol>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>(function () {\r\n    \"use strict\";\r\n    var hiddenItems = document.getElementsByClassName('hidden'), hidden;\r\n    document.addEventListener('click', function (e) {\r\n        for (var i = 0; hidden = hiddenItems[i]; i++) {\r\n            if (!hidden.contains(e.target) &amp;&amp; hidden.style.display != 'none')\r\n                hidden.style.display = 'none';\r\n        }\r\n        if (e.target.getAttribute('data-toggle')) {\r\n            var toggle = document.querySelector(e.target.getAttribute('data-toggle'));\r\n            toggle.style.display = toggle.style.display == 'none' ? 'block' : 'none';\r\n        }\r\n    }, false);\r\n})();</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;a href=\"javascript:void(0)\" data-toggle=\"#hidden1\"&gt;Toggle Hidden Div&lt;/a&gt;\r\n&lt;div class=\"hidden\" id=\"hidden1\" style=\"display: none;\" data-hidden=\"true\"&gt;This content is normally hidden&lt;/div&gt;\r\n&lt;a href=\"javascript:void(0)\" data-toggle=\"#hidden2\"&gt;Toggle Hidden Div&lt;/a&gt;\r\n&lt;div class=\"hidden\" id=\"hidden2\" style=\"display: none;\" data-hidden=\"true\"&gt;This content is normally hidden&lt;/div&gt;\r\n&lt;a href=\"javascript:void(0)\" data-toggle=\"#hidden3\"&gt;Toggle Hidden Div&lt;/a&gt;\r\n&lt;div class=\"hidden\" id=\"hidden3\" style=\"display: none;\" data-hidden=\"true\"&gt;This content is normally hidden&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":5,"body":"<p>We implemented a solution, partly based off a comment from a user above, which works perfectly for us. We use it to hide a search box / results when clicking outside those elements, excluding the element that originally.</p>\n\n<pre><code>// HIDE SEARCH BOX IF CLICKING OUTSIDE\n$(document).click(function(event){ \n    // IF NOT CLICKING THE SEARCH BOX OR ITS CONTENTS OR SEARCH ICON \n    if ($(\"#search-holder\").is(\":visible\") &amp;&amp; !$(event.target).is(\"#search-holder *, #search\")) {\n        $(\"#search-holder\").fadeOut('fast');\n        $(\"#search\").removeClass('active');\n    }\n});\n</code></pre>\n\n<p>It checks if the search box is already visible first also, and in our case, it's also removing an active class on the hide/show search button.</p>\n"},{"score":6,"body":"<p>Upvote for the most popular answer, but add </p>\n\n<pre><code>&amp;&amp; (e.target != $('html').get(0)) // ignore the scrollbar\n</code></pre>\n\n<p>so, a click on a scroll bar does not [hide or whatever] your target element.</p>\n"},{"score":-2,"body":"<p>This is a classic case of where a tweak to the HTML would be a better solution. Why not set the click on the elements which don't contain the menu item? Then you don't need to add the propagation.</p>\n\n<pre><code>$('.header, .footer, .main-content').click(function() {\n//Hide the menus if visible\n});\n</code></pre>\n"},{"score":-1,"body":"<p><strong>Outside click plugin!</strong></p>\n\n<p><strong>Usage:</strong></p>\n\n<pre><code>$('.target-element').outsideClick(function(event){\n    //code that fires when user clicks outside the element\n    //event = the click event\n    //$(this) = the '.target-element' that is firing this function \n}, '.excluded-element')\n</code></pre>\n\n<p><strong>The code for it:</strong></p>\n\n<pre><code>(function($) {\n\n//when the user hits the escape key, it will trigger all outsideClick functions\n$(document).on(\"keyup\", function (e) {\n    if (e.which == 27) $('body').click(); //escape key\n});\n\n//The actual plugin\n$.fn.outsideClick = function(callback, exclusions) {\n    var subject = this;\n\n    //test if exclusions have been set\n    var hasExclusions = typeof exclusions !== 'undefined';\n\n    //switches click event with touch event if on a touch device\n    var ClickOrTouchEvent = \"ontouchend\" in document ? \"touchend\" : \"click\";\n\n    $('body').on(ClickOrTouchEvent, function(event) {\n        //click target does not contain subject as a parent\n        var clickedOutside = !$(event.target).closest(subject).length;\n\n        //click target was on one of the excluded elements\n        var clickedExclusion = $(event.target).closest(exclusions).length;\n\n        var testSuccessful;\n\n        if (hasExclusions) {\n            testSuccessful = clickedOutside &amp;&amp; !clickedExclusion;\n        } else {\n            testSuccessful = clickedOutside;\n        }\n\n        if(testSuccessful) {\n            callback.call(subject, event);\n        }\n    });\n\n    return this;\n};\n\n}(jQuery));\n</code></pre>\n\n<p>Adapted from this answer <a href=\"https://stackoverflow.com/a/3028037/1611058\">https://stackoverflow.com/a/3028037/1611058</a></p>\n"},{"score":47,"body":"<p>After research I have found three working solutions (I forgot the page links for reference)</p>\n\n<h2>First solution</h2>\n\n<pre><code>&lt;script&gt;\n    //The good thing about this solution is it doesn't stop event propagation.\n\n    var clickFlag = 0;\n    $('body').on('click', function () {\n        if(clickFlag == 0) {\n            console.log('hide element here');\n            /* Hide element here */\n        }\n        else {\n            clickFlag=0;\n        }\n    });\n    $('body').on('click','#testDiv', function (event) {\n        clickFlag = 1;\n        console.log('showed the element');\n        /* Show the element */\n    });\n&lt;/script&gt;\n</code></pre>\n\n<h2>Second solution</h2>\n\n<pre><code>&lt;script&gt;\n    $('body').on('click', function(e) {\n        if($(e.target).closest('#testDiv').length == 0) {\n           /* Hide dropdown here */\n        }\n    });\n&lt;/script&gt;\n</code></pre>\n\n<h2>Third solution</h2>\n\n<pre><code>&lt;script&gt;\n    var specifiedElement = document.getElementById('testDiv');\n    document.addEventListener('click', function(event) {\n        var isClickInside = specifiedElement.contains(event.target);\n        if (isClickInside) {\n          console.log('You clicked inside')\n        }\n        else {\n          console.log('You clicked outside')\n        }\n    });\n&lt;/script&gt;\n</code></pre>\n"},{"score":0,"body":"<pre><code>    $('#menucontainer').click(function(e){\n        e.stopPropagation();\n     });\n\n    $(document).on('click',  function(e){\n        // code\n    });\n</code></pre>\n"},{"score":26,"body":"<p>A simple solution for the situation is:</p>\n\n<pre><code>$(document).mouseup(function (e)\n{\n    var container = $(\"YOUR SELECTOR\"); // Give you class or ID\n\n    if (!container.is(e.target) &amp;&amp;            // If the target of the click is not the desired div or section\n        container.has(e.target).length === 0) // ... nor a descendant-child of the container\n    {\n        container.hide();\n    }\n});\n</code></pre>\n\n<p>The above script will hide the <code>div</code> if outside of the <code>div</code> click event is triggered.</p>\n\n<p>You can see the following blog for more information : <a href=\"http://www.codecanal.com/detect-click-outside-div-using-javascript/\" rel=\"noreferrer\">http://www.codecanal.com/detect-click-outside-div-using-javascript/</a></p>\n"},{"score":0,"body":"<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>$('html').click(function() {\r\n//Hide the menus if visible\r\n});\r\n\r\n$('#menucontainer').click(function(event){\r\n    event.stopPropagation();\r\n});</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;\r\n&lt;html&gt;\r\n &lt;button id='#menucontainer'&gt;Ok&lt;/button&gt; \r\n&lt;/html&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":0,"body":"<p>Have a try of this:</p>\n\n<pre><code>$('html').click(function(e) {\n  if($(e.target).parents('#menuscontainer').length == 0) {\n    $('#menuscontainer').hide();\n  }\n});\n</code></pre>\n\n<p><a href=\"https://jsfiddle.net/4cj4jxy0/\" rel=\"nofollow\">https://jsfiddle.net/4cj4jxy0/</a></p>\n\n<p>But note that this cannot work if the click event cannot reach the <code>html</code> tag. (Maybe other elements have <code>stopPropagation()</code>).</p>\n"},{"score":0,"body":"<p>Subscribe <em>capturing phase</em> of click to handle click on elements which call <code>preventDefault</code>.<br>\nRetrigger it on document element using the other name <code>click-anywhere</code>.</p>\n\n<pre><code>document.addEventListener('click', function (event) {\n  event = $.event.fix(event);\n  event.type = 'click-anywhere';\n  $document.trigger(event);\n}, true);\n</code></pre>\n\n<p>Then where you need click outside functionality subscribe on <code>click-anywhere</code> event on <code>document</code> and check if the click was outside of the element you are interested in:</p>\n\n<pre><code>$(document).on('click-anywhere', function (event) {\n  if (!$(event.target).closest('#smth').length) {\n    // Do anything you need here\n  }\n});\n</code></pre>\n\n<p>Some notes:</p>\n\n<ul>\n<li><p>You have to use <code>document</code> as it would be a perfomance fault to trigger event on all elements outside of which the click occured.</p></li>\n<li><p>This functionality can be wrapped into special plugin, which calls some callback on outside click.</p></li>\n<li><p>You can't subscribe capturing phase using jQuery itself.</p></li>\n<li><p>You don't need document load to subscribe as subscription is on <code>document</code>, even not on its <code>body</code>, so it exists always independently ащкь script placement and load status.</p></li>\n</ul>\n"},{"score":5,"body":"<p>For easier use, and more expressive code, I created a jQuery plugin for this:</p>\n\n<pre><code>$('div.my-element').clickOut(function(target) { \n    //do something here... \n});\n</code></pre>\n\n<p>Note:  <strong>target</strong> is the element the user actually clicked.  But callback is still executed in the context of the original element, so you can utilize <strong>this</strong> as you'd expect in a jQuery callback.</p>\n\n<p>Plugin:</p>\n\n<pre><code>$.fn.clickOut = function (parent, fn) {\n    var context = this;\n    fn = (typeof parent === 'function') ? parent : fn;\n    parent = (parent instanceof jQuery) ? parent : $(document);\n\n    context.each(function () {\n        var that = this;\n        parent.on('click', function (e) {\n            var clicked = $(e.target);\n            if (!clicked.is(that) &amp;&amp; !clicked.parents().is(that)) {\n                if (typeof fn === 'function') {\n                    fn.call(that, clicked);\n                }\n            }\n        });\n\n    });\n    return context;\n};\n</code></pre>\n\n<p>By default, the click event listener is placed on the document.  However, if you want to limit the event listener scope, you can pass in a jQuery object representing a parent level element that will be the top parent at which clicks will be listened to.  This prevents unnecessary document level event listeners.  Obviously, it won't work unless the parent element supplied is a parent of your initial element. </p>\n\n<p>Use like so:</p>\n\n<pre><code>$('div.my-element').clickOut($('div.my-parent'), function(target) { \n    //do something here...\n});\n</code></pre>\n"},{"score":0,"body":"\n\n<pre class=\"lang-js prettyprint-override\"><code>$(document).on('click.menu.hide', function(e){\n  if ( !$(e.target).closest('#my_menu').length ) {\n    $('#my_menu').find('ul').toggleClass('active', false);\n  }\n});\n\n$(document).on('click.menu.show', '#my_menu li', function(e){\n  $(this).find('ul').toggleClass('active');\n});\n</code></pre>\n\n<pre class=\"lang-css prettyprint-override\"><code>div {\n  float: left;\n}\n\nul {\n  padding: 0;\n  position: relative;\n}\nul li {\n  padding: 5px 25px 5px 10px;\n  border: 1px solid silver;\n  cursor: pointer;\n  list-style: none;\n  margin-top: -1px;\n  white-space: nowrap;\n}\nul li ul:before {\n  margin-right: -20px;\n  position: absolute;\n  top: -17px;\n  right: 0;\n  content: \"\\25BC\";\n}\nul li ul li {\n  visibility: hidden;\n  height: 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  border-width: 0 0 1px 0;\n}\nul li ul li:last-child {\n  border: none;\n}\nul li ul.active:before {\n  content: \"\\25B2\";\n}\nul li ul.active li {\n  display: list-item;\n  visibility: visible;\n  height: inherit;\n  padding: 5px 25px 5px 10px;\n}\n</code></pre>\n\n<pre class=\"lang-html prettyprint-override\"><code>&lt;script src=\"https://code.jquery.com/jquery-2.1.4.js\"&gt;&lt;/script&gt;\n&lt;div&gt;\n  &lt;ul id=\"my_menu\"&gt;\n    &lt;li&gt;Menu 1\n      &lt;ul&gt;\n        &lt;li&gt;subMenu 1&lt;/li&gt;\n        &lt;li&gt;subMenu 2&lt;/li&gt;\n        &lt;li&gt;subMenu 3&lt;/li&gt;\n        &lt;li&gt;subMenu 4&lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/li&gt;\n    &lt;li&gt;Menu 2\n      &lt;ul&gt;\n        &lt;li&gt;subMenu 1&lt;/li&gt;\n        &lt;li&gt;subMenu 2&lt;/li&gt;\n        &lt;li&gt;subMenu 3&lt;/li&gt;\n        &lt;li&gt;subMenu 4&lt;/li&gt;\n      &lt;/ul&gt;\n    &lt;/li&gt;\n    &lt;li&gt;Menu 3&lt;/li&gt;\n    &lt;li&gt;Menu 4&lt;/li&gt;\n    &lt;li&gt;Menu 5&lt;/li&gt;\n    &lt;li&gt;Menu 6&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n</code></pre>\n\n\n\n<p>Here is jsbin version <a href=\"http://jsbin.com/xopacadeni/edit?html,css,js,output\" rel=\"nofollow\">http://jsbin.com/xopacadeni/edit?html,css,js,output</a></p>\n"},{"score":328,"body":"<blockquote>\n<p>How to detect a click outside an element?</p>\n</blockquote>\n<p>The reason that this question is so popular and has so many answers is that it is deceptively complex. After almost eight years and dozens of answers, I am genuinely surprised to see how little care has been given to accessibility.</p>\n<blockquote>\n<p>I would like to hide these elements when the user clicks outside the menus' area.</p>\n</blockquote>\n<p>This is a noble cause and is the <em>actual</em> issue. The title of the question—which is what most answers appear to attempt to address—contains an unfortunate red herring.</p>\n<p><strong>Hint: it's the word <em>&quot;click&quot;</em>!</strong></p>\n<h1>You don't actually want to bind click handlers.</h1>\n<p>If you're binding click handlers to close the dialog, you've already failed. The reason you've failed is that not everyone triggers <code>click</code> events. Users not using a mouse will be able to escape your dialog (and your pop-up menu is arguably a type of dialog) by pressing <kbd>Tab</kbd>, and they then won't be able to read the content behind the dialog without subsequently triggering a <code>click</code> event.</p>\n<p>So let's rephrase the question.</p>\n<blockquote>\n<p>How does one close a dialog when a user is finished with it?</p>\n</blockquote>\n<p>This is the goal. Unfortunately, now we need to bind the <code>userisfinishedwiththedialog</code> event, and that binding isn't so straightforward.</p>\n<p>So how can we detect that a user has finished using a dialog?</p>\n<h2><code>focusout</code> event</h2>\n<p>A good start is to determine if focus has left the dialog.</p>\n<p><strong>Hint: be careful with the <code>blur</code> event, <code>blur</code> doesn't propagate if the event was bound to the bubbling phase!</strong></p>\n<p>jQuery's <a href=\"http://api.jquery.com/focusout/\" rel=\"noreferrer\"><code>focusout</code></a> will do just fine. If you can't use jQuery, then you can use <code>blur</code> during the capturing phase:</p>\n<pre><code>element.addEventListener('blur', ..., true);\n//                       use capture: ^^^^\n</code></pre>\n<p>Also, for many dialogs you'll need to allow the container to gain focus. Add <code>tabindex=&quot;-1&quot;</code> to allow the dialog to receive focus dynamically without otherwise interrupting the tabbing flow.</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>$('a').on('click', function () {\n  $(this.hash).toggleClass('active').focus();\n});\n\n$('div').on('focusout', function () {\n  $(this).removeClass('active');\n});</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>div {\n  display: none;\n}\n.active {\n  display: block;\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;\n&lt;a href=\"#example\"&gt;Example&lt;/a&gt;\n&lt;div id=\"example\" tabindex=\"-1\"&gt;\n  Lorem ipsum &lt;a href=\"http://example.com\"&gt;dolor&lt;/a&gt; sit amet.\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<hr />\n<p>If you play with that demo for more than a minute you should quickly start seeing issues.</p>\n<p>The first is that the link in the dialog isn't clickable. Attempting to click on it or tab to it will lead to the dialog closing before the interaction takes place. This is because focusing the inner element triggers a <code>focusout</code> event before triggering a <code>focusin</code> event again.</p>\n<p>The fix is to queue the state change on the event loop. This can be done by using <code>setImmediate(...)</code>, or <code>setTimeout(..., 0)</code> for browsers that don't support <code>setImmediate</code>. Once queued it can be cancelled by a subsequent <code>focusin</code>:</p>\n<pre><code>$('.submenu').on({\n  focusout: function (e) {\n    $(this).data('submenuTimer', setTimeout(function () {\n      $(this).removeClass('submenu--active');\n    }.bind(this), 0));\n  },\n  focusin: function (e) {\n    clearTimeout($(this).data('submenuTimer'));\n  }\n});\n</code></pre>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>$('a').on('click', function () {\n  $(this.hash).toggleClass('active').focus();\n});\n\n$('div').on({\n  focusout: function () {\n    $(this).data('timer', setTimeout(function () {\n      $(this).removeClass('active');\n    }.bind(this), 0));\n  },\n  focusin: function () {\n    clearTimeout($(this).data('timer'));\n  }\n});</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>div {\n  display: none;\n}\n.active {\n  display: block;\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;\n&lt;a href=\"#example\"&gt;Example&lt;/a&gt;\n&lt;div id=\"example\" tabindex=\"-1\"&gt;\n  Lorem ipsum &lt;a href=\"http://example.com\"&gt;dolor&lt;/a&gt; sit amet.\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>The second issue is that the dialog won't close when the link is pressed again. This is because the dialog loses focus, triggering the close behavior, after which the link click triggers the dialog to reopen.</p>\n<p>Similar to the previous issue, the focus state needs to be managed. Given that the state change has already been queued, it's just a matter of handling focus events on the dialog triggers:</p>\n<sub>This should look familiar</sub>\n<pre><code>$('a').on({\n  focusout: function () {\n    $(this.hash).data('timer', setTimeout(function () {\n      $(this.hash).removeClass('active');\n    }.bind(this), 0));\n  },\n  focusin: function () {\n    clearTimeout($(this.hash).data('timer'));  \n  }\n});\n</code></pre>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>$('a').on('click', function () {\n  $(this.hash).toggleClass('active').focus();\n});\n\n$('div').on({\n  focusout: function () {\n    $(this).data('timer', setTimeout(function () {\n      $(this).removeClass('active');\n    }.bind(this), 0));\n  },\n  focusin: function () {\n    clearTimeout($(this).data('timer'));\n  }\n});\n\n$('a').on({\n  focusout: function () {\n    $(this.hash).data('timer', setTimeout(function () {\n      $(this.hash).removeClass('active');\n    }.bind(this), 0));\n  },\n  focusin: function () {\n    clearTimeout($(this.hash).data('timer'));  \n  }\n});</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>div {\n  display: none;\n}\n.active {\n  display: block;\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;\n&lt;a href=\"#example\"&gt;Example&lt;/a&gt;\n&lt;div id=\"example\" tabindex=\"-1\"&gt;\n  Lorem ipsum &lt;a href=\"http://example.com\"&gt;dolor&lt;/a&gt; sit amet.\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<hr />\n<h2><kbd>Esc</kbd> key</h2>\n<p>If you thought you were done by handling the focus states, there's more you can do to simplify the user experience.</p>\n<p>This is often a &quot;nice to have&quot; feature, but it's common that when you have a modal or popup of any sort that the <kbd>Esc</kbd> key will close it out.</p>\n<pre><code>keydown: function (e) {\n  if (e.which === 27) {\n    $(this).removeClass('active');\n    e.preventDefault();\n  }\n}\n</code></pre>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>$('a').on('click', function () {\n  $(this.hash).toggleClass('active').focus();\n});\n\n$('div').on({\n  focusout: function () {\n    $(this).data('timer', setTimeout(function () {\n      $(this).removeClass('active');\n    }.bind(this), 0));\n  },\n  focusin: function () {\n    clearTimeout($(this).data('timer'));\n  },\n  keydown: function (e) {\n    if (e.which === 27) {\n      $(this).removeClass('active');\n      e.preventDefault();\n    }\n  }\n});\n\n$('a').on({\n  focusout: function () {\n    $(this.hash).data('timer', setTimeout(function () {\n      $(this.hash).removeClass('active');\n    }.bind(this), 0));\n  },\n  focusin: function () {\n    clearTimeout($(this.hash).data('timer'));  \n  }\n});</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>div {\n  display: none;\n}\n.active {\n  display: block;\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;\n&lt;a href=\"#example\"&gt;Example&lt;/a&gt;\n&lt;div id=\"example\" tabindex=\"-1\"&gt;\n  Lorem ipsum &lt;a href=\"http://example.com\"&gt;dolor&lt;/a&gt; sit amet.\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<hr />\n<p>If you know you have focusable elements within the dialog, you won't need to focus the dialog directly. If you're building a menu, you could focus the first menu item instead.</p>\n<pre><code>click: function (e) {\n  $(this.hash)\n    .toggleClass('submenu--active')\n    .find('a:first')\n    .focus();\n  e.preventDefault();\n}\n</code></pre>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>$('.menu__link').on({\n  click: function (e) {\n    $(this.hash)\n      .toggleClass('submenu--active')\n      .find('a:first')\n      .focus();\n    e.preventDefault();\n  },\n  focusout: function () {\n    $(this.hash).data('submenuTimer', setTimeout(function () {\n      $(this.hash).removeClass('submenu--active');\n    }.bind(this), 0));\n  },\n  focusin: function () {\n    clearTimeout($(this.hash).data('submenuTimer'));  \n  }\n});\n\n$('.submenu').on({\n  focusout: function () {\n    $(this).data('submenuTimer', setTimeout(function () {\n      $(this).removeClass('submenu--active');\n    }.bind(this), 0));\n  },\n  focusin: function () {\n    clearTimeout($(this).data('submenuTimer'));\n  },\n  keydown: function (e) {\n    if (e.which === 27) {\n      $(this).removeClass('submenu--active');\n      e.preventDefault();\n    }\n  }\n});</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>.menu {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.menu:after {\n  clear: both;\n  content: '';\n  display: table;\n}\n.menu__item {\n  float: left;\n  position: relative;\n}\n\n.menu__link {\n  background-color: lightblue;\n  color: black;\n  display: block;\n  padding: 0.5em 1em;\n  text-decoration: none;\n}\n.menu__link:hover,\n.menu__link:focus {\n  background-color: black;\n  color: lightblue;\n}\n\n.submenu {\n  border: 1px solid black;\n  display: none;\n  left: 0;\n  list-style: none;\n  margin: 0;\n  padding: 0;\n  position: absolute;\n  top: 100%;\n}\n.submenu--active {\n  display: block;\n}\n\n.submenu__item {\n  width: 150px;\n}\n\n.submenu__link {\n  background-color: lightblue;\n  color: black;\n  display: block;\n  padding: 0.5em 1em;\n  text-decoration: none;\n}\n\n.submenu__link:hover,\n.submenu__link:focus {\n  background-color: black;\n  color: lightblue;\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;\n&lt;ul class=\"menu\"&gt;\n  &lt;li class=\"menu__item\"&gt;\n    &lt;a class=\"menu__link\" href=\"#menu-1\"&gt;Menu 1&lt;/a&gt;\n    &lt;ul class=\"submenu\" id=\"menu-1\" tabindex=\"-1\"&gt;\n      &lt;li class=\"submenu__item\"&gt;&lt;a class=\"submenu__link\" href=\"http://example.com/#1\"&gt;Example 1&lt;/a&gt;&lt;/li&gt;\n      &lt;li class=\"submenu__item\"&gt;&lt;a class=\"submenu__link\" href=\"http://example.com/#2\"&gt;Example 2&lt;/a&gt;&lt;/li&gt;\n      &lt;li class=\"submenu__item\"&gt;&lt;a class=\"submenu__link\" href=\"http://example.com/#3\"&gt;Example 3&lt;/a&gt;&lt;/li&gt;\n      &lt;li class=\"submenu__item\"&gt;&lt;a class=\"submenu__link\" href=\"http://example.com/#4\"&gt;Example 4&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/li&gt;\n  &lt;li class=\"menu__item\"&gt;\n    &lt;a  class=\"menu__link\" href=\"#menu-2\"&gt;Menu 2&lt;/a&gt;\n    &lt;ul class=\"submenu\" id=\"menu-2\" tabindex=\"-1\"&gt;\n      &lt;li class=\"submenu__item\"&gt;&lt;a class=\"submenu__link\" href=\"http://example.com/#1\"&gt;Example 1&lt;/a&gt;&lt;/li&gt;\n      &lt;li class=\"submenu__item\"&gt;&lt;a class=\"submenu__link\" href=\"http://example.com/#2\"&gt;Example 2&lt;/a&gt;&lt;/li&gt;\n      &lt;li class=\"submenu__item\"&gt;&lt;a class=\"submenu__link\" href=\"http://example.com/#3\"&gt;Example 3&lt;/a&gt;&lt;/li&gt;\n      &lt;li class=\"submenu__item\"&gt;&lt;a class=\"submenu__link\" href=\"http://example.com/#4\"&gt;Example 4&lt;/a&gt;&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\nlorem ipsum &lt;a href=\"http://example.com/\"&gt;dolor&lt;/a&gt; sit amet.</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<hr />\n<h1>WAI-ARIA Roles and Other Accessibility Support</h1>\n<p>This answer hopefully covers the basics of accessible keyboard and mouse support for this feature, but as it's already quite sizable I'm going to avoid any discussion of <a href=\"https://www.w3.org/TR/wai-aria/\" rel=\"noreferrer\">WAI-ARIA roles and attributes</a>, however I <em>highly</em> recommend that implementers refer to the spec for details on what roles they should use and any other appropriate attributes.</p>\n"},{"score":1,"body":"<p>To hide <code>fileTreeClass</code> if clicked outside of it   </p>\n\n<pre><code> jQuery(document).mouseup(function (e) {\n            var container = $(\".fileTreeClass\");\n            if (!container.is(e.target) // if the target of the click isn't the container...\n                &amp;&amp; container.has(e.target).length === 0) // ... nor a descendant of the container\n            {\n                container.hide();\n            }\n        });\n</code></pre>\n"},{"score":1,"body":"<p>Simple plugin:</p>\n\n<pre><code>$.fn.clickOff = function(callback, selfDestroy) {\n    var clicked = false;\n    var parent = this;\n    var destroy = selfDestroy || true;\n\n    parent.click(function() {\n        clicked = true;\n    });\n\n    $(document).click(function(event) {\n        if (!clicked &amp;&amp; parent.is(':visible')) {\n            if(callback) callback.call(parent, event)\n        }\n        if (destroy) {\n            //parent.clickOff = function() {};\n            //parent.off(\"click\");\n            //$(document).off(\"click\");\n            parent.off(\"clickOff\");\n        }\n        clicked = false;\n    });\n};\n</code></pre>\n\n<p>Use:</p>\n\n<pre><code>$(\"#myDiv\").clickOff(function() {\n   alert('clickOff');\n});\n</code></pre>\n"},{"score":2,"body":"<p>This might be a better fix for some people. </p>\n\n<pre><code>$(\".menu_link\").click(function(){\n    // show menu code\n});\n\n$(\".menu_link\").mouseleave(function(){\n    //hide menu code, you may add a timer for 3 seconds before code to be run\n});\n</code></pre>\n\n<p>I know mouseleave does not only mean a click outside, it also means leaving that element's area.</p>\n\n<p>Once the menu itself is inside the <code>menu_link</code> element then the menu itself should not be a problem to click on or move on.</p>\n"},{"score":2,"body":"<p>I believe the best way of doing it is something like this. </p>\n\n<pre><code>$(document).on(\"click\", function(event) {\n  clickedtarget = $(event.target).closest('#menuscontainer');\n  $(\"#menuscontainer\").not(clickedtarget).hide();\n});\n</code></pre>\n\n<p>This type of solution could easily be made to work for multiple menus and also menus that are dynamically added through javascript. Basically it just allows you to click anywhere in your document, and checks which element you clicked in, and selects it's closest \"#menuscontainer\". Then it hides all menuscontainers but excludes the one you clicked in. </p>\n\n<p>Not sure about exactly how your menus are built, but feel free to copy my code in the JSFiddle. It's a very simple but thoroughly functional menu/modal system. All you need to do is build the html-menus and the code will do the work for you.</p>\n\n<p><a href=\"https://jsfiddle.net/zs6anrn7/\" rel=\"nofollow noreferrer\">https://jsfiddle.net/zs6anrn7/</a></p>\n"},{"score":3,"body":"<p>I know there are a million answers to this question, but I've always been a fan of using HTML and CSS to do most of the work. In this case, z-index and positioning. The simplest way that I have found to do this is as follows:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>$(\"#show-trigger\").click(function(){\r\n  $(\"#element\").animate({width: 'toggle'});\r\n  $(\"#outside-element\").show();\r\n});\r\n$(\"#outside-element\").click(function(){\r\n  $(\"#element\").hide();\r\n  $(\"#outside-element\").hide();\r\n});</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>#outside-element {\r\n  position:fixed;\r\n  width:100%;\r\n  height:100%;\r\n  z-index:1;\r\n  display:none;\r\n}\r\n#element {\r\n  display:none;\r\n  padding:20px;\r\n  background-color:#ccc;\r\n  width:300px;\r\n  z-index:2;\r\n  position:relative;\r\n}\r\n#show-trigger {\r\n  padding:20px;\r\n  background-color:#ccc;\r\n  margin:20px auto;\r\n  z-index:2;\r\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;\r\n&lt;div id=\"outside-element\"&gt;&lt;/div&gt;\r\n&lt;div id=\"element\"&gt;\r\n  &lt;div class=\"menu-item\"&gt;&lt;a href=\"#1\"&gt;Menu Item 1&lt;/a&gt;&lt;/div&gt;\r\n  &lt;div class=\"menu-item\"&gt;&lt;a href=\"#2\"&gt;Menu Item 1&lt;/a&gt;&lt;/div&gt;\r\n  &lt;div class=\"menu-item\"&gt;&lt;a href=\"#3\"&gt;Menu Item 1&lt;/a&gt;&lt;/div&gt;\r\n  &lt;div class=\"menu-item\"&gt;&lt;a href=\"#4\"&gt;Menu Item 1&lt;/a&gt;&lt;/div&gt;\r\n&lt;/div&gt;\r\n&lt;div id=\"show-trigger\"&gt;Show Menu&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>This creates a safe environment, since nothing is going to get triggered unless the menu is actually open and the z-index protects any of the content within the element from creating any misfires upon being clicked.</p>\n\n<p>Additionally, you're not requiring jQuery to cover all of your bases with propagation calls and having to purge all of the inner elements from misfires.</p>\n"},{"score":3,"body":"<pre><code>$(document).on(\"click\",function (event)   \n {   \n     console.log(event);\n   if ($(event.target).closest('.element').length == 0)\n     {\n    //your code here\n      if ($(\".element\").hasClass(\"active\"))\n      {\n        $(\".element\").removeClass(\"active\");\n      }\n     }\n });\n</code></pre>\n\n<p>Try this coding for getting the solution.</p>\n"},{"score":17,"body":"<p>The event has a property called event.path of the element which is a <em>\"static ordered list of all its ancestors in tree order\"</em>. To check if an event originated from a specific DOM element or one of its children, just check the path for that specific DOM element. It can also be used to check multiple elements by logically <code>OR</code>ing the element check in the <code>some</code> function.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>$(\"body\").click(function() {\r\n  target = document.getElementById(\"main\");\r\n  flag = event.path.some(function(el, i, arr) {\r\n    return (el == target)\r\n  })\r\n  if (flag) {\r\n    console.log(\"Inside\")\r\n  } else {\r\n    console.log(\"Outside\")\r\n  }\r\n});</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>#main {\r\n  display: inline-block;\r\n  background:yellow;\r\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;\r\n&lt;div id=\"main\"&gt;\r\n  &lt;ul&gt;\r\n    &lt;li&gt;Test-Main&lt;/li&gt;\r\n    &lt;li&gt;Test-Main&lt;/li&gt;\r\n    &lt;li&gt;Test-Main&lt;/li&gt;\r\n    &lt;li&gt;Test-Main&lt;/li&gt;\r\n    &lt;li&gt;Test-Main&lt;/li&gt;\r\n  &lt;/ul&gt;\r\n&lt;/div&gt;\r\n&lt;div id=\"main2\"&gt;\r\n  Outside Main\r\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>So for your case It should be </p>\n\n<pre><code>$(\"body\").click(function() {\n  target = $(\"#menuscontainer\")[0];\n  flag = event.path.some(function(el, i, arr) {\n    return (el == target)\n  });\n  if (!flag) {\n    // Hide the menus\n  }\n});\n</code></pre>\n"},{"score":7,"body":"<p>If someone curious here is javascript solution(es6):</p>\n\n<pre><code>window.addEventListener('mouseup', e =&gt; {\n        if (e.target != yourDiv &amp;&amp; e.target.parentNode != yourDiv) {\n            yourDiv.classList.remove('show-menu');\n            //or yourDiv.style.display = 'none';\n        }\n    })\n</code></pre>\n\n<p>and es5, just in case:</p>\n\n<pre><code>window.addEventListener('mouseup', function (e) {\nif (e.target != yourDiv &amp;&amp; e.target.parentNode != yourDiv) {\n    yourDiv.classList.remove('show-menu'); \n    //or yourDiv.style.display = 'none';\n}\n</code></pre>\n\n<p>});</p>\n"},{"score":4,"body":"<p>Here is what I do to solve to problem.</p>\n\n<pre><code>$(window).click(function (event) {\n    //To improve performance add a checklike \n    //if(myElement.isClosed) return;\n    var isClickedElementChildOfMyBox = isChildOfElement(event,'#id-of-my-element');\n\n    if (isClickedElementChildOfMyBox)\n        return;\n\n    //your code to hide the element \n});\n\nvar isChildOfElement = function (event, selector) {\n    if (event.originalEvent.path) {\n        return event.originalEvent.path[0].closest(selector) !== null;\n    }\n\n    return event.originalEvent.originalTarget.closest(selector) !== null;\n}\n</code></pre>\n"},{"score":3,"body":"<p>This works for me</p>\n\n<pre><code>$(\"body\").mouseup(function(e) {\n    var subject = $(\".main-menu\");\n    if(e.target.id != subject.attr('id') &amp;&amp; !subject.has(e.target).length) {\n        $('.sub-menu').hide();\n    }\n});\n</code></pre>\n"},{"score":7,"body":"<p>Here is a simple solution by pure javascript. It is <strong>up-to-date with ES6</strong>:</p>\n\n<pre><code>var isMenuClick = false;\nvar menu = document.getElementById('menuscontainer');\ndocument.addEventListener('click',()=&gt;{\n    if(!isMenuClick){\n       //Hide the menu here\n    }\n    //Reset isMenuClick \n    isMenuClick = false;\n})\nmenu.addEventListener('click',()=&gt;{\n    isMenuClick = true;\n})\n</code></pre>\n"},{"score":0,"body":"<p>if you just want to display a window when you click on a button and undisp this window when you click outside.( or on the button again ) this bellow work good</p>\n\n<pre><code>document.body.onclick = function() { undisp_menu(); };\nvar menu_on = 0;\n\nfunction menu_trigger(event){\n\n    if (menu_on == 0)\n    {\n        // otherwise u will call the undisp on body when \n        // click on the button\n        event.stopPropagation(); \n\n        disp_menu();\n    }\n\n    else{\n        undisp_menu();\n    }\n\n}\n\n\nfunction disp_menu(){\n\n    menu_on = 1;\n    var e = document.getElementsByClassName(\"menu\")[0];\n    e.className = \"menu on\";\n\n}\n\nfunction undisp_menu(){\n\n    menu_on = 0;\n    var e = document.getElementsByClassName(\"menu\")[0];\n    e.className = \"menu\";\n\n}\n</code></pre>\n\n<p>don't forget this for the button</p>\n\n<pre><code>&lt;div class=\"button\" onclick=\"menu_trigger(event)\"&gt;\n\n&lt;div class=\"menu\"&gt;\n</code></pre>\n\n<p>and the css:</p>\n\n<pre><code>.menu{\n    display: none;\n}\n\n.on {\n    display: inline-block;\n}\n</code></pre>\n"},{"score":3,"body":"<p>If you are using tools like \"Pop-up\", you can use the \"onFocusOut\" event.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>window.onload=function(){\r\ndocument.getElementById(\"inside-div\").focus();\r\n}\r\nfunction loseFocus(){\r\nalert(\"Clicked outside\");\r\n}</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>#container{\r\nbackground-color:lightblue;\r\nwidth:200px;\r\nheight:200px;\r\n}\r\n\r\n#inside-div{\r\nbackground-color:lightgray;\r\nwidth:100px;\r\nheight:100px;\r\n\r\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;div id=\"container\"&gt;\r\n&lt;input type=\"text\" id=\"inside-div\" onfocusout=\"loseFocus()\"&gt;\r\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":2,"body":"<pre><code>$('#propertyType').on(\"click\",function(e){\n          self.propertyTypeDialog = !self.propertyTypeDialog;\n          b = true;\n          e.stopPropagation();\n          console.log(\"input clicked\");\n      });\n\n      $(document).on('click','body:not(#propertyType)',function (e) {\n          e.stopPropagation();\n          if(b == true)  {\n              if ($(e.target).closest(\"#configuration\").length == 0) {\n                  b = false;\n                  self.propertyTypeDialog = false;\n                  console.log(\"outside clicked\");\n              }\n          }\n        // console.log($(e.target).closest(\"#configuration\").length);\n      });\n</code></pre>\n"},{"score":7,"body":"<p>I have used below script and done with jQuery.</p>\n\n<pre><code>jQuery(document).click(function(e) {\n    var target = e.target; //target div recorded\n    if (!jQuery(target).is('#tobehide') ) {\n        jQuery(this).fadeOut(); //if the click element is not the above id will hide\n    }\n})\n</code></pre>\n\n<p>Below find the HTML code</p>\n\n<pre><code>&lt;div class=\"main-container\"&gt;\n&lt;div&gt; Hello I am the title&lt;/div&gt;\n&lt;div class=\"tobehide\"&gt;I will hide when you click outside of me&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>You can read the tutorial <a href=\"http://tutsplanet.com/trigger-function-clicks-outside-element-jquery-492/\" rel=\"noreferrer\">here</a> </p>\n"},{"score":18,"body":"<p>I am surprised nobody actually acknowledged <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/focusout_event\" rel=\"noreferrer\"><code>focusout</code></a> event:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var button = document.getElementById('button');\nbutton.addEventListener('click', function(e){\n  e.target.style.backgroundColor = 'green';\n});\nbutton.addEventListener('focusout', function(e){\n  e.target.style.backgroundColor = '';\n});</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;button id=\"button\"&gt;Click&lt;/button&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":4,"body":"<p>I just want to make @Pistos answer more apparent since it's hidden in the comments.</p>\n\n<p>This solution worked perfectly for me. Plain JS:</p>\n\n<pre><code>var elementToToggle = $('.some-element');\n$(document).click( function(event) {\n  if( $(event.target).closest(elementToToggle).length === 0 ) {\n    elementToToggle.hide();\n  }\n});\n</code></pre>\n\n<p>in CoffeeScript:</p>\n\n<pre><code>elementToToggle = $('.some-element')\n$(document).click (event) -&gt;\n  if $(event.target).closest(elementToToggle).length == 0\n    elementToToggle.hide()\n</code></pre>\n"},{"score":4,"body":"<p>Let's say the div you want to detect if the user clicked outside or inside has an id, for example: \"my-special-widget\".</p>\n\n<p>Listen to body click events:</p>\n\n<pre><code>document.body.addEventListener('click', (e) =&gt; {\n    if (isInsideMySpecialWidget(e.target, \"my-special-widget\")) {\n        console.log(\"user clicked INSIDE the widget\");\n    }\n    console.log(\"user clicked OUTSIDE the widget\");\n});\n\nfunction isInsideMySpecialWidget(elem, mySpecialWidgetId){\n    while (elem.parentElement) {\n        if (elem.id === mySpecialWidgetId) {\n            return true;\n        }\n        elem = elem.parentElement;\n    }\n    return false;\n}\n</code></pre>\n\n<p>In this case, you won't break the normal flow of click on some element in your page, since you are not using the \"stopPropagation\" method.</p>\n"},{"score":-1,"body":"<p>First you have to track wether the mouse is inside or outside your element1, using the mouseenter and mouseleave events.\nThen you can create an element2 which covers the whole screen to detect any clicks, and react accordingly depending on wether you are inside or outside element1.</p>\n\n<p>I strongly recommend to handle both initialization and cleanup, and that the element2 is made as temporary as possible, for obvious reasons.</p>\n\n<p>In the example below, the overlay is an element positionned somewhere, which can be selected by clicking inside, and unselected by clicking outside.\nThe _init and _release methods are called as part of an automatic initialisation/cleanup process.\nThe class inherits from a ClickOverlay which has an inner and outerElement, don't worry about it. I used outerElement.parentNode.appendChild to avoid conflicts.</p>\n\n<pre><code>import ClickOverlay from './ClickOverlay.js'\n\n/* CSS */\n// .unselect-helper {\n//  position: fixed; left: -100vw; top: -100vh;\n//  width: 200vw; height: 200vh;\n// }\n// .selected {outline: 1px solid black}\n\nexport default class ResizeOverlay extends ClickOverlay {\n    _init(_opts) {\n        this.enterListener = () =&gt; this.onEnter()\n        this.innerElement.addEventListener('mouseenter', this.enterListener)\n        this.leaveListener = () =&gt; this.onLeave()\n        this.innerElement.addEventListener('mouseleave', this.leaveListener)\n        this.selectListener = () =&gt; {\n            if (this.unselectHelper)\n                return\n            this.unselectHelper = document.createElement('div')\n            this.unselectHelper.classList.add('unselect-helper')\n            this.unselectListener = () =&gt; {\n                if (this.mouseInside)\n                    return\n                this.clearUnselectHelper()\n                this.onUnselect()\n            }\n            this.unselectHelper.addEventListener('pointerdown'\n                , this.unselectListener)\n            this.outerElement.parentNode.appendChild(this.unselectHelper)\n            this.onSelect()\n        }\n        this.innerElement.addEventListener('pointerup', this.selectListener)\n    }\n\n    _release() {\n        this.innerElement.removeEventListener('mouseenter', this.enterListener)\n        this.innerElement.removeEventListener('mouseleave', this.leaveListener)\n        this.innerElement.removeEventListener('pointerup', this.selectListener)\n        this.clearUnselectHelper()\n    }\n\n    clearUnselectHelper() {\n        if (!this.unselectHelper)\n            return\n        this.unselectHelper.removeEventListener('pointerdown'\n            , this.unselectListener)\n        this.unselectHelper.remove()\n        delete this.unselectListener\n        delete this.unselectHelper\n    }\n\n    onEnter() {\n        this.mouseInside = true\n    }\n\n    onLeave() {\n        delete this.mouseInside\n    }\n\n    onSelect() {\n        this.innerElement.classList.add('selected')\n    }\n\n    onUnselect() {\n        this.innerElement.classList.remove('selected')\n    }\n}\n</code></pre>\n"},{"score":2,"body":"<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"true\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const button = document.querySelector('button')\r\nconst box = document.querySelector('.box');\r\n\r\nconst toggle = event =&gt; {\r\n  event.stopPropagation();\r\n  \r\n  if (!event.target.closest('.box')) {\r\n    console.log('Click outside');\r\n\r\n    box.classList.toggle('active');\r\n\r\n    box.classList.contains('active')\r\n      ? document.addEventListener('click', toggle)\r\n      : document.removeEventListener('click', toggle);\r\n  } else {\r\n    console.log('Click inside');\r\n  }\r\n}\r\n\r\nbutton.addEventListener('click', toggle);</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>.box {\r\n  position: absolute;\r\n  display: none;\r\n  margin-top: 8px;\r\n  padding: 20px;\r\n  background: lightgray;\r\n}\r\n\r\n.box.active {\r\n  display: block;\r\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;button&gt;Toggle box&lt;/button&gt;\r\n\r\n&lt;div class=\"box\"&gt;\r\n  &lt;form action=\"\"&gt;\r\n    &lt;input type=\"text\"&gt;\r\n    &lt;button type=\"button\"&gt;Search&lt;/button&gt;\r\n  &lt;/form&gt;\r\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":0,"body":"<p>The easiest way: <code>mouseleave(function())</code></p>\n\n<p>More info: <a href=\"https://www.w3schools.com/jquery/jquery_events.asp\" rel=\"nofollow noreferrer\">https://www.w3schools.com/jquery/jquery_events.asp</a></p>\n"},{"score":3,"body":"<p>2020 solution using native JS API <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\" rel=\"nofollow noreferrer\">closest</a> method.</p>\n<pre class=\"lang-js prettyprint-override\"><code>document.addEventListener('click', ({ target }) =&gt; {\n  if (!target.closest('.el1, .el2, #el3')) {\n    alert('click outside')\n  }\n})\n\n</code></pre>\n"},{"score":1,"body":"<p>Still looking for that perfect solution for detecting clicking outside? Look no further! Introducing <a href=\"https://www.npmjs.com/package/clickout-event\" rel=\"nofollow noreferrer\">Clickout-Event</a>, a package that provides universal support for clickout and other similar events, and it works in <strong>all</strong> scenarios: plain HTML <code>onclickout</code> attributes, <code>.addEventListener('clickout')</code> of vanilla JavaScript, <code>.on('clickout')</code> of jQuery, <code>v-on:clickout</code> directives of Vue.js, you name it. As long as a front-end framework internally uses <code>addEventListener</code> to handle events, Clickout-Event works for it. Just add the script tag anywhere in your page, and it simply works like magic.</p>\n<p>HTML attribute</p>\n<pre class=\"lang-html prettyprint-override\"><code>&lt;div onclickout=&quot;console.log('clickout detected')&quot;&gt;...&lt;/div&gt;\n</code></pre>\n<p>Vanilla JavaScript</p>\n<pre class=\"lang-js prettyprint-override\"><code>document.getElementById('myId').addEventListener('clickout', myListener);\n</code></pre>\n<p>jQuery</p>\n<pre class=\"lang-js prettyprint-override\"><code>$('#myId').on('clickout', myListener);\n</code></pre>\n<p>Vue.js</p>\n<pre class=\"lang-html prettyprint-override\"><code>&lt;div v-on:clickout=&quot;open=false&quot;&gt;...&lt;/div&gt;\n</code></pre>\n<p>Angular</p>\n<pre class=\"lang-html prettyprint-override\"><code>&lt;div (clickout)=&quot;close()&quot;&gt;...&lt;/div&gt;\n</code></pre>\n"},{"score":1,"body":"<p>All of these answers solve the problem, but I would like to contribute with a moders es6 solution that does exactly what is needed. I just hope to make someone happy with this runnable demo.</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>window.clickOutSide = (element, clickOutside, clickInside) =&gt; {\n  document.addEventListener('click', (event) =&gt; {\n    if (!element.contains(event.target)) {\n      if (typeof clickInside === 'function') {\n        clickOutside();\n      }\n    } else {\n      if (typeof clickInside === 'function') {\n        clickInside();\n      }\n    }\n  });\n};\n\nwindow.clickOutSide(document.querySelector('.block'), () =&gt; alert('clicked outside'), () =&gt; alert('clicked inside'));</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>.block {\n  width: 400px;\n  height: 400px;\n  background-color: red;\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;div class=\"block\"&gt;&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":0,"body":"<p>this works fine for me. i am not an expert.</p>\n<pre><code>$(document).click(function(event) {\n  var $target = $(event.target);\n  if(!$target.closest('#hamburger, a').length &amp;&amp;\n  $('#hamburger, a').is(&quot;:visible&quot;)) {\n    $('nav').slideToggle();\n  }\n});\n</code></pre>\n"},{"score":9,"body":"<h2>It's 2020 and you can use <code>event.composedPath()</code></h2>\n<p>From: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath\" rel=\"noreferrer\">https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath</a></p>\n<blockquote>\n<p>The composedPath() method of the Event interface returns the event’s path, which is an array of the objects on which listeners will be invoked.</p>\n</blockquote>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const target = document.querySelector('#myTarget')\n\ndocument.addEventListener('click', (event) =&gt; {\n  const withinBoundaries = event.composedPath().includes(target)\n\n  if (withinBoundaries) {\n    target.innerText = 'Click happened inside element'\n  } else {\n    target.innerText = 'Click happened **OUTSIDE** element'\n  } \n})</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>/* just to make it good looking. you don't need this */\n#myTarget {\n  margin: 50px auto;\n  width: 500px;\n  height: 500px;\n  background: gray;\n  border: 10px solid black;\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;div id=\"myTarget\"&gt;\n  click me (or not!)\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"}],"score":2570}