{"body":"<p>What is the preferred syntax for defining enums in JavaScript? Something like:</p>\n\n<pre><code>my.namespace.ColorEnum = {\n    RED : 0,\n    GREEN : 1,\n    BLUE : 2\n}\n\n// later on\n\nif(currentColor == my.namespace.ColorEnum.RED) {\n   // whatever\n}\n</code></pre>\n\n<p>Or is there a more preferable idiom?</p>\n","title":"What is the preferred syntax for defining enums in JavaScript?","answers":[{"score":613,"body":"<p>This isn't much of an answer, but I'd say that works just fine, personally</p>\n\n<p>Having said that, since it doesn't matter what the values are (you've used 0, 1, 2), I'd use a meaningful string in case you ever wanted to output the current value.</p>\n"},{"score":85,"body":"<p>Bottom line: You can't. </p>\n\n<p>You can fake it, but you won't get type safety. Typically this is done by creating a simple dictionary of string values mapped to integer values. For example:</p>\n\n<pre><code>var DaysEnum = {\"monday\":1, \"tuesday\":2, \"wednesday\":3, ...}\n\nDocument.Write(\"Enumerant: \" + DaysEnum.tuesday);\n</code></pre>\n\n<p>The problem with this approach? You can accidentally redefine your enumerant, or accidentally have duplicate enumerant values. For example:</p>\n\n<pre><code>DaysEnum.monday = 4; // whoops, monday is now thursday, too\n</code></pre>\n\n<p><strong>Edit</strong>  </p>\n\n<blockquote>\n  <p>What about Artur Czajka's Object.freeze? Wouldn't that work to prevent you from setting monday to thursday? – Fry Quad </p>\n</blockquote>\n\n<p>Absolutely, <a href=\"http://msdn.microsoft.com/en-us/library/windows/apps/ff806186%28v=vs.94%29.aspx\" rel=\"noreferrer\"><code>Object.freeze</code></a> would totally fix the problem I complained about. I would like to remind everyone that when I wrote the above, <code>Object.freeze</code> didn't really exist. </p>\n\n<p>Now.... now it opens up some <em>very</em> interesting possibilities. </p>\n\n<p><strong>Edit 2</strong><br>\nHere's a very good library for creating enums. </p>\n\n<p><a href=\"http://www.2ality.com/2011/10/enums.html\" rel=\"noreferrer\">http://www.2ality.com/2011/10/enums.html</a></p>\n\n<p>While it probably doesn't fit every valid use of enums, it goes a very long way. </p>\n"},{"score":510,"body":"<h2>UPDATE</h2>\n\n<p>Thanks for all the upvotes everyone, but I don't think my answer below is the best way to write enums in JavaScript anymore. See my blog post for more details: <a href=\"https://stijndewitt.com/2014/01/26/enums-in-javascript/\" rel=\"noreferrer\">Enums in JavaScript</a>.</p>\n\n<hr>\n\n<p>Alerting the name is already possible:</p>\n\n<pre><code>if (currentColor == my.namespace.ColorEnum.RED) {\n   // alert name of currentColor (RED: 0)\n   var col = my.namespace.ColorEnum;\n   for (var name in col) {\n     if (col[name] == col.RED)\n       alert(name);\n   }\n}\n</code></pre>\n\n<p>Alternatively, you could make the values objects, so you can have the cake and eat it too:</p>\n\n<pre><code>var SIZE = {\n  SMALL : {value: 0, name: \"Small\", code: \"S\"}, \n  MEDIUM: {value: 1, name: \"Medium\", code: \"M\"}, \n  LARGE : {value: 2, name: \"Large\", code: \"L\"}\n};\n\nvar currentSize = SIZE.MEDIUM;\nif (currentSize == SIZE.MEDIUM) {\n  // this alerts: \"1: Medium\"\n  alert(currentSize.value + \": \" + currentSize.name);\n}\n</code></pre>\n\n<p>In JavaScript, as it is a dynamic language, it is even possible to add enum values to the set later:</p>\n\n<pre><code>// Add EXTRALARGE size\nSIZE.EXTRALARGE = {value: 3, name: \"Extra Large\", code: \"XL\"};\n</code></pre>\n\n<p>Remember, the fields of the enum (value, name and code in this example) are not needed for the identity check and are only there for convenience. Also the name of the size property itself does not need to be hard coded, but can also be set dynamically. So supposing you only know the name for your new enum value, you can still add it without problems:</p>\n\n<pre><code>// Add 'Extra Large' size, only knowing it's name\nvar name = \"Extra Large\";\nSIZE[name] = {value: -1, name: name, code: \"?\"};\n</code></pre>\n\n<p>Of course this means that some assumptions can no longer be made (that value represents the correct order for the size for example). </p>\n\n<p>Remember, in JavaScript an object is just like a <em>map</em> or <em>hash table</em>. A set of name-value pairs. You can loop through them or otherwise manipulate them without knowing much about them in advance.</p>\n\n<h2>Example</h2>\n\n<pre><code>for (var sz in SIZE) {\n  // sz will be the names of the objects in SIZE, so\n  // 'SMALL', 'MEDIUM', 'LARGE', 'EXTRALARGE'\n  var size = SIZE[sz]; // Get the object mapped to the name in sz\n  for (var prop in size) {\n    // Get all the properties of the size object, iterates over\n    // 'value', 'name' and 'code'. You can inspect everything this way.        \n  }\n} \n</code></pre>\n\n<p>And by the way, if you are interested in namespaces, you may want to have a look at my solution for simple but powerful namespace and dependency management for JavaScript: <a href=\"http://packagesinjavascript.wordpress.com/\" rel=\"noreferrer\">Packages JS</a></p>\n"},{"score":985,"body":"<p>Since 1.8.5 it's possible to <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/freeze\" rel=\"noreferrer\">seal and freeze the object</a>, so define the above as:</p>\n<pre><code>const DaysEnum = Object.freeze({&quot;monday&quot;:1, &quot;tuesday&quot;:2, &quot;wednesday&quot;:3, ...})\n</code></pre>\n<p>or</p>\n<pre><code>const DaysEnum = {&quot;monday&quot;:1, &quot;tuesday&quot;:2, &quot;wednesday&quot;:3, ...}\nObject.freeze(DaysEnum)\n</code></pre>\n<p>and voila! JS enums.</p>\n<p>However, this doesn't prevent you from assigning an undesired value to a variable, which is often the main goal of enums:</p>\n<pre><code>let day = DaysEnum.tuesday\nday = 298832342 // goes through without any errors\n</code></pre>\n<p>One way to ensure a stronger degree of type safety (with enums or otherwise) is to use a tool like <a href=\"https://www.typescriptlang.org/\" rel=\"noreferrer\">TypeScript</a> or <a href=\"https://flow.org/\" rel=\"noreferrer\">Flow</a>.</p>\n<p>Quotes aren't needed but I kept them for consistency.</p>\n"},{"score":58,"body":"<p>Here's what we all want:</p>\n\n<pre><code>function Enum(constantsList) {\n    for (var i in constantsList) {\n        this[constantsList[i]] = i;\n    }\n}\n</code></pre>\n\n<p>Now you can create your enums:</p>\n\n<pre><code>var YesNo = new Enum(['NO', 'YES']);\nvar Color = new Enum(['RED', 'GREEN', 'BLUE']);\n</code></pre>\n\n<p>By doing this, constants can be acessed in the usual way (YesNo.YES, Color.GREEN) and they get a sequential int value (NO = 0, YES = 1; RED = 0, GREEN = 1, BLUE = 2).</p>\n\n<p>You can also add methods, by using Enum.prototype:</p>\n\n<pre><code>Enum.prototype.values = function() {\n    return this.allValues;\n    /* for the above to work, you'd need to do\n            this.allValues = constantsList at the constructor */\n};\n</code></pre>\n\n<p><br>\nEdit - small improvement - now with varargs: (unfortunately it doesn't work properly on IE :S... should stick with previous version then)</p>\n\n<pre><code>function Enum() {\n    for (var i in arguments) {\n        this[arguments[i]] = i;\n    }\n}\n\nvar YesNo = new Enum('NO', 'YES');\nvar Color = new Enum('RED', 'GREEN', 'BLUE');\n</code></pre>\n"},{"score":11,"body":"<p>If you're using <a href=\"http://documentcloud.github.com/backbone/\">Backbone</a>, you can get full-blown enum functionality (find by id, name, custom members) for free using <a href=\"http://documentcloud.github.com/backbone/#Collection\">Backbone.Collection</a>.</p>\n\n<pre><code>// enum instance members, optional\nvar Color = Backbone.Model.extend({\n    print : function() {\n        console.log(\"I am \" + this.get(\"name\"))\n    }\n});\n\n// enum creation\nvar Colors = new Backbone.Collection([\n    { id : 1, name : \"Red\", rgb : 0xFF0000},\n    { id : 2, name : \"Green\" , rgb : 0x00FF00},\n    { id : 3, name : \"Blue\" , rgb : 0x0000FF}\n], {\n    model : Color\n});\n\n// Expose members through public fields.\nColors.each(function(color) {\n    Colors[color.get(\"name\")] = color;\n});\n\n// using\nColors.Red.print()\n</code></pre>\n"},{"score":15,"body":"<p>This is the solution that I use.</p>\n\n<pre><code>function Enum() {\n    this._enums = [];\n    this._lookups = {};\n}\n\nEnum.prototype.getEnums = function() {\n    return _enums;\n}\n\nEnum.prototype.forEach = function(callback){\n    var length = this._enums.length;\n    for (var i = 0; i &lt; length; ++i){\n        callback(this._enums[i]);\n    }\n}\n\nEnum.prototype.addEnum = function(e) {\n    this._enums.push(e);\n}\n\nEnum.prototype.getByName = function(name) {\n    return this[name];\n}\n\nEnum.prototype.getByValue = function(field, value) {\n    var lookup = this._lookups[field];\n    if(lookup) {\n        return lookup[value];\n    } else {\n        this._lookups[field] = ( lookup = {});\n        var k = this._enums.length - 1;\n        for(; k &gt;= 0; --k) {\n            var m = this._enums[k];\n            var j = m[field];\n            lookup[j] = m;\n            if(j == value) {\n                return m;\n            }\n        }\n    }\n    return null;\n}\n\nfunction defineEnum(definition) {\n    var k;\n    var e = new Enum();\n    for(k in definition) {\n        var j = definition[k];\n        e[k] = j;\n        e.addEnum(j)\n    }\n    return e;\n}\n</code></pre>\n\n<p>And you define your enums like this:</p>\n\n<pre><code>var COLORS = defineEnum({\n    RED : {\n        value : 1,\n        string : 'red'\n    },\n    GREEN : {\n        value : 2,\n        string : 'green'\n    },\n    BLUE : {\n        value : 3,\n        string : 'blue'\n    }\n});\n</code></pre>\n\n<p>And this is how you access your enums:</p>\n\n<pre><code>COLORS.BLUE.string\nCOLORS.BLUE.value\nCOLORS.getByName('BLUE').string\nCOLORS.getByValue('value', 1).string\n\nCOLORS.forEach(function(e){\n    // do what you want with e\n});\n</code></pre>\n\n<p>I usually use the last 2 methods for mapping enums from message objects.</p>\n\n<p>Some advantages to this approach:</p>\n\n<ul>\n<li>Easy to declare enums</li>\n<li>Easy to access your enums</li>\n<li>Your enums can be complex types</li>\n<li>The Enum class has some associative caching if you are using getByValue a lot</li>\n</ul>\n\n<p>Some disadvantages:</p>\n\n<ul>\n<li>Some messy memory management going on in there, as I keep the references to the enums</li>\n<li>Still no type safety</li>\n</ul>\n"},{"score":7,"body":"<p>I've modified the solution of Andre 'Fi':</p>\n\n<pre><code>  function Enum() {\n    var that = this;\n    for (var i in arguments) {\n        that[arguments[i]] = i;\n    }\n    this.name = function(value) {\n        for (var key in that) {\n            if (that[key] == value) {\n                return key;\n            }\n        }\n    };\n    this.exist = function(value) {\n        return (typeof that.name(value) !== \"undefined\");\n    };\n    if (Object.freeze) {\n        Object.freeze(that);\n    }\n  }\n</code></pre>\n\n<p>Test:</p>\n\n<pre><code>var Color = new Enum('RED', 'GREEN', 'BLUE');\nundefined\nColor.name(Color.REDs)\nundefined\nColor.name(Color.RED)\n\"RED\"\nColor.exist(Color.REDs)\nfalse\nColor.exist(Color.RED)\ntrue\n</code></pre>\n"},{"score":17,"body":"<p>This is an old one I know, but the way it has since been implemented via the TypeScript interface is:</p>\n\n<pre><code>var MyEnum;\n(function (MyEnum) {\n    MyEnum[MyEnum[\"Foo\"] = 0] = \"Foo\";\n    MyEnum[MyEnum[\"FooBar\"] = 2] = \"FooBar\";\n    MyEnum[MyEnum[\"Bar\"] = 1] = \"Bar\";\n})(MyEnum|| (MyEnum= {}));\n</code></pre>\n\n<p>This enables you to look up on both <code>MyEnum.Bar</code> which returns 1, and <code>MyEnum[1]</code> which returns \"Bar\" regardless of the order of declaration.</p>\n"},{"score":23,"body":"<p>I've been playing around with this, as I love my enums. =)</p>\n\n<p>Using <code>Object.defineProperty</code> I think I came up with a somewhat viable solution.</p>\n\n<p>Here's a jsfiddle: <a href=\"http://jsfiddle.net/ZV4A6/\" rel=\"noreferrer\">http://jsfiddle.net/ZV4A6/</a></p>\n\n<p>Using this method.. you should (in theory) be able to call and define enum values for any object, without affecting other attributes of that object.</p>\n\n<pre><code>Object.defineProperty(Object.prototype,'Enum', {\n    value: function() {\n        for(i in arguments) {\n            Object.defineProperty(this,arguments[i], {\n                value:parseInt(i),\n                writable:false,\n                enumerable:true,\n                configurable:true\n            });\n        }\n        return this;\n    },\n    writable:false,\n    enumerable:false,\n    configurable:false\n}); \n</code></pre>\n\n<p>Because of the attribute <code>writable:false</code> this <i>should</i> make it type safe.</p>\n\n<p>So you should be able to create a custom object, then call <code>Enum()</code> on it. The values assigned start at 0 and increment per item.</p>\n\n<pre><code>var EnumColors={};\nEnumColors.Enum('RED','BLUE','GREEN','YELLOW');\nEnumColors.RED;    // == 0\nEnumColors.BLUE;   // == 1\nEnumColors.GREEN;  // == 2\nEnumColors.YELLOW; // == 3\n</code></pre>\n"},{"score":2,"body":"<p>I had done it a while ago using a mixture of <code>__defineGetter__</code> and <code>__defineSetter__</code> or <code>defineProperty</code> depending on the JS version.</p>\n\n<p>Here's the enum generating function I made: <a href=\"https://gist.github.com/gfarrell/6716853\" rel=\"nofollow\">https://gist.github.com/gfarrell/6716853</a></p>\n\n<p>You'd use it like this:</p>\n\n<pre><code>var Colours = Enum('RED', 'GREEN', 'BLUE');\n</code></pre>\n\n<p>And it would create an immutable string:int dictionary (an enum).</p>\n"},{"score":4,"body":"<p>A quick and simple way would be :</p>\n\n<pre><code>var Colors = function(){\nreturn {\n    'WHITE':0,\n    'BLACK':1,\n    'RED':2,\n    'GREEN':3\n    }\n}();\n\nconsole.log(Colors.WHITE)  //this prints out \"0\"\n</code></pre>\n"},{"score":-3,"body":"<p>You could also try to define a new function and therebefore a new namespace, and add variables to it, like this.</p>\n<pre><code>function Color () {};  \nColor.RED = 1;\nColor.YELLOW = 2;\n</code></pre>\n<p>As long anybody uses the namespace granted by the function Color, everything will go fine.\nIf you know Java, this is kind of old enums : where we use a class or interface only to hold static attributes. If a function, in javascript, is a kind of class, this is pretty much the same approach.</p>\n<p>I thing is a very simple way to define enums.</p>\n<p>Hope it helps!</p>\n<p>Greetings.</p>\n<p>Victor.</p>\n"},{"score":3,"body":"<p>As of writing, <strong>October 2014</strong> - so here is a contemporary solution. Am writing the solution as a Node Module, and have included a test using Mocha and Chai, as well as underscoreJS. You can easily ignore these, and just take the Enum code if preferred.</p>\n\n<p>Seen a lot of posts with overly convoluted libraries etc. The solution to getting enum support in Javascript is so simple it really isn't needed. Here is the code:</p>\n\n<p>File: enums.js</p>\n\n<pre><code>_ = require('underscore');\n\nvar _Enum = function () {\n\n   var keys = _.map(arguments, function (value) {\n      return value;\n   });\n   var self = {\n      keys: keys\n   };\n   for (var i = 0; i &lt; arguments.length; i++) {\n      self[keys[i]] = i;\n   }\n   return self;\n};\n\nvar fileFormatEnum = Object.freeze(_Enum('CSV', 'TSV'));\nvar encodingEnum = Object.freeze(_Enum('UTF8', 'SHIFT_JIS'));\n\nexports.fileFormatEnum = fileFormatEnum;\nexports.encodingEnum = encodingEnum;\n</code></pre>\n\n<p>And a test to illustrate what it gives you:</p>\n\n<p>file: enumsSpec.js</p>\n\n<pre><code>var chai = require(\"chai\"),\n    assert = chai.assert,\n    expect = chai.expect,\n    should = chai.should(),\n    enums = require('./enums'),\n    _ = require('underscore');\n\n\ndescribe('enums', function () {\n\n    describe('fileFormatEnum', function () {\n        it('should return expected fileFormat enum declarations', function () {\n            var fileFormatEnum = enums.fileFormatEnum;\n            should.exist(fileFormatEnum);\n            assert('{\"keys\":[\"CSV\",\"TSV\"],\"CSV\":0,\"TSV\":1}' === JSON.stringify(fileFormatEnum), 'Unexpected format');\n            assert('[\"CSV\",\"TSV\"]' === JSON.stringify(fileFormatEnum.keys), 'Unexpected keys format');\n        });\n    });\n\n    describe('encodingEnum', function () {\n        it('should return expected encoding enum declarations', function () {\n            var encodingEnum = enums.encodingEnum;\n            should.exist(encodingEnum);\n            assert('{\"keys\":[\"UTF8\",\"SHIFT_JIS\"],\"UTF8\":0,\"SHIFT_JIS\":1}' === JSON.stringify(encodingEnum), 'Unexpected format');\n            assert('[\"UTF8\",\"SHIFT_JIS\"]' === JSON.stringify(encodingEnum.keys), 'Unexpected keys format');\n        });\n    });\n\n});\n</code></pre>\n\n<p>As you can see, you get an Enum factory, you can get all the keys simply by calling enum.keys, and you can match the keys themselves to integer constants. And you can reuse the factory with different values, and export those generated Enums using Node's modular approach. </p>\n\n<p>Once again, if you are just a casual user, or in the browser etc, just take the factory part of the code, potentially removing underscore library too if you don't wish to use it in your code.</p>\n"},{"score":8,"body":"<p>your answers are far too complicated</p>\n\n<pre><code>var buildSet = function(array) {\n  var set = {};\n  for (var i in array) {\n    var item = array[i];\n    set[item] = item;\n  }\n  return set;\n}\n\nvar myEnum = buildSet(['RED','GREEN','BLUE']);\n// myEnum.RED == 'RED' ...etc\n</code></pre>\n"},{"score":1,"body":"<p>Really like what @Duncan did above, but I don't like mucking up global Object function space with Enum, so I wrote the following:</p>\n\n<pre><code>function mkenum_1()\n{\n  var o = new Object();\n  var c = -1;\n  var f = function(e, v) { Object.defineProperty(o, e, { value:v, writable:false, enumerable:true, configurable:true })};\n\n  for (i in arguments) {\n    var e = arguments[i];\n    if ((!!e) &amp; (e.constructor == Object))\n      for (j in e)\n        f(j, (c=e[j]));\n    else\n      f(e, ++c);\n    }\n\n  return Object.freeze ? Object.freeze(o) : o;\n}\n\nvar Sizes = mkenum_1('SMALL','MEDIUM',{LARGE: 100},'XLARGE');\n\nconsole.log(\"MED := \" + Sizes.MEDIUM);\nconsole.log(\"LRG := \" + Sizes.LARGE);\n\n// Output is:\n// MED := 1\n// LRG := 100\n</code></pre>\n\n<p>@Stijin also has a neat solution (referring to his blog) which includes properties on these objects. I wrote some code for that, too, which I'm including next.</p>\n\n<pre><code>function mkenum_2(seed)\n{\n    var p = {};\n\n    console.log(\"Seed := \" + seed);\n\n    for (k in seed) {\n        var v = seed[k];\n\n        if (v instanceof Array)\n            p[(seed[k]=v[0])] = { value: v[0], name: v[1], code: v[2] };\n        else\n            p[v] = { value: v, name: k.toLowerCase(), code: k.substring(0,1) };\n    }\n    seed.properties = p;\n\n    return Object.freeze ? Object.freeze(seed) : seed;\n}\n</code></pre>\n\n<p>This version produces an additional property list allowing friendly name conversion and short codes.  I like this version because one need not duplicate data entry in properties as the code does it for you.</p>\n\n<pre><code>var SizeEnum2 = mkenum_2({ SMALL: 1, MEDIUM: 2, LARGE: 3});\nvar SizeEnum3 = mkenum_2({ SMALL: [1, \"small\", \"S\"], MEDIUM: [2, \"medium\", \"M\"], LARGE: [3, \"large\", \"L\"] });\n</code></pre>\n\n<p>These two can be combined into a single processing unit, mkenum, (consume enums, assign values, create and add property list).  However, as I've spent far too much time on this today already, I will leave the combination as an exercise for the dear reader.</p>\n"},{"score":5,"body":"<pre><code>var ColorEnum = {\n    red: {},\n    green: {},\n    blue: {}\n}\n</code></pre>\n\n<p>You don't need to make sure you don't assign duplicate numbers to different enum values this way. A new object gets instantiated and assigned to all enum values.</p>\n"},{"score":1,"body":"<p>You can use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\" rel=\"nofollow\">Object.prototype.hasOwnProperty()</a> </p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var findInEnum,\r\n    colorEnum = {\r\n    red : 0,\r\n    green : 1,\r\n    blue : 2\r\n};\r\n\r\n// later on\r\n\r\nfindInEnum = function (enumKey) {\r\n  if (colorEnum.hasOwnProperty(enumKey)) {\r\n    return enumKey+' Value: ' + colorEnum[enumKey]\r\n  }\r\n}\r\n\r\nalert(findInEnum(\"blue\"))</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":4,"body":"<p>Here's a couple different ways to implement <a href=\"http://www.typescriptlang.org/Handbook#basic-types-enum\" rel=\"nofollow\">TypeScript enums</a>.</p>\n\n<p>The easiest way is to just iterate over an object, adding inverted key-value pairs to the object. The only drawback is that you must manually set the value for each member.</p>\n\n<pre><code>function _enum(list) {       \n  for (var key in list) {\n    list[list[key] = list[key]] = key;\n  }\n  return Object.freeze(list);\n}\n\nvar Color = _enum({\n  Red: 0,\n  Green: 5,\n  Blue: 2\n});\n\n// Color → {0: \"Red\", 2: \"Blue\", 5: \"Green\", \"Red\": 0, \"Green\": 5, \"Blue\": 2}\n// Color.Red → 0\n// Color.Green → 5\n// Color.Blue → 2\n// Color[5] → Green\n// Color.Blue &gt; Color.Green → false\n</code></pre>\n\n<p><br>\nAnd here's a <a href=\"https://lodash.com/docs#mixin\" rel=\"nofollow\">lodash mixin</a> to create an enum using a string. While this version is a little bit more involved, it does the numbering automatically for you. All the lodash methods used in this example have a regular JavaScript equivalent, so you can easily switch them out if you want.</p>\n\n<pre><code>function enum() {\n    var key, val = -1, list = {};\n    _.reduce(_.toArray(arguments), function(result, kvp) {    \n        kvp = kvp.split(\"=\");\n        key = _.trim(kvp[0]);\n        val = _.parseInt(kvp[1]) || ++val;            \n        result[result[val] = key] = val;\n        return result;\n    }, list);\n    return Object.freeze(list);\n}    \n\n// Add enum to lodash \n_.mixin({ \"enum\": enum });\n\nvar Color = _.enum(\n    \"Red\",\n    \"Green\",\n    \"Blue = 5\",\n    \"Yellow\",\n    \"Purple = 20\",\n    \"Gray\"\n);\n\n// Color.Red → 0\n// Color.Green → 1\n// Color.Blue → 5\n// Color.Yellow → 6\n// Color.Purple → 20\n// Color.Gray → 21\n// Color[5] → Blue\n</code></pre>\n"},{"score":1,"body":"<p>What is an enum in <strong>my</strong> opinion: It's an immutable object that is always accessible and you can compare items with eachother, but the items have common properties/methods, but the objects themselves or the values cannot be changed and they are instantiated only once.</p>\n\n<p>Enums are imho used for comparing datatypes, settings, actions to take/reply things like that. </p>\n\n<p>So for this you need objects with the same instance so you can check if it is a enum type <code>if(something instanceof enum)</code>\nAlso if you get an enum object you want to be able to do stuff with it, regardless of the enum type, it should always respond in the same way.</p>\n\n<p>In my case its comparing values of datatypes, but it could be anything, from modifying blocks in facing direction in a 3d game to passing values on to a specific object type registry.</p>\n\n<p>Keeping in mind it is javascript and doesn't provide fixed enum type, you end up always making your own implementation and as this thread shows there are legions of implementations without one being the absoulte correct.</p>\n\n<hr>\n\n<p>This is what I use for Enums. Since enums are immutable(or should be at least heh) I freeze the objects so they can't be manipulated easely.</p>\n\n<p>The enums can be used by EnumField.STRING and they have their own methods that will work with their types.\nTo test if something passed to an object you can use <code>if(somevar instanceof EnumFieldSegment)</code></p>\n\n<p>It may not be the most elegant solution and i'm open for improvements, but this type of immutable enum(unless you unfreeze it) is exactly the usecase I needed.</p>\n\n<p>I also realise I could have overridden the prototype with a {} but my mind works better with this format ;-) shoot me.</p>\n\n<pre><code>/**\n * simple parameter object instantiator\n * @param name\n * @param value\n * @returns\n */\nfunction p(name,value) {\n    this.name = name;\n    this.value = value;\n    return Object.freeze(this);\n}\n/**\n * EnumFieldSegmentBase\n */\nfunction EnumFieldSegmentBase() {\n    this.fieldType = \"STRING\";\n}\nfunction dummyregex() {\n}\ndummyregex.prototype.test = function(str) {\n    if(this.fieldType === \"STRING\") {\n        maxlength = arguments[1];\n        return str.length &lt;= maxlength;\n    }\n    return true;\n};\n\ndummyregexposer = new dummyregex();\nEnumFieldSegmentBase.prototype.getInputRegex = function() { \n    switch(this.fieldType) {\n        case \"STRING\" :     return dummyregexposer;  \n        case \"INT\":         return /^(\\d+)?$/;\n        case \"DECIMAL2\":    return /^\\d+(\\.\\d{1,2}|\\d+|\\.)?$/;\n        case \"DECIMAL8\":    return /^\\d+(\\.\\d{1,8}|\\d+|\\.)?$/;\n        // boolean is tricky dicky. if its a boolean false, if its a string if its empty 0 or false its  false, otherwise lets see what Boolean produces\n        case \"BOOLEAN\":     return dummyregexposer;\n    }\n};\nEnumFieldSegmentBase.prototype.convertToType = function($input) {\n    var val = $input;\n    switch(this.fieldType) {\n        case \"STRING\" :         val = $input;break;\n        case \"INT\":         val==\"\"? val=0 :val = parseInt($input);break;\n        case \"DECIMAL2\":    if($input === \"\" || $input === null) {$input = \"0\"}if($input.substr(-1) === \".\"){$input = $input+0};val = new Decimal2($input).toDP(2);break;\n        case \"DECIMAL8\":    if($input === \"\" || $input === null) {$input = \"0\"}if($input.substr(-1) === \".\"){$input = $input+0};val = new Decimal8($input).toDP(8);break;\n        // boolean is tricky dicky. if its a boolean false, if its a string if its empty 0 or false its  false, otherwise lets see what Boolean produces\n        case \"BOOLEAN\":     val = (typeof $input == 'boolean' ? $input : (typeof $input === 'string' ? (($input === \"false\" || $input === \"\" || $input === \"0\") ? false : true) : new Boolean($input).valueOf()))  ;break;\n    }\n    return val;\n};\nEnumFieldSegmentBase.prototype.convertToString = function($input) {\n    var val = $input;\n    switch(this.fieldType) {\n        case \"STRING\":      val = $input;break;\n        case \"INT\":         val = $input+\"\";break;\n        case \"DECIMAL2\":    val = $input.toPrecision(($input.toString().indexOf('.') === -1 ? $input.toString().length+2 : $input.toString().indexOf('.')+2)) ;break;\n        case \"DECIMAL8\":    val = $input.toPrecision(($input.toString().indexOf('.') === -1 ? $input.toString().length+8 : $input.toString().indexOf('.')+8)) ;break;\n        case \"BOOLEAN\":     val = $input ? \"true\" : \"false\"  ;break;\n    }\n    return val;\n};\nEnumFieldSegmentBase.prototype.compareValue = function($val1,$val2) {\n    var val = false;\n    switch(this.fieldType) {\n        case \"STRING\":      val = ($val1===$val2);break;\n        case \"INT\":         val = ($val1===$val2);break;\n        case \"DECIMAL2\":    val = ($val1.comparedTo($val2)===0);break;\n        case \"DECIMAL8\":    val = ($val1.comparedTo($val2)===0);break;\n        case \"BOOLEAN\":     val = ($val1===$val2);break;\n    }\n    return val;\n};\n\n/**\n * EnumFieldSegment is an individual segment in the \n * EnumField\n * @param $array An array consisting of object p\n */\nfunction EnumFieldSegment() {\n    for(c=0;c&lt;arguments.length;c++) {\n        if(arguments[c] instanceof p) {\n            this[arguments[c].name] = arguments[c].value;\n        }\n    }\n    return Object.freeze(this); \n}\nEnumFieldSegment.prototype = new EnumFieldSegmentBase();\nEnumFieldSegment.prototype.constructor = EnumFieldSegment;\n\n\n/**\n * Simple enum to show what type of variable a Field type is.\n * @param STRING\n * @param INT\n * @param DECIMAL2\n * @param DECIMAL8\n * @param BOOLEAN\n * \n */\nEnumField = Object.freeze({STRING:      new EnumFieldSegment(new p(\"fieldType\",\"STRING\")), \n                            INT:        new EnumFieldSegment(new p(\"fieldType\",\"INT\")), \n                            DECIMAL2:   new EnumFieldSegment(new p(\"fieldType\",\"DECIMAL2\")), \n                            DECIMAL8:   new EnumFieldSegment(new p(\"fieldType\",\"DECIMAL8\")), \n                            BOOLEAN:    new EnumFieldSegment(new p(\"fieldType\",\"BOOLEAN\"))});\n</code></pre>\n"},{"score":4,"body":"<p>I've just published an NPM package <a href=\"https://www.npmjs.com/package/gen_enum\" rel=\"nofollow\">gen_enum</a> allows you to create Enum data structure in Javascript quickly:</p>\n\n<pre><code>var genEnum = require('gen_enum');\n\nvar AppMode = genEnum('SIGN_UP, LOG_IN, FORGOT_PASSWORD');\nvar curMode = AppMode.LOG_IN;\nconsole.log(curMode.isLogIn()); // output true \nconsole.log(curMode.isSignUp()); // output false \nconsole.log(curMode.isForgotPassword()); // output false \n</code></pre>\n\n<p>One nice thing about this little tool is in modern environment (including nodejs and IE 9+ browsers) the returned Enum object is immutable.</p>\n\n<p>For more information please checkout <a href=\"https://github.com/greenlaw110/enumjs\" rel=\"nofollow\">https://github.com/greenlaw110/enumjs</a></p>\n\n<p><strong>Updates</strong></p>\n\n<p>I obsolete <code>gen_enum</code> package and merge the function into <a href=\"https://www.npmjs.com/package/constjs\" rel=\"nofollow\">constjs</a> package, which provides more features including immutable objects, JSON string deserialization, string constants and bitmap generation etc. Checkout <a href=\"https://www.npmjs.com/package/constjs\" rel=\"nofollow\">https://www.npmjs.com/package/constjs</a> for more information </p>\n\n<p>To upgrade from <code>gen_enum</code> to <code>constjs</code> just change the statement</p>\n\n<pre><code>var genEnum = require('gen_enum');\n</code></pre>\n\n<p>to</p>\n\n<pre><code>var genEnum = require('constjs').enum;\n</code></pre>\n"},{"score":0,"body":"<pre><code>var DaysEnum = Object.freeze ({ monday: {}, tuesday: {}, ... });\n</code></pre>\n\n<p>You don't need to specify an <em>id</em>, you can just use an empty object to compare enums. </p>\n\n<pre><code>if (incommingEnum === DaysEnum.monday) //incommingEnum is monday\n</code></pre>\n\n<p><strong>EDIT:</strong> If you are going to serialize the object (to JSON for instance) you'll the <em>id</em> again.</p>\n\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/287903/enums-in-javascript#comment12864576_5040502\">( taken from Gabriel Llamas comment )</a></li>\n<li><a href=\"https://stackoverflow.com/questions/287903/enums-in-javascript/30045582?noredirect=1#comment71130974_30045582\">( edit based on Stijn de Witt's comment )</a></li>\n</ul>\n"},{"score":56,"body":"<p>In most modern browsers, there is a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\" rel=\"noreferrer\">symbol</a> primitive data type which can be used to create an enumeration. It will ensure type safety of the enum as each symbol value is guaranteed by JavaScript to be unique, i.e. <code>Symbol() != Symbol()</code>. For example:</p>\n\n<pre><code>const COLOR = Object.freeze({RED: Symbol(), BLUE: Symbol()});\n</code></pre>\n\n<p>To simplify debugging, you can add a description to enum values:</p>\n\n<pre><code>const COLOR = Object.freeze({RED: Symbol(\"RED\"), BLUE: Symbol(\"BLUE\")});\n</code></pre>\n\n<p><a href=\"http://plnkr.co/edit/rGjzZlUF4HPdllaTQ3OW?p=preview\" rel=\"noreferrer\">Plunker demo</a></p>\n\n<p>On <a href=\"https://github.com/zhaber/symbol-enum\" rel=\"noreferrer\">GitHub</a> you can find a wrapper that simplifies the code required to initialize the enum:</p>\n\n<pre><code>const color = new Enum(\"RED\", \"BLUE\")\n\ncolor.RED.toString() // Symbol(RED)\ncolor.getName(color.RED) // RED\ncolor.size // 2\ncolor.values() // Symbol(RED), Symbol(BLUE)\ncolor.toString() // RED,BLUE\n</code></pre>\n"},{"score":6,"body":"<p>IE8 does Not support freeze() method.<br>\nSource: <a href=\"http://kangax.github.io/compat-table/es5/\" rel=\"nofollow\">http://kangax.github.io/compat-table/es5/</a>, Click on \"Show obsolete browsers?\" on top, and check IE8 &amp; freeze row col intersection.</p>\n\n<p>In my current game project, I have used below, since few customers still use IE8:</p>\n\n<pre><code>var CONST_WILD_TYPES = {\n    REGULAR: 'REGULAR',\n    EXPANDING: 'EXPANDING',\n    STICKY: 'STICKY',\n    SHIFTING: 'SHIFTING'\n};\n</code></pre>\n\n<p>We could also do:  </p>\n\n<pre><code>var CONST_WILD_TYPES = {\n    REGULAR: 'RE',\n    EXPANDING: 'EX',\n    STICKY: 'ST',\n    SHIFTING: 'SH'\n};\n</code></pre>\n\n<p>or even this:  </p>\n\n<pre><code>var CONST_WILD_TYPES = {\n    REGULAR: '1',\n    EXPANDING: '2',\n    STICKY: '3',\n    SHIFTING: '4'\n};\n</code></pre>\n\n<p>The last one, seems most efficient for string, it reduces your total bandwidth if you have server &amp; client exchanging this data.<br>\nOf course, now it's your duty to make sure there are no conflicts in the data (RE, EX, etc. must be unique, also 1, 2, etc. should be unique). Note that you need to maintain these forever for backward compatibility.  </p>\n\n<p>Assignment:</p>\n\n<pre><code>var wildType = CONST_WILD_TYPES.REGULAR;\n</code></pre>\n\n<p>Comparision:</p>\n\n<pre><code>if (wildType === CONST_WILD_TYPES.REGULAR) {\n    // do something here\n}\n</code></pre>\n"},{"score":15,"body":"<p>Create an object literal:</p>\n\n<pre><code>const Modes = {\n  DRAGGING: 'drag',\n  SCALING:  'scale',\n  CLICKED:  'click'\n};\n</code></pre>\n"},{"score":3,"body":"<p>It's easy to use, I think. <a href=\"https://stackoverflow.com/a/32245370/4365315\">https://stackoverflow.com/a/32245370/4365315</a></p>\n\n<pre><code>var A = {a:11, b:22}, \nenumA = new TypeHelper(A);\n\nif(enumA.Value === A.b || enumA.Key === \"a\"){ \n... \n}\n\nvar keys = enumA.getAsList();//[object, object]\n\n//set\nenumA.setType(22, false);//setType(val, isKey)\n\nenumA.setType(\"a\", true);\n\nenumA.setTypeByIndex(1);\n</code></pre>\n\n<p>UPDATE:</p>\n\n<p>There is my helper codes(<code>TypeHelper</code>).</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var Helper = {\r\n    isEmpty: function (obj) {\r\n        return !obj || obj === null || obj === undefined || Array.isArray(obj) &amp;&amp; obj.length === 0;\r\n    },\r\n\r\n    isObject: function (obj) {\r\n        return (typeof obj === 'object');\r\n    },\r\n\r\n    sortObjectKeys: function (object) {\r\n        return Object.keys(object)\r\n            .sort(function (a, b) {\r\n                c = a - b;\r\n                return c\r\n            });\r\n    },\r\n    containsItem: function (arr, item) {\r\n        if (arr &amp;&amp; Array.isArray(arr)) {\r\n            return arr.indexOf(item) &gt; -1;\r\n        } else {\r\n            return arr === item;\r\n        }\r\n    },\r\n\r\n    pushArray: function (arr1, arr2) {\r\n        if (arr1 &amp;&amp; arr2 &amp;&amp; Array.isArray(arr1)) {\r\n            arr1.push.apply(arr1, Array.isArray(arr2) ? arr2 : [arr2]);\r\n        }\r\n    }\r\n};\r\nfunction TypeHelper() {\r\n    var _types = arguments[0],\r\n        _defTypeIndex = 0,\r\n        _currentType,\r\n        _value,\r\n        _allKeys = Helper.sortObjectKeys(_types);\r\n\r\n    if (arguments.length == 2) {\r\n        _defTypeIndex = arguments[1];\r\n    }\r\n\r\n    Object.defineProperties(this, {\r\n        Key: {\r\n            get: function () {\r\n                return _currentType;\r\n            },\r\n            set: function (val) {\r\n                _currentType.setType(val, true);\r\n            },\r\n            enumerable: true\r\n        },\r\n        Value: {\r\n            get: function () {\r\n                return _types[_currentType];\r\n            },\r\n            set: function (val) {\r\n                _value.setType(val, false);\r\n            },\r\n            enumerable: true\r\n        }\r\n    });\r\n    this.getAsList = function (keys) {\r\n        var list = [];\r\n        _allKeys.forEach(function (key, idx, array) {\r\n            if (key &amp;&amp; _types[key]) {\r\n\r\n                if (!Helper.isEmpty(keys) &amp;&amp; Helper.containsItem(keys, key) || Helper.isEmpty(keys)) {\r\n                    var json = {};\r\n                    json.Key = key;\r\n                    json.Value = _types[key];\r\n                    Helper.pushArray(list, json);\r\n                }\r\n            }\r\n        });\r\n        return list;\r\n    };\r\n\r\n    this.setType = function (value, isKey) {\r\n        if (!Helper.isEmpty(value)) {\r\n            Object.keys(_types).forEach(function (key, idx, array) {\r\n                if (Helper.isObject(value)) {\r\n                    if (value &amp;&amp; value.Key == key) {\r\n                        _currentType = key;\r\n                    }\r\n                } else if (isKey) {\r\n                    if (value &amp;&amp; value.toString() == key.toString()) {\r\n                        _currentType = key;\r\n                    }\r\n                } else if (value &amp;&amp; value.toString() == _types[key]) {\r\n                    _currentType = key;\r\n                }\r\n            });\r\n        } else {\r\n            this.setDefaultType();\r\n        }\r\n        return isKey ? _types[_currentType] : _currentType;\r\n    };\r\n\r\n    this.setTypeByIndex = function (index) {\r\n        for (var i = 0; i &lt; _allKeys.length; i++) {\r\n            if (index === i) {\r\n                _currentType = _allKeys[index];\r\n                break;\r\n            }\r\n        }\r\n    };\r\n\r\n    this.setDefaultType = function () {\r\n        this.setTypeByIndex(_defTypeIndex);\r\n    };\r\n\r\n    this.setDefaultType();\r\n}\r\n\r\nvar TypeA = {\r\n    \"-1\": \"Any\",\r\n    \"2\": \"2L\",\r\n    \"100\": \"100L\",\r\n    \"200\": \"200L\",\r\n    \"1000\": \"1000L\"\r\n};\r\n\r\nvar enumA = new TypeHelper(TypeA, 4);\r\n\r\ndocument.writeln(\"Key = \", enumA.Key,\", Value = \", enumA.Value, \"&lt;br&gt;\");\r\n\r\n\r\nenumA.setType(\"200L\", false);\r\ndocument.writeln(\"Key = \", enumA.Key,\", Value = \", enumA.Value, \"&lt;br&gt;\");\r\n\r\nenumA.setDefaultType();\r\ndocument.writeln(\"Key = \", enumA.Key,\", Value = \", enumA.Value, \"&lt;br&gt;\");\r\n\r\n\r\nenumA.setTypeByIndex(1);\r\ndocument.writeln(\"Key = \", enumA.Key,\", Value = \", enumA.Value, \"&lt;br&gt;\");\r\n\r\ndocument.writeln(\"is equals = \", (enumA.Value == TypeA[\"2\"]));</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":7,"body":"<p>I came up with <a href=\"https://github.com/vivin/enumjs\" rel=\"noreferrer\">this</a> approach which is modeled after enums in Java. These are type-safe, and so you can perform <code>instanceof</code> checks as well.</p>\n\n<p>You can define enums like this:</p>\n\n<pre><code>var Days = Enum.define(\"Days\", [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]);\n</code></pre>\n\n<p><code>Days</code> now refers to the <code>Days</code> enum:</p>\n\n<pre><code>Days.Monday instanceof Days; // true\n\nDays.Friday.name(); // \"Friday\"\nDays.Friday.ordinal(); // 4\n\nDays.Sunday === Days.Sunday; // true\nDays.Sunday === Days.Friday; // false\n\nDays.Sunday.toString(); // \"Sunday\"\n\nDays.toString() // \"Days { Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday } \"\n\nDays.values().map(function(e) { return e.name(); }); //[\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\nDays.values()[4].name(); //\"Friday\"\n\nDays.fromName(\"Thursday\") === Days.Thursday // true\nDays.fromName(\"Wednesday\").name() // \"Wednesday\"\nDays.Friday.fromName(\"Saturday\").name() // \"Saturday\"\n</code></pre>\n\n<p>The implementation:</p>\n\n<pre><code>var Enum = (function () {\n    /**\n     * Function to define an enum\n     * @param typeName - The name of the enum.\n     * @param constants - The constants on the enum. Can be an array of strings, or an object where each key is an enum\n     * constant, and the values are objects that describe attributes that can be attached to the associated constant.\n     */\n    function define(typeName, constants) {\n\n        /** Check Arguments **/\n        if (typeof typeName === \"undefined\") {\n            throw new TypeError(\"A name is required.\");\n        }\n\n        if (!(constants instanceof Array) &amp;&amp; (Object.getPrototypeOf(constants) !== Object.prototype)) {\n\n            throw new TypeError(\"The constants parameter must either be an array or an object.\");\n\n        } else if ((constants instanceof Array) &amp;&amp; constants.length === 0) {\n\n            throw new TypeError(\"Need to provide at least one constant.\");\n\n        } else if ((constants instanceof Array) &amp;&amp; !constants.reduce(function (isString, element) {\n                return isString &amp;&amp; (typeof element === \"string\");\n            }, true)) {\n\n            throw new TypeError(\"One or more elements in the constant array is not a string.\");\n\n        } else if (Object.getPrototypeOf(constants) === Object.prototype &amp;&amp; !Object.keys(constants).reduce(function (isObject, constant) {\n                return Object.getPrototypeOf(constants[constant]) === Object.prototype;\n            }, true)) {\n\n            throw new TypeError(\"One or more constants do not have an associated object-value.\");\n\n        }\n\n        var isArray = (constants instanceof Array);\n        var isObject = !isArray;\n\n        /** Private sentinel-object used to guard enum constructor so that no one else can create enum instances **/\n        function __() { };\n\n        /** Dynamically define a function with the same name as the enum we want to define. **/\n        var __enum = new Function([\"__\"],\n            \"return function \" + typeName + \"(sentinel, name, ordinal) {\" +\n                \"if(!(sentinel instanceof __)) {\" +\n                    \"throw new TypeError(\\\"Cannot instantiate an instance of \" + typeName + \".\\\");\" +\n                \"}\" +\n\n                \"this.__name = name;\" +\n                \"this.__ordinal = ordinal;\" +\n            \"}\"\n        )(__);\n\n        /** Private objects used to maintain enum instances for values(), and to look up enum instances for fromName() **/\n        var __values = [];\n        var __dict = {};\n\n        /** Attach values() and fromName() methods to the class itself (kind of like static methods). **/\n        Object.defineProperty(__enum, \"values\", {\n            value: function () {\n                return __values;\n            }\n        });\n\n        Object.defineProperty(__enum, \"fromName\", {\n            value: function (name) {\n                var __constant = __dict[name]\n                if (__constant) {\n                    return __constant;\n                } else {\n                    throw new TypeError(typeName + \" does not have a constant with name \" + name + \".\");\n                }\n            }\n        });\n\n        /**\n         * The following methods are available to all instances of the enum. values() and fromName() need to be\n         * available to each constant, and so we will attach them on the prototype. But really, they're just\n         * aliases to their counterparts on the prototype.\n         */\n        Object.defineProperty(__enum.prototype, \"values\", {\n            value: __enum.values\n        });\n\n        Object.defineProperty(__enum.prototype, \"fromName\", {\n            value: __enum.fromName\n        });\n\n        Object.defineProperty(__enum.prototype, \"name\", {\n            value: function () {\n                return this.__name;\n            }\n        });\n\n        Object.defineProperty(__enum.prototype, \"ordinal\", {\n            value: function () {\n                return this.__ordinal;\n            }\n        });\n\n        Object.defineProperty(__enum.prototype, \"valueOf\", {\n            value: function () {\n                return this.__name;\n            }\n        });\n\n        Object.defineProperty(__enum.prototype, \"toString\", {\n            value: function () {\n                return this.__name;\n            }\n        });\n\n        /**\n         * If constants was an array, we can the element values directly. Otherwise, we will have to use the keys\n         * from the constants object.\n         */\n        var _constants = constants;\n        if (isObject) {\n            _constants = Object.keys(constants);\n        }\n\n        /** Iterate over all constants, create an instance of our enum for each one, and attach it to the enum type **/\n        _constants.forEach(function (name, ordinal) {\n            // Create an instance of the enum\n            var __constant = new __enum(new __(), name, ordinal);\n\n            // If constants was an object, we want to attach the provided attributes to the instance.\n            if (isObject) {\n                Object.keys(constants[name]).forEach(function (attr) {\n                    Object.defineProperty(__constant, attr, {\n                        value: constants[name][attr]\n                    });\n                });\n            }\n\n            // Freeze the instance so that it cannot be modified.\n            Object.freeze(__constant);\n\n            // Attach the instance using the provided name to the enum type itself.\n            Object.defineProperty(__enum, name, {\n                value: __constant\n            });\n\n            // Update our private objects\n            __values.push(__constant);\n            __dict[name] = __constant;\n        });\n\n        /** Define a friendly toString method for the enum **/\n        var string = typeName + \" { \" + __enum.values().map(function (c) {\n                return c.name();\n            }).join(\", \") + \" } \";\n\n        Object.defineProperty(__enum, \"toString\", {\n            value: function () {\n                return string;\n            }\n        });\n\n        /** Freeze our private objects **/\n        Object.freeze(__values);\n        Object.freeze(__dict);\n\n        /** Freeze the prototype on the enum and the enum itself **/\n        Object.freeze(__enum.prototype);\n        Object.freeze(__enum);\n\n        /** Return the enum **/\n        return __enum;\n    }\n\n    return {\n        define: define\n    }\n\n})();\n</code></pre>\n"},{"score":3,"body":"<p>I wrote <strong>enumerationjs</strong> a <a href=\"https://github.com/sveinburne/enumerationjs#top\" rel=\"nofollow\">very tiny library to address the issue</a> which <strong>ensures type safety</strong>, allow enum constants to <strong>inherit from a prototype</strong>, guaranties enum constants and enum types to be immutable + many little features. It allows to refactor a lot of code and move some logic inside the enum definition. Here is an example : </p>\n\n<pre><code>var CloseEventCodes = new Enumeration(\"closeEventCodes\", {\n  CLOSE_NORMAL:          { _id: 1000, info: \"Connection closed normally\" },\n  CLOSE_GOING_AWAY:      { _id: 1001, info: \"Connection closed going away\" },\n  CLOSE_PROTOCOL_ERROR:  { _id: 1002, info: \"Connection closed due to protocol error\"  },\n  CLOSE_UNSUPPORTED:     { _id: 1003, info: \"Connection closed due to unsupported operation\" },\n  CLOSE_NO_STATUS:       { _id: 1005, info: \"Connection closed with no status\" },\n  CLOSE_ABNORMAL:        { _id: 1006, info: \"Connection closed abnormally\" },\n  CLOSE_TOO_LARGE:       { _id: 1009, info: \"Connection closed due to too large packet\" }\n},{ talk: function(){\n    console.log(this.info); \n  }\n});\n\n\nCloseEventCodes.CLOSE_TOO_LARGE.talk(); //prints \"Connection closed due to too large packet\"\nCloseEventCodes.CLOSE_TOO_LARGE instanceof CloseEventCodes //evaluates to true\n</code></pre>\n\n<p><code>Enumeration</code> is basically a factory. </p>\n\n<p><a href=\"https://github.com/sveinburne/enumerationjs/blob/master/JS.GUIDE.MD#top\" rel=\"nofollow\">Fully documented guide available here.</a> Hope this helps. </p>\n"},{"score":4,"body":"<p>I've made an Enum class that can fetch values AND names at O(1). It can also generate an Object Array containing all Names and Values.</p>\n\n<pre><code>function Enum(obj) {\n    // Names must be unique, Values do not.\n    // Putting same values for different Names is risky for this implementation\n\n    this._reserved = {\n        _namesObj: {},\n        _objArr: [],\n        _namesArr: [],\n        _valuesArr: [],\n        _selectOptionsHTML: \"\"\n    };\n\n    for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n            this[k] = obj[k];\n            this._reserved._namesObj[obj[k]] = k;\n        }\n    }\n}\n(function () {\n    this.GetName = function (val) {\n        if (typeof this._reserved._namesObj[val] === \"undefined\")\n            return null;\n        return this._reserved._namesObj[val];\n    };\n\n    this.GetValue = function (name) {\n        if (typeof this[name] === \"undefined\")\n            return null;\n        return this[name];\n    };\n\n    this.GetObjArr = function () {\n        if (this._reserved._objArr.length == 0) {\n            var arr = [];\n            for (k in this) {\n                if (this.hasOwnProperty(k))\n                    if (k != \"_reserved\")\n                        arr.push({\n                            Name: k,\n                            Value: this[k]\n                        });\n            }\n            this._reserved._objArr = arr;\n        }\n        return this._reserved._objArr;\n    };\n\n    this.GetNamesArr = function () {\n        if (this._reserved._namesArr.length == 0) {\n            var arr = [];\n            for (k in this) {\n                if (this.hasOwnProperty(k))\n                    if (k != \"_reserved\")\n                        arr.push(k);\n            }\n            this._reserved._namesArr = arr;\n        }\n        return this._reserved._namesArr;\n    };\n\n    this.GetValuesArr = function () {\n        if (this._reserved._valuesArr.length == 0) {\n            var arr = [];\n            for (k in this) {\n                if (this.hasOwnProperty(k))\n                    if (k != \"_reserved\")\n                        arr.push(this[k]);\n            }\n            this._reserved._valuesArr = arr;\n        }\n        return this._reserved._valuesArr;\n    };\n\n    this.GetSelectOptionsHTML = function () {\n        if (this._reserved._selectOptionsHTML.length == 0) {\n            var html = \"\";\n            for (k in this) {\n                if (this.hasOwnProperty(k))\n                    if (k != \"_reserved\")\n                        html += \"&lt;option value='\" + this[k] + \"'&gt;\" + k + \"&lt;/option&gt;\";\n            }\n            this._reserved._selectOptionsHTML = html;\n        }\n        return this._reserved._selectOptionsHTML;\n    };\n}).call(Enum.prototype);\n</code></pre>\n\n<p>You can init'd it like this:</p>\n\n<pre><code>var enum1 = new Enum({\n    item1: 0,\n    item2: 1,\n    item3: 2\n});\n</code></pre>\n\n<p>To fetch a value (like Enums in C#):</p>\n\n<pre><code>var val2 = enum1.item2;\n</code></pre>\n\n<p>To fetch a name for a value (can be ambiguous when putting the same value for different names):</p>\n\n<pre><code>var name1 = enum1.GetName(0);  // \"item1\"\n</code></pre>\n\n<p>To get an array with each name &amp; value in an object:</p>\n\n<pre><code>var arr = enum1.GetObjArr();\n</code></pre>\n\n<p>Will generate:</p>\n\n<pre><code>[{ Name: \"item1\", Value: 0}, { ... }, ... ]\n</code></pre>\n\n<p>You can also get the html select options readily:</p>\n\n<pre><code>var html = enum1.GetSelectOptionsHTML();\n</code></pre>\n\n<p>Which holds:</p>\n\n<pre><code>\"&lt;option value='0'&gt;item1&lt;/option&gt;...\"\n</code></pre>\n"},{"score":2,"body":"<p>You can try this:</p>\n\n<pre><code>   var Enum = Object.freeze({\n            Role: Object.freeze({ Administrator: 1, Manager: 2, Supervisor: 3 }),\n            Color:Object.freeze({RED : 0, GREEN : 1, BLUE : 2 })\n            });\n\n    alert(Enum.Role.Supervisor);\n    alert(Enum.Color.GREEN);\n    var currentColor=0;\n    if(currentColor == Enum.Color.RED) {\n       alert('Its Red');\n    }\n</code></pre>\n"},{"score":4,"body":"<p>You can do something like this</p>\n\n<pre><code>    var Enum = (function(foo) {\n\n    var EnumItem = function(item){\n        if(typeof item == \"string\"){\n            this.name = item;\n        } else {\n            this.name = item.name;\n        }\n    }\n    EnumItem.prototype = new String(\"DEFAULT\");\n    EnumItem.prototype.toString = function(){\n        return this.name;\n    }\n    EnumItem.prototype.equals = function(item){\n        if(typeof item == \"string\"){\n            return this.name == item;\n        } else {\n            return this == item &amp;&amp; this.name == item.name;\n        }\n    }\n\n    function Enum() {\n        this.add.apply(this, arguments);\n        Object.freeze(this);\n    }\n    Enum.prototype.add = function() {\n        for (var i in arguments) {\n            var enumItem = new EnumItem(arguments[i]);\n            this[enumItem.name] = enumItem;\n        }\n    };\n    Enum.prototype.toList = function() {\n        return Object.keys(this);\n    };\n    foo.Enum = Enum;\n    return Enum;\n})(this);\nvar STATUS = new Enum(\"CLOSED\",\"PENDING\", { name : \"CONFIRMED\", ackd : true });\nvar STATE = new Enum(\"CLOSED\",\"PENDING\",\"CONFIRMED\",{ name : \"STARTED\"},{ name : \"PROCESSING\"});\n</code></pre>\n\n<p>As defined in this library.\n<a href=\"https://github.com/webmodule/foo/blob/master/foo.js#L217\" rel=\"nofollow noreferrer\">https://github.com/webmodule/foo/blob/master/foo.js#L217</a></p>\n\n<p>Complete example\n<a href=\"https://gist.github.com/lnt/bb13a2fd63cdb8bce85fd62965a20026\" rel=\"nofollow noreferrer\">https://gist.github.com/lnt/bb13a2fd63cdb8bce85fd62965a20026</a></p>\n"},{"score":4,"body":"<p><strong>Simplest solution:</strong></p>\n\n<h2>Create</h2>\n\n<pre><code>var Status = Object.freeze({\n    \"Connecting\":0,\n    \"Ready\":1,\n    \"Loading\":2,\n    \"Processing\": 3\n});\n</code></pre>\n\n<h2>Get Value</h2>\n\n<pre><code>console.log(Status.Ready) // 1\n</code></pre>\n\n<h2>Get Key</h2>\n\n<pre><code>console.log(Object.keys(Status)[Status.Ready]) // Ready\n</code></pre>\n"},{"score":4,"body":"<p>Even though <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes\" rel=\"nofollow noreferrer\">only static methods</a> (and not static properties) are supported in ES2015 (see <a href=\"http://exploringjs.com/es6/ch_classes.html#_inside-the-body-of-a-class-definition\" rel=\"nofollow noreferrer\">here</a> as well, &sect;15.2.2.2), curiously you can use the below with Babel with the <code>es2015</code> preset:</p>\n\n<pre><code>class CellState {\n    v: string;\n    constructor(v: string) {\n        this.v = v;\n        Object.freeze(this);\n    }\n    static EMPTY       = new CellState('e');\n    static OCCUPIED    = new CellState('o');\n    static HIGHLIGHTED = new CellState('h');\n    static values      = function(): Array&lt;CellState&gt; {\n        const rv = [];\n        rv.push(CellState.EMPTY);\n        rv.push(CellState.OCCUPIED);\n        rv.push(CellState.HIGHLIGHTED);\n        return rv;\n    }\n}\nObject.freeze(CellState);\n</code></pre>\n\n<p>I found this to be working as expected even across modules (e.g. importing the <code>CellState</code> enum from another module) and also when I import a module using Webpack.</p>\n\n<p><strong>The advantage this method has over most other answers is that you can use it alongside a static type checker</strong> (e.g. <a href=\"https://flowtype.org/\" rel=\"nofollow noreferrer\">Flow</a>) and you can assert, at development time using static type checking, that your variables, parameters, etc. are of the specific <code>CellState</code> \"enum\" rather than some other enum (which would be impossible to distinguish if you used generic objects or symbols).</p>\n\n<h1>update</h1>\n\n<p>The above code has a deficiency in that it allows one to create additional objects of type <code>CellState</code> (even though one can't assign them to the static fields of <code>CellState</code> since it's frozen). Still, the below more refined code offers the following advantages:</p>\n\n<ol>\n<li>no more objects of type <code>CellState</code> may be created</li>\n<li>you are guaranteed that no two enum instances are assigned the same code</li>\n<li>utility method to get the enum back from a string representation</li>\n<li><p>the <code>values</code> function that returns all instances of the enum does not have to create the return value in the above, manual (and error-prone) way.</p>\n\n<pre><code>'use strict';\n\nclass Status {\n\nconstructor(code, displayName = code) {\n    if (Status.INSTANCES.has(code))\n        throw new Error(`duplicate code value: [${code}]`);\n    if (!Status.canCreateMoreInstances)\n        throw new Error(`attempt to call constructor(${code}`+\n       `, ${displayName}) after all static instances have been created`);\n    this.code        = code;\n    this.displayName = displayName;\n    Object.freeze(this);\n    Status.INSTANCES.set(this.code, this);\n}\n\ntoString() {\n    return `[code: ${this.code}, displayName: ${this.displayName}]`;\n}\nstatic INSTANCES   = new Map();\nstatic canCreateMoreInstances      = true;\n\n// the values:\nstatic ARCHIVED    = new Status('Archived');\nstatic OBSERVED    = new Status('Observed');\nstatic SCHEDULED   = new Status('Scheduled');\nstatic UNOBSERVED  = new Status('Unobserved');\nstatic UNTRIGGERED = new Status('Untriggered');\n\nstatic values      = function() {\n    return Array.from(Status.INSTANCES.values());\n}\n\nstatic fromCode(code) {\n    if (!Status.INSTANCES.has(code))\n        throw new Error(`unknown code: ${code}`);\n    else\n        return Status.INSTANCES.get(code);\n}\n}\n\nStatus.canCreateMoreInstances = false;\nObject.freeze(Status);\nexports.Status = Status;\n</code></pre></li>\n</ol>\n"},{"score":1,"body":"<p>The Alien solution is to make things as simple as possible:</p>\n\n<ol>\n<li>use enum keyword (reserved in javascript)</li>\n<li><p>If enum keyword is just reserved but not implemented in your javascript, define the following</p>\n\n<pre><code>const enumerate = spec =&gt; spec.split(/\\s*,\\s*/)\n  .reduce((e, n) =&gt; Object.assign(e,{[n]:n}), {}) \n</code></pre></li>\n</ol>\n\n<p>Now, you can easily use it</p>\n\n<pre><code>const kwords = enumerate(\"begin,end, procedure,if\")\nconsole.log(kwords, kwords.if, kwords.if == \"if\", kwords.undef)\n</code></pre>\n\n<p>I see no reason to make the enum values explicit variables. The scripts are morphic anyway and it makes no difference if part of your code is a string or valid code. What really matters is that you do not need to deal with tons of quotation marks whenever use or define them. </p>\n"},{"score":16,"body":"<p>In <a href=\"https://babeljs.io/docs/plugins/transform-class-properties/\" rel=\"noreferrer\">ES7</a> , you can do an elegant ENUM relying on static attributes: </p>\n\n<pre><code>class ColorEnum  {\n    static RED = 0 ;\n    static GREEN = 1;\n    static BLUE = 2;\n}\n</code></pre>\n\n<p>then </p>\n\n<pre><code>if (currentColor === ColorEnum.GREEN ) {/*-- coding --*/}\n</code></pre>\n\n<p>The advantage ( of using class instead of literal object) is to have a parent class <code>Enum</code> then all your Enums will <strong>extends</strong> that class.  </p>\n\n<pre><code> class ColorEnum  extends Enum {/*....*/}\n</code></pre>\n"},{"score":-1,"body":"<p>You could try using <a href=\"https://bitbucket.org/snippets/frostbane/aAjxM\" rel=\"nofollow noreferrer\">https://bitbucket.org/snippets/frostbane/aAjxM</a>.</p>\n\n<pre><code>my.namespace.ColorEnum = new Enum(\n    \"RED = 0\",\n    \"GREEN\",\n    \"BLUE\"\n)\n</code></pre>\n\n<p>It should work up to ie8.</p>\n"},{"score":0,"body":"<p>You can use a simple funcion to invert keys and values, it will work with arrays also as it converts numerical integer strings to numbers. The code is small, simple and reusable for this and other use cases.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var objInvert = function (obj) {\r\n    var invert = {}\r\n    for (var i in obj) {\r\n      if (i.match(/^\\d+$/)) i = parseInt(i,10)\r\n      invert[obj[i]] = i\r\n    }\r\n    return invert\r\n}\r\n \r\nvar musicStyles = Object.freeze(objInvert(['ROCK', 'SURF', 'METAL',\r\n'BOSSA-NOVA','POP','INDIE']))\r\n\r\nconsole.log(musicStyles)</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":5,"body":"<p>es7 way, (iterator, freeze), usage:</p>\n\n<pre><code>const ThreeWiseMen = new Enum('Melchior', 'Caspar', 'Balthazar')\n\nfor (let name of ThreeWiseMen)\n    console.log(name)\n\n\n// with a given key\nlet key = ThreeWiseMen.Melchior\n\nconsole.log(key in ThreeWiseMen) // true (string conversion, also true: 'Melchior' in ThreeWiseMen)\n\nfor (let entry from key.enum)\n     console.log(entry)\n\n\n// prevent alteration (throws TypeError in strict mode)\nThreeWiseMen.Me = 'Me too!'\nThreeWiseMen.Melchior.name = 'Foo'\n</code></pre>\n\n<p>code:</p>\n\n<pre><code>class EnumKey {\n\n    constructor(props) { Object.freeze(Object.assign(this, props)) }\n\n    toString() { return this.name }\n\n}\n\nexport class Enum {\n\n    constructor(...keys) {\n\n        for (let [index, key] of keys.entries()) {\n\n            Object.defineProperty(this, key, {\n\n                value: new EnumKey({ name:key, index, enum:this }),\n                enumerable: true,\n\n            })\n\n        }\n\n        Object.freeze(this)\n\n    }\n\n    *[Symbol.iterator]() {\n\n        for (let key of Object.keys(this))\n            yield this[key]\n\n    }\n\n    toString() { return [...this].join(', ') }\n\n}\n</code></pre>\n"},{"score":27,"body":"<h2>Use Javascript <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" rel=\"noreferrer\">Proxies</a></h2>\n\n<p><strong>TLDR:</strong> Add this class to your utility methods and use it throughout your code, it mocks Enum behavior from traditional programming languages, and actually throws errors when you try to either access an enumerator that does not exist or add/update an enumerator. No need to rely on <code>Object.freeze()</code>.</p>\n\n<pre><code>class Enum {\n  constructor(enumObj) {\n    const handler = {\n      get(target, name) {\n        if (typeof target[name] != 'undefined') {\n          return target[name];\n        }\n        throw new Error(`No such enumerator: ${name}`);\n      },\n      set() {\n        throw new Error('Cannot add/update properties on an Enum instance after it is defined')\n      }\n    };\n\n    return new Proxy(enumObj, handler);\n  }\n}\n</code></pre>\n\n<p>Then create enums by instantiating the class:</p>\n\n<pre><code>const roles = new Enum({\n  ADMIN: 'Admin',\n  USER: 'User',\n});\n</code></pre>\n\n<hr>\n\n<p><strong>Full Explanation:</strong> </p>\n\n<p>One very beneficial feature of Enums that you get from traditional languages is that they blow up (throw a compile-time error) if you try to access an enumerator which does not exist. </p>\n\n<p>Besides freezing the mocked enum structure to prevent additional values from accidentally/maliciously being added, none of the other answers address that intrinsic feature of Enums.</p>\n\n<p>As you are probably aware, accessing non-existing members in JavaScript simply returns <code>undefined</code> and does not blow up your code. Since enumerators are predefined constants (i.e. days of the week), there should never be a case when an enumerator should be undefined.</p>\n\n<p>Don't get me wrong, JavaScript's behavior of returning <code>undefined</code> when accessing undefined properties is actually a very powerful feature of language, but it's not a feature you want when you are trying to mock traditional Enum structures. </p>\n\n<p>This is where Proxy objects shine. Proxies were standardized in the language with the introduction of ES6 (ES2015). Here's the description from MDN: </p>\n\n<blockquote>\n  <p>The Proxy object is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function\n  invocation, etc).</p>\n</blockquote>\n\n<p>Similar to a web server proxy, JavaScript proxies are able to intercept operations on objects (with the use of \"traps\", call them hooks if you like) and allow you to perform various checks, actions and/or manipulations before they complete (or in some cases stopping the operations altogether which is exactly what we want to do if and when we try to reference an enumerator which does not exist).</p>\n\n<p>Here's a contrived example that uses the Proxy object to mimic Enums. The enumerators in this example are standard HTTP Methods (i.e. \"GET\", \"POST\", etc.):</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"true\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// Class for creating enums (13 lines)\r\n// Feel free to add this to your utility library in \r\n// your codebase and profit! Note: As Proxies are an ES6 \r\n// feature, some browsers/clients may not support it and \r\n// you may need to transpile using a service like babel\r\n\r\nclass Enum {\r\n  // The Enum class instantiates a JavaScript Proxy object.\r\n  // Instantiating a `Proxy` object requires two parameters, \r\n  // a `target` object and a `handler`. We first define the handler,\r\n  // then use the handler to instantiate a Proxy.\r\n\r\n  // A proxy handler is simply an object whose properties\r\n  // are functions which define the behavior of the proxy \r\n  // when an operation is performed on it. \r\n  \r\n  // For enums, we need to define behavior that lets us check what enumerator\r\n  // is being accessed and what enumerator is being set. This can be done by \r\n  // defining \"get\" and \"set\" traps.\r\n  constructor(enumObj) {\r\n    const handler = {\r\n      get(target, name) {\r\n        if (typeof target[name] != 'undefined') {\r\n          return target[name]\r\n        }\r\n        throw new Error(`No such enumerator: ${name}`)\r\n      },\r\n      set() {\r\n        throw new Error('Cannot add/update properties on an Enum instance after it is defined')\r\n      }\r\n    }\r\n\r\n\r\n    // Freeze the target object to prevent modifications\r\n    return new Proxy(enumObj, handler)\r\n  }\r\n}\r\n\r\n\r\n// Now that we have a generic way of creating Enums, lets create our first Enum!\r\nconst httpMethods = new Enum({\r\n  DELETE: \"DELETE\",\r\n  GET: \"GET\",\r\n  OPTIONS: \"OPTIONS\",\r\n  PATCH: \"PATCH\",\r\n  POST: \"POST\",\r\n  PUT: \"PUT\"\r\n})\r\n\r\n// Sanity checks\r\nconsole.log(httpMethods.DELETE)\r\n// logs \"DELETE\"\r\n\r\ntry {\r\n  httpMethods.delete = \"delete\"\r\n} catch (e) {\r\nconsole.log(\"Error: \", e.message)\r\n}\r\n// throws \"Cannot add/update properties on an Enum instance after it is defined\"\r\n\r\ntry {\r\n  console.log(httpMethods.delete)\r\n} catch (e) {\r\n  console.log(\"Error: \", e.message)\r\n}\r\n// throws \"No such enumerator: delete\"</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<hr>\n\n<p><strong>ASIDE: What the heck is a proxy?</strong></p>\n\n<p>I remember when I first started seeing the word proxy everywhere, it definitely didn't make sense to me for a long time. If that's you right now, I think an easy way to generalize proxies is to think of them as software, institutions, or even people that act as intermediaries or middlemen between two servers, companies, or people. </p>\n"},{"score":4,"body":"<p>This is how Typescript translates it's <code>enum</code> into Javascript:</p>\n\n<pre><code>var makeEnum = function(obj) {\n    obj[ obj['Active'] = 1 ] = 'Active';\n    obj[ obj['Closed'] = 2 ] = 'Closed';\n    obj[ obj['Deleted'] = 3 ] = 'Deleted';\n}\n</code></pre>\n\n<p>Now:</p>\n\n<pre><code>makeEnum( NewObj = {} )\n// =&gt; {1: \"Active\", 2: \"Closed\", 3: \"Deleted\", Active: 1, Closed: 2, Deleted: 3}\n</code></pre>\n\n<p>At first I was confused why <code>obj[1]</code> returns <code>'Active'</code>, but then realised that its dead simple - <strong>Assignment operator</strong> assigns value and then returns it:</p>\n\n<pre><code>obj['foo'] = 1\n// =&gt; 1\n</code></pre>\n"},{"score":35,"body":"<h1>𝗦𝗲𝗹𝗳-𝗗𝗲𝘀𝗰𝗿𝗶𝗽𝘁𝗶𝘃𝗲 𝗘𝘅𝘁𝗲𝗻𝘀𝗶𝗯𝗹𝗲 𝗩𝗮𝗿𝗶𝗮𝗯𝗹𝗲 𝗡𝗮𝗺𝗲𝘀</h1>\n<p>Let's cut straight to the problem: file size. Every other answer listed here bloats your minified code to the extreme. I present to you that for the best possible reduction in code size by minification, performance, readability of code, large scale project management, and syntax hinting in many code editors, this is the correct way to do enumerations: underscore-notation variables.</p>\n<hr />\n<h1><img src=\"https://i.stack.imgur.com/vUCWq.png\" alt=\"Underscore-Notation Variables\" /></h1>\n<p>As demonstrated in the chart above and example below, here are five easy steps to get started:</p>\n<ol>\n<li>Determine a name for the enumeration group. Think of a noun that can describe the purpose of the enumeration or at least the entries in the enumeration. For example, a group of enumerations representing colors choosable by the user might be better named COLORCHOICES than COLORS.</li>\n<li>Decide whether enumerations in the group are mutually-exclusive or independent. If mutually-exclusive, start each enumerated variable name with <code>ENUM_</code>. If independent or side-by-side, use <code>INDEX_</code>.</li>\n<li>For each entry, create a new local variable whose name starts with <code>ENUM_</code> or <code>INDEX_</code>, then the name of the group, then an underscore, then a unique friendly name for the property</li>\n<li>Add a <code>ENUMLENGTH_</code>, <code>ENUMLEN_</code>, <code>INDEXLENGTH_</code>, or <code>INDEXLEN_</code> (whether <code>LEN_</code> or <code>LENGTH_</code> is personal preference) enumerated variable at the very end. You should use this variable wherever possible in your code to ensure that adding an extra entry to the enumeration and incrementing this value won't break your code.</li>\n<li>Give each successive enumerated variable a value one more than the last, starting at 0. There are comments on this page that say <code>0</code> should not be used as an enumerated value because <code>0 == null</code>, <code>0 == false</code>, <code>0 == \"\"</code>, and other JS craziness. I submit to you that, to avoid this problem and boost performance at the same time, always use <code>===</code> and never let <code>==</code> appear in your code except with <code>typeof</code> (e.x. <code>typeof X == \"string\"</code>). In all my years of using <code>===</code>, I have never once had a problem with using 0 as an enumeration value. If you are still squeamish, then <code>1</code> could be used as the starting value in <code>ENUM_</code> enumerations (but not in <code>INDEX_</code> enumerations) without performance penalty in many cases.</li>\n</ol>\n<pre><code>const ENUM_COLORENUM_RED   = 0;\nconst ENUM_COLORENUM_GREEN = 1;\nconst ENUM_COLORENUM_BLUE  = 2;\nconst ENUMLEN_COLORENUM    = 3;\n\n// later on\n\nif(currentColor === ENUM_COLORENUM_RED) {\n   // whatever\n}\n</code></pre>\n<p>Here is how I remember when to use <code>INDEX_</code> and when to use <code>ENUM_</code>:</p>\n<pre><code>// Precondition: var arr = []; //\narr[INDEX_] = ENUM_;\n</code></pre>\n<p>However, <code>ENUM_</code> can, in certain circumstances, be appropriate as an index such as when counting the occurrences of each item.</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const ENUM_PET_CAT = 0,\n      ENUM_PET_DOG = 1,\n      ENUM_PET_RAT = 2,\n      ENUMLEN_PET  = 3;\n\nvar favoritePets = [ENUM_PET_CAT, ENUM_PET_DOG, ENUM_PET_RAT,\n                    ENUM_PET_DOG, ENUM_PET_DOG, ENUM_PET_CAT,\n                    ENUM_PET_RAT, ENUM_PET_CAT, ENUM_PET_DOG];\n\nvar petsFrequency = [];\n\nfor (var i=0; i&lt;ENUMLEN_PET; i=i+1|0)\n  petsFrequency[i] = 0;\n\nfor (var i=0, len=favoritePets.length|0, petId=0; i&lt;len; i=i+1|0)\n  petsFrequency[petId = favoritePets[i]|0] = (petsFrequency[petId]|0) + 1|0;\n\nconsole.log({\n    \"cat\": petsFrequency[ENUM_PET_CAT],\n    \"dog\": petsFrequency[ENUM_PET_DOG],\n    \"rat\": petsFrequency[ENUM_PET_RAT]\n});</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>Observe that, in the code above, it's really easy to add in a new kind of pet: you would just have to append a new entry after <code>ENUM_PET_RAT</code> and update <code>ENUMLEN_PET</code> accordingly. It might be more difficult and buggy to add a new entry in other systems of enumeration.</p>\n<hr />\n<h1>𝗘𝘅𝘁𝗲𝗻𝗱 𝗨𝗽𝗽𝗲𝗿𝗰𝗮𝘀𝗲 𝗩𝗮𝗿𝗶𝗮𝗯𝗹𝗲𝘀 𝗪𝗶𝘁𝗵 𝗔𝗱𝗱𝗶𝘁𝗶𝗼𝗻</h1>\n<p>Additionally, this syntax of enumerations allows for clear and concise class extending as seen below. To extend a class, add an incrementing number to the <code>LEN_</code> entry of the parent class. Then, finish out the subclass with its own <code>LEN_</code> entry so that the subclass may be extended further in the future.</p>\n<p><img src=\"https://i.stack.imgur.com/xIHxl.png\" alt=\"Addition extension diagram\" /></p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>(function(window){\n    \"use strict\";\n    var parseInt = window.parseInt;\n\n    // use INDEX_ when representing the index in an array instance\n    const INDEX_PIXELCOLOR_TYPE = 0, // is a ENUM_PIXELTYPE\n          INDEXLEN_PIXELCOLOR   = 1,\n          INDEX_SOLIDCOLOR_R    = INDEXLEN_PIXELCOLOR+0,\n          INDEX_SOLIDCOLOR_G    = INDEXLEN_PIXELCOLOR+1,\n          INDEX_SOLIDCOLOR_B    = INDEXLEN_PIXELCOLOR+2,\n          INDEXLEN_SOLIDCOLOR   = INDEXLEN_PIXELCOLOR+3,\n          INDEX_ALPHACOLOR_R    = INDEXLEN_PIXELCOLOR+0,\n          INDEX_ALPHACOLOR_G    = INDEXLEN_PIXELCOLOR+1,\n          INDEX_ALPHACOLOR_B    = INDEXLEN_PIXELCOLOR+2,\n          INDEX_ALPHACOLOR_A    = INDEXLEN_PIXELCOLOR+3,\n          INDEXLEN_ALPHACOLOR   = INDEXLEN_PIXELCOLOR+4,\n    // use ENUM_ when representing a mutually-exclusive species or type\n          ENUM_PIXELTYPE_SOLID = 0,\n          ENUM_PIXELTYPE_ALPHA = 1,\n          ENUM_PIXELTYPE_UNKNOWN = 2,\n          ENUMLEN_PIXELTYPE    = 2;\n\n    function parseHexColor(inputString) {\n        var rawstr = inputString.trim().substring(1);\n        var result = [];\n        if (rawstr.length === 8) {\n            result[INDEX_PIXELCOLOR_TYPE] = ENUM_PIXELTYPE_ALPHA;\n            result[INDEX_ALPHACOLOR_R] = parseInt(rawstr.substring(0,2), 16);\n            result[INDEX_ALPHACOLOR_G] = parseInt(rawstr.substring(2,4), 16);\n            result[INDEX_ALPHACOLOR_B] = parseInt(rawstr.substring(4,6), 16);\n            result[INDEX_ALPHACOLOR_A] = parseInt(rawstr.substring(4,6), 16);\n        } else if (rawstr.length === 4) {\n            result[INDEX_PIXELCOLOR_TYPE] = ENUM_PIXELTYPE_ALPHA;\n            result[INDEX_ALPHACOLOR_R] = parseInt(rawstr[0], 16) * 0x11;\n            result[INDEX_ALPHACOLOR_G] = parseInt(rawstr[1], 16) * 0x11;\n            result[INDEX_ALPHACOLOR_B] = parseInt(rawstr[2], 16) * 0x11;\n            result[INDEX_ALPHACOLOR_A] = parseInt(rawstr[3], 16) * 0x11;\n        } else if (rawstr.length === 6) {\n            result[INDEX_PIXELCOLOR_TYPE] = ENUM_PIXELTYPE_SOLID;\n            result[INDEX_SOLIDCOLOR_R] = parseInt(rawstr.substring(0,2), 16);\n            result[INDEX_SOLIDCOLOR_G] = parseInt(rawstr.substring(2,4), 16);\n            result[INDEX_SOLIDCOLOR_B] = parseInt(rawstr.substring(4,6), 16);\n        } else if (rawstr.length === 3) {\n            result[INDEX_PIXELCOLOR_TYPE] = ENUM_PIXELTYPE_SOLID;\n            result[INDEX_SOLIDCOLOR_R] = parseInt(rawstr[0], 16) * 0x11;\n            result[INDEX_SOLIDCOLOR_G] = parseInt(rawstr[1], 16) * 0x11;\n            result[INDEX_SOLIDCOLOR_B] = parseInt(rawstr[2], 16) * 0x11;\n        } else {\n            result[INDEX_PIXELCOLOR_TYPE] = ENUM_PIXELTYPE_UNKNOWN;\n        }\n        return result;\n    }\n\n    // the red component of green\n    console.log(parseHexColor(\"#0f0\")[INDEX_SOLIDCOLOR_R]);\n    // the alpha of transparent purple\n    console.log(parseHexColor(\"#f0f7\")[INDEX_ALPHACOLOR_A]); \n    // the enumerated array for turquoise\n    console.log(parseHexColor(\"#40E0D0\"));\n})(self);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>(Length: 2,450 bytes)</p>\n<p>Some may say that this is less practical than other solutions: it waists tons of space, it takes a long time to write, and it is not coated with sugar syntax. Those people would be right if they do not minify their code. However, no reasonable person would leave unminified code in the end product. For this minification, Closure Compiler is the best I have yet to find. Online access can be found <a href=\"https://closure-compiler.appspot.com/\" rel=\"nofollow noreferrer\">here</a>. Closure compiler is able to take all of this enumeration data and inline it, making your Javascript be super duper small and run super duper fast. Thus, Minify with Closure Compiler. Observe.</p>\n<hr />\n<h1>𝗠𝗶𝗻𝗶𝗳𝘆 𝗪𝗶𝘁𝗵 <a href=\"https://closure-compiler.appspot.com/\" rel=\"nofollow noreferrer\">𝗖𝗹𝗼𝘀𝘂𝗿𝗲 𝗖𝗼𝗺𝗽𝗶𝗹𝗲𝗿</a></h1>\n<p>Closure compiler is able to perform some pretty incredible optimizations via inferences that are way beyond the capacities of any other Javascript minifier. Closure Compiler is able to inline primitive variables set to a fixed value. Closure Compiler is also able to make inferences based upon these inlined values and eliminate unused blocks in if-statements and loops.</p>\n<p><img src=\"https://i.stack.imgur.com/2cadt.jpg\" alt=\"Wringing code via Closure Compiler\" /></p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>'use strict';(function(e){function d(a){a=a.trim().substring(1);var b=[];8===a.length?(b[0]=1,b[1]=c(a.substring(0,2),16),b[2]=c(a.substring(2,4),16),b[3]=c(a.substring(4,6),16),b[4]=c(a.substring(4,6),16)):4===a.length?(b[1]=17*c(a[0],16),b[2]=17*c(a[1],16),b[3]=17*c(a[2],16),b[4]=17*c(a[3],16)):6===a.length?(b[0]=0,b[1]=c(a.substring(0,2),16),b[2]=c(a.substring(2,4),16),b[3]=c(a.substring(4,6),16)):3===a.length?(b[0]=0,b[1]=17*c(a[0],16),b[2]=17*c(a[1],16),b[3]=17*c(a[2],16)):b[0]=2;return b}var c=\ne.parseInt;console.log(d(\"#0f0\")[1]);console.log(d(\"#f0f7\")[4]);console.log(d(\"#40E0D0\"))})(self);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>(Length: 605 bytes)</p>\n<p>Closure Compiler rewards you for coding smarter and organizing your code well because, whereas many minifiers punish organized code with a bigger minified file size, Closure Compiler is able to sift through all your cleanliness and sanity to output an even smaller file size if you use tricks like variable name enumerations. That, in this one mind, is the holy grail of coding: a tool that both assists your code with a smaller minified size and assists your mind by training better programming habits.</p>\n<hr />\n<h1>𝗦𝗺𝗮𝗹𝗹𝗲𝗿 𝗖𝗼𝗱𝗲 𝗦𝗶𝘇𝗲</h1>\n<p>Now, let us see how big the equivalent file would be without any of these enumerations.\n<br /><br /></p>\n<p><a href=\"https://pastebin.com/embed_iframe/fcX5fN2V\" rel=\"nofollow noreferrer\">Source Without Using Enumerations</a> (length: 1,973 bytes (477 bytes shorter than enumerated code!))<br />\n<a href=\"https://pastebin.com/embed_iframe/97K6XLdU\" rel=\"nofollow noreferrer\">Minified Without Using Enumerations</a> (length: 843 bytes (238 bytes <strong>longer than enumerated code</strong>))</p>\n<p><img src=\"https://i.stack.imgur.com/DX0nA.png\" alt=\"Chart of code sizes\" /></p>\n<p><br /><br /></p>\n<p>As seen, without enumerations, the source code is shorter at the cost of a larger minified code. I do not know about you; but I know for sure that I do not incorporate source code into the end product. Thus, this form of enumerations is far superior insomuch that it results in smaller minified file sizes.</p>\n<hr />\n<h1>𝗖𝗼𝗼𝗽𝗲𝗿𝗮𝘁𝗶𝘃𝗲 🤝 𝗕𝘂𝗴 𝗙𝗶𝘅𝗶𝗻𝗴</h1>\n<p>Another advantage about this form of enumeration is that it can be used to easily manage large scale projects without sacrificing minified code size. When working on a large project with lots of other people, it might be beneficial to explicitly mark and label the variable names with who created the code so that the original creator of the code can be quickly identified for collaborative bug fixing.</p>\n<pre class=\"lang-js prettyprint-override\"><code>// JG = Jack Giffin\nconst ENUM_JG_COLORENUM_RED   = 0,\n      ENUM_JG_COLORENUM_GREEN = 1,\n      ENUM_JG_COLORENUM_BLUE  = 2,\n      ENUMLEN_JG_COLORENUM    = 3;\n\n// later on\n\nif(currentColor === ENUM_JG_COLORENUM_RED) {\n   // whatever\n}\n\n// PL = Pepper Loftus\n// BK = Bob Knight\nconst ENUM_PL_ARRAYTYPE_UNSORTED   = 0,\n      ENUM_PL_ARRAYTYPE_ISSORTED   = 1,\n      ENUM_BK_ARRAYTYPE_CHUNKED    = 2, // added by Bob Knight\n      ENUM_JG_ARRAYTYPE_INCOMPLETE = 3, // added by jack giffin\n      ENUMLEN_PL_COLORENUM         = 4;\n\n// later on\n\nif(\n  randomArray === ENUM_PL_ARRAYTYPE_UNSORTED ||\n  randomArray === ENUM_BK_ARRAYTYPE_CHUNKED\n) {\n   // whatever\n}\n</code></pre>\n\n<hr />\n<h1>𝗦𝘂𝗽𝗲𝗿𝗶𝗼𝗿 𝗣𝗲𝗿𝗳𝗼𝗿𝗺𝗮𝗻𝗰𝗲 <sub><sub><sub><sub><img src=\"https://i.stack.imgur.com/OoOrv.png\" /></sub></sub></sub></sub></h1>\n<p>Further, this form of enumeration is also much faster after minification. In normal named properties, the browser has to use hashmaps to look up where the property is on the object. Although JIT compilers intelligently cache this location on the object, there is still tremendous overhead due to special cases such as deleting a lower property from the object.</p>\n<img src=\"https://v8.dev/_img/elements-kinds/lattice.svg\" />\n<p>But, with continuous non-sparse integer-indexed <a href=\"https://v8.dev/blog/elements-kinds#the-elements-kind-lattice\" rel=\"nofollow noreferrer\">PACKED_ELEMENTS</a> arrays, the browser is able to skip much of that overhead because the index of the value in the internal array is already specified. Yes, according to the ECMAScript standard, all properties are supposed to be treated as strings. Nevertheless, this aspect of the ECMAScript standard is very misleading about performance because all browsers have special optimizations for numeric indexes in arrays.</p>\n<pre><code>/// Hashmaps are slow, even with JIT juice\nvar ref = {};\nref.count = 10;\nref.value = &quot;foobar&quot;;\n</code></pre>\n<p>Compare the code above to the code below.</p>\n<pre><code>/// Arrays, however, are always lightning fast\nconst INDEX_REFERENCE_COUNT = 0;\nconst INDEX_REFERENCE_VALUE = 1;\nconst INDEXLENGTH_REFERENCE = 2;\n\nvar ref = [];\nref[INDEX_REFERENCE_COUNT] = 10;\nref[INDEX_REFERENCE_VALUE] = &quot;foobar&quot;;\n</code></pre>\n<p>One might object to the code with enumerations seeming to be much longer than the code with ordinary objects, but looks can be deceiving. It is important to remember that source code size is not proportional to output size when using the epic Closure Compiler. Observe.</p>\n<pre><code>/// Hashmaps are slow, even with JIT juice\nvar a={count:10,value:&quot;foobar&quot;};\n</code></pre>\n<p>The minified code without enumerations is above and the minified code with enumerations is below.</p>\n<pre><code>/// Arrays, however, are always lightning fast\nvar a=[10,&quot;foobar&quot;];\n</code></pre>\n<p>The example above demonstrates that, in addition to having superior performance, the enumerated code also results in a smaller minified file size.</p>\n<hr />\n<h1>𝗘𝗮𝘀𝘆 𝗗𝗲𝗯𝘂𝗴𝗴𝗶𝗻𝗴</h1>\n<p>Furthermore, this one's personal <em>cherry on the top</em> is using this form of enumerations along with the <a href=\"https://codemirror.net/\" rel=\"nofollow noreferrer\">CodeMirror</a> text editor in Javascript mode. CodeMirror's Javascript syntax highlighting mode highlights local variables in the current scope. That way, you know instantly when you type in a variable name correctly because if the variable name was previously declared with the <code>var</code> keyword, then the variable name turns a special color (cyan by default). Even if you do not use CodeMirror, then at least the browser throws a helpful <code><em>[variable name]</em> is not defined</code> exception when executing code with mistyped enumeration names. Also, JavaScript tools such as JSLint and Closure Compiler are very loud about telling you when you mistype in an enumeration variable name. CodeMirror, the browser, and various Javascript tools put together make debugging this form of enumeration very simple and really easy.</p>\n<p><img src=\"https://i.stack.imgur.com/sSyEB.png\" alt=\"CodeMirror highlighting demonstration\" /></p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const ENUM_COLORENUM_RED   = 0,\n      ENUM_COLORENUM_GREEN = 1,\n      ENUM_COLORENUM_BLUE  = 2,\n      ENUMLEN_COLORENUM    = 3;\nvar currentColor = ENUM_COLORENUM_GREEN;\n\nif(currentColor === ENUM_COLORENUM_RED) {\n   // whatever\n}\n\nif(currentColor === ENUM_COLORENUM_DNE) {\n   // whatever\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>In the above snippet, you were alerted with an error because <code>ENUM_COLORENUM_DNE</code> does not exist.</p>\n<hr />\n<h1>𝗖𝗼𝗻𝗰𝗹𝘂𝘀𝗶𝗼𝗻</h1>\n<p>I think its safe to say that this methodology of enumeration is indeed the best way to go not just for minified code size, but also for performance, debugging, and collaboration.</p>\n"},{"score":0,"body":"<p>This answer is an alternative approach for specific circumstances.  I needed a set of bitmask constants based on attribute sub-values (cases where an attribute value is an array or list of values). It encompasses the equivalent of several overlapping enums. </p>\n\n<p>I created a class to both store and generate the bitmask values. I can then use the pseudo-constant bitmask values this way to test, for example, if green is present in an RGB value: </p>\n\n<pre><code>if (value &amp; Ez.G) {...}\n</code></pre>\n\n<p>In my code I create only one instance of this class.  There doesn't seem to be a clean way to do this without instantiating at least one instance of the class. Here is the class declaration and bitmask value generation code:</p>\n\n<pre><code>class Ez {\nconstructor() {\n    let rgba = [\"R\", \"G\", \"B\", \"A\"];\n    let rgbm = rgba.slice();\n    rgbm.push(\"M\");              // for feColorMatrix values attribute\n    this.createValues(rgba);\n    this.createValues([\"H\", \"S\", \"L\"]);\n    this.createValues([rgba, rgbm]);\n    this.createValues([attX, attY, attW, attH]);\n}\ncreateValues(a) {                // a for array\n    let i, j;\n    if (isA(a[0])) {             // max 2 dimensions\n        let k = 1;\n        for (i of a[0]) {\n            for (j of a[1]) {\n                this[i + j] = k;\n                k *= 2;\n            }\n        }\n    }\n    else {                       // 1D array is simple loop\n        for (i = 0, j = 1; i &lt; a.length; i++, j *= 2)\n            this[a[i]] = j;\n   }\n}\n</code></pre>\n\n<p>The 2D array is for the SVG feColorMatrix values attribute, which is a 4x5 matrix of RGBA by RGBAM, where M is a multiplier. The resulting Ez properties are Ez.RR, Ez.RG, etc.</p>\n"},{"score":2,"body":"<pre><code>class Enum {\n  constructor (...vals) {\n    vals.forEach( val =&gt; {\n      const CONSTANT = Symbol(val);\n      Object.defineProperty(this, val.toUpperCase(), {\n        get () {\n          return CONSTANT;\n        },\n        set (val) {\n          const enum_val = \"CONSTANT\";\n          // generate TypeError associated with attempting to change the value of a constant\n          enum_val = val;\n        }\n      });\n    });\n  }\n}\n</code></pre>\n\n<p>Example of usage:</p>\n\n<pre><code>const COLORS = new Enum(\"red\", \"blue\", \"green\");\n</code></pre>\n"},{"score":1,"body":"<p>Read all the answers and didn't found any non-verbose and DRY solution.\nI use this one-liner:</p>\n\n<pre><code>const modes = ['DRAW', 'SCALE', 'DRAG'].reduce((o, v) =&gt; ({ ...o, [v]: v }), {});\n</code></pre>\n\n<p>it generates an object with human-readable values:</p>\n\n<pre><code>{\n  DRAW: 'DRAW',\n  SCALE: 'SCALE',\n  DRAG: 'DRAG'\n}\n</code></pre>\n"},{"score":5,"body":"<p>I wasn't satisfied with any of the answers, so I made <em>Yet Another Enum (YEA!)</em>.</p>\n\n<p>This implementation:</p>\n\n<ul>\n<li>uses more up-to-date JS</li>\n<li>requires just the declaration of this one class to easily create enums</li>\n<li>has mapping by name (<code>colors.RED</code>), string (<code>colors[\"RED\"]</code>), and index (<code>colors[0]</code>), but you only need to pass in the strings as an array</li>\n<li>binds equivalent <code>toString()</code> and <code>valueOf()</code> functions to each enum object (if this is somehow not desired, one can simply remove it - small overhead for JS though)</li>\n<li>has optional global naming/storage by name string</li>\n<li>freezes the enum object once created so that it can't be modified</li>\n</ul>\n\n<p>Special thanks to <a href=\"https://stackoverflow.com/a/6672823/1599699\">Andre 'Fi''s answer</a> for some inspiration.</p>\n\n<hr>\n\n<p><strong>The codes:</strong></p>\n\n<pre class=\"lang-js prettyprint-override\"><code>class Enums {\n  static create({ name = undefined, items = [] }) {\n    let newEnum = {};\n    newEnum.length = items.length;\n    newEnum.items = items;\n    for (let itemIndex in items) {\n      //Map by name.\n      newEnum[items[itemIndex]] = parseInt(itemIndex, 10);\n      //Map by index.\n      newEnum[parseInt(itemIndex, 10)] = items[itemIndex];\n    }\n    newEnum.toString = Enums.enumToString.bind(newEnum);\n    newEnum.valueOf = newEnum.toString;\n    //Optional naming and global registration.\n    if (name != undefined) {\n      newEnum.name = name;\n      Enums[name] = newEnum;\n    }\n    //Prevent modification of the enum object.\n    Object.freeze(newEnum);\n    return newEnum;\n  }\n  static enumToString() {\n    return \"Enum \" +\n      (this.name != undefined ? this.name + \" \" : \"\") +\n      \"[\" + this.items.toString() + \"]\";\n  }\n}\n</code></pre>\n\n<hr>\n\n<p><strong>Usage:</strong></p>\n\n<pre class=\"lang-js prettyprint-override\"><code>let colors = Enums.create({\n  name: \"COLORS\",\n  items: [ \"RED\", \"GREEN\", \"BLUE\", \"PORPLE\" ]\n});\n\n//Global access, if named.\nEnums.COLORS;\n\ncolors.items; //Array(4) [ \"RED\", \"GREEN\", \"BLUE\", \"PORPLE\" ]\ncolors.length; //4\n\ncolors.RED; //0\ncolors.GREEN; //1\ncolors.BLUE; //2\ncolors.PORPLE; //3\ncolors[0]; //\"RED\"\ncolors[1]; //\"GREEN\"\ncolors[2]; //\"BLUE\"\ncolors[3]; //\"PORPLE\"\n\ncolors.toString(); //\"Enum COLORS [RED,GREEN,BLUE,PORPLE]\"\n\n//Enum frozen, makes it a real enum.\ncolors.RED = 9001;\ncolors.RED; //0\n</code></pre>\n"},{"score":3,"body":"<p>This can be useful:</p>\n<pre class=\"lang-js prettyprint-override\"><code>const [CATS, DOGS, BIRDS] = ENUM();\n</code></pre>\n<p>The implementation is simple and efficient:</p>\n<pre class=\"lang-js prettyprint-override\"><code>function * ENUM(count=1) { while(true) yield count++ }\n</code></pre>\n<p>A generator can yield the exact sequence of integers required, without knowing how many constants there are. It can also support an optional argument that specifies which (possibly negative) number to start from (defaulting to <code>1</code>).</p>\n"},{"score":-1,"body":"<pre><code>export const ButtonType = Object.freeze({ \n   DEFAULT: 'default', \n   BIG: 'big', \n   SMALL: 'small'\n})\n</code></pre>\n<p>source: <a href=\"https://medium.com/@idanlevi2/enum-in-javascript-5f2ff500f149\" rel=\"nofollow noreferrer\">https://medium.com/@idanlevi2/enum-in-javascript-5f2ff500f149</a></p>\n"},{"score":0,"body":"<p>The <a href=\"https://npmjs.com/package/com.recoyxgroup.javascript.enum\" rel=\"nofollow noreferrer\">com.recoyxgroup.javascript.enum</a> package allows you to properly define enum and flags enum classes, where:</p>\n<ul>\n<li>Every constant is represented as an immutable <code>{ _value: someNumber }</code></li>\n<li>Every constant has a property attached to the enum class (E.CONSTANT_NAME)</li>\n<li>Every constant has a friendly String (<code>constantName</code>)</li>\n<li>Every constant has a Number (<code>someNumber</code>)</li>\n<li>You can declare custom properties/methods using <code>E.prototype</code>.</li>\n</ul>\n<p>Wherever a specific enum is expected, the convention is to do <code>E(v)</code>, like this:</p>\n<pre class=\"lang-js prettyprint-override\"><code>const { FlagsEnum } from 'com.recoyxgroup.javascript.enum';\n\nconst Rights = FlagsEnum('Rights', [\n    'ADMINISTRATION',\n    'REVIEW',\n]);\n\nfunction fn(rights) {\n    rights = Rights(rights);\n    console.log('administration' in rights, 'review' in rights);\n}\n\nfn( ['administration', 'review'] ); // true true\nfn( 'administration' ); // true false\nfn( undefined ); // false false\n\nvar r = Rights.ADMINISTRATION;\nconsole.log( r == 'administration' );\n</code></pre>\n<p>As you can see, you can still compare the value to a String.</p>\n<p>Definitions can be more specific:</p>\n<pre><code>const E = FlagsEnum('E', [\n    ['Q', 0x10],\n    ['K', 'someB'],\n    ['L', [0x40, 'someL']],\n]);\n</code></pre>\n<p>FlagsEnum products &gt; Instance properties/methods</p>\n<ul>\n<li>number (was going to be valueOf(), but because of JS ==, had to be 'number')</li>\n<li>set()</li>\n<li>exclude()</li>\n<li>toggle()</li>\n<li>filter()</li>\n<li>valueOf()</li>\n<li>toString()</li>\n</ul>\n"},{"score":3,"body":"<p><strong>Update 05.11.2020:</strong><br>\nModified to include static fields and methods to closer replicate &quot;true&quot; enum behavior.</p>\n<p>Has anyone tried doing this with a class that contains private fields and &quot;get&quot; accessors?\nI realize private class fields are still experimental at this point but it seems to work for the purposes of creating a class with immutable fields/properties. Browser support is decent as well. The only &quot;major&quot; browsers that don't support it are Firefox (which I'm sure they will soon) and IE (who cares).</p>\n<p><em>DISCLAIMER</em>:<br>\nI am not a developer. I was just looking for an answer to this question and started thinking about how I sometimes create &quot;enhanced&quot; enums in C# by creating classes with private fields and restricted property accessors.</p>\n<p><em><strong>Sample Class</strong></em></p>\n<pre><code>class Sizes {\n    // Private Fields\n    static #_SMALL = 0;\n    static #_MEDIUM = 1;\n    static #_LARGE = 2;\n\n    // Accessors for &quot;get&quot; functions only (no &quot;set&quot; functions)\n    static get SMALL() { return this.#_SMALL; }\n    static get MEDIUM() { return this.#_MEDIUM; }\n    static get LARGE() { return this.#_LARGE; }\n}\n</code></pre>\n<p>You should now be able to call your enums directly.</p>\n<pre><code>Sizes.SMALL; // 0\nSizes.MEDIUM; // 1\nSizes.LARGE; // 2\n</code></pre>\n<p>The combination of using private fields and limited accessors means that the enum values are well protected.</p>\n<pre><code>Sizes.SMALL = 10 // Sizes.SMALL is still 0\nSizes._SMALL = 10 // Sizes.SMALL is still 0\nSizes.#_SMALL = 10 // Sizes.SMALL is still 0\n</code></pre>\n"},{"score":1,"body":"<p>There are basically two types of enums, global (like C) and object-like (like TypeScript). For global enums, do something like this-</p>\n<pre class=\"lang-js prettyprint-override\"><code>// Note that // enum is optional, though it makes it look slightly better.\nconst // enum\n  SUNDAY = 1,\n  MONDAY = 2,\n  TUESDAY = 3,\n  WEDNSDAY = 4,\n  THURSDAY = 5,\n  FRIDAY = 6,\n  SATURDAY = 7;\n</code></pre>\n<p>And for object-like enums, do this (like Artur Czajka's answer)-</p>\n<pre class=\"lang-js prettyprint-override\"><code>// A trailing comma isn't required but is a good habit.\nconst Days = Object.freeze({\n  SUNDAY = 1,\n  MONDAY = 2,\n  TUESDAY = 3,\n  WEDSNDAY = 4,\n  THURSDAY = 5,\n  FRIDAY = 6,\n  SATURDAY = 7,\n});\n</code></pre>\n<p>or</p>\n<pre class=\"lang-js prettyprint-override\"><code>const Days = {\n  SUNDAY = 1,\n  MONDAY = 2,\n  TUESDAY = 3,\n  WEDSNDAY = 4,\n  THURSDAY = 5,\n  FRIDAY = 6,\n  SATURDAY = 7,\n};\nObject.freeze(Days);\n</code></pre>\n<p>The first way to declare object-like enums looks slightly cleaner. By the way, global and object-like enums aren't really correct terms, I made them up.</p>\n<p>Edit:</p>\n<p>A solution made (for global enums) by Aral Roca, it looks amazing but has a con of being slow (like 0.1 seconds slow)-</p>\n<pre class=\"lang-js prettyprint-override\"><code>function* ENUM(count = 1) {\n  while (true) yield count++;\n}\n</code></pre>\n<p>and then</p>\n<pre class=\"lang-js prettyprint-override\"><code>const [ RED, GREEN, BLUE ] = ENUM();\n</code></pre>\n"},{"score":0,"body":"<p>Here's my take on a (flagged) <code>Enum</code> factory. Here's a <a href=\"https://jsfiddle.net/KooiInc/1527adxq/\" rel=\"nofollow noreferrer\">working demo</a>.</p>\n<pre><code>/*\n * Notes: \n * The proxy handler enables case insensitive property queries\n * BigInt is used to enable bitflag strings /w length &gt; 52\n*/\nfunction EnumFactory() {\n  const proxyfy = {\n    construct(target, args) { \n      const caseInsensitiveHandler = { \n          get(target, key) {\n          return target[key.toUpperCase()] || target[key];  \n        } \n      };\n      const proxified = new Proxy(new target(...args), caseInsensitiveHandler ); \n      return Object.freeze(proxified);\n    },\n  }\n  const ProxiedEnumCtor = new Proxy(EnumCtor, proxyfy);\n  const throwIf = (\n      assertion = false, \n      message = `Unspecified error`, \n      ErrorType = Error ) =&gt; \n      assertion &amp;&amp; (() =&gt; { throw new ErrorType(message); })();\n  const hasFlag = (val, sub) =&gt; {\n    throwIf(!val || !sub, &quot;valueIn: missing parameters&quot;, RangeError);\n    const andVal = (sub &amp; val);\n    return andVal !== BigInt(0) &amp;&amp; andVal === val;\n  };\n\n  function EnumCtor(values) {\n    throwIf(values.constructor !== Array || \n            values.length &lt; 2 || \n        values.filter( v =&gt; v.constructor !== String ).length &gt; 0,\n      `EnumFactory: expected Array of at least 2 strings`, TypeError);\n    const base = BigInt(1);\n    this.NONE = BigInt(0);\n    values.forEach( (v, i) =&gt; this[v.toUpperCase()] = base&lt;&lt;BigInt(i) );\n  }\n\n  EnumCtor.prototype = {\n    get keys() { return Object.keys(this).slice(1); },\n    subset(sub) {\n      const arrayValues = this.keys;\n      return new ProxiedEnumCtor(\n        [...sub.toString(2)].reverse()\n          .reduce( (acc, v, i) =&gt; ( +v &lt; 1 ? acc : [...acc, arrayValues[i]] ), [] )\n      );\n    },\n    getLabel(enumValue) {\n      const tryLabel = Object.entries(this).find( value =&gt; value[1] === enumValue );\n      return !enumValue || !tryLabel.length ? \n        &quot;getLabel: no value parameter or value not in enum&quot; :\n        tryLabel.shift();\n    },\n    hasFlag(val, sub = this) { return hasFlag(val, sub); },\n  };\n  \n  return arr =&gt; new ProxiedEnumCtor(arr);\n}\n</code></pre>\n"}],"score":2167}