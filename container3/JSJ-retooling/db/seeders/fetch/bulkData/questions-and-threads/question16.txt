{"body":"<p>Is there a regular expression to validate an email address in JavaScript?</p>\n","title":"How to validate an email address in JavaScript","answers":[{"score":69,"body":"<p>JavaScript can match a regular expression:</p>\n\n<pre><code>emailAddress.match( / some_regex /);\n</code></pre>\n\n<p>Here's an <a href=\"http://tools.ietf.org/html/rfc22\" rel=\"noreferrer\">RFC22</a> regular expression for emails:</p>\n\n<pre><code>^((?&gt;[a-zA-Z\\d!#$%&amp;'*+\\-/=?^_`{|}~]+\\x20*|\"((?=[\\x01-\\x7f])[^\"\\\\]|\\\\[\\x01-\\x7f])*\n\"\\x20*)*(?&lt;angle&gt;&lt;))?((?!\\.)(?&gt;\\.?[a-zA-Z\\d!#$%&amp;'*+\\-/=?^_`{|}~]+)+|\"((?=[\\x01-\\x\n7f])[^\"\\\\]|\\\\[\\x01-\\x7f])*\")@(((?!-)[a-zA-Z\\d\\-]+(?&lt;!-)\\.)+[a-zA-Z]{2,}|\\[(((?(?&lt;\n!\\[)\\.)(25[0-5]|2[0-4]\\d|[01]?\\d?\\d)){4}|[a-zA-Z\\d\\-]*[a-zA-Z\\d]:((?=[\\x01-\\x7f])\n[^\\\\\\[\\]]|\\\\[\\x01-\\x7f])+)\\])(?(angle)&gt;)$\n</code></pre>\n"},{"score":5300,"body":"<p>Using <a href=\"http://en.wikipedia.org/wiki/Regular_expression\" rel=\"noreferrer\">regular expressions</a> is probably the best way. You can see a bunch of tests <a href=\"http://jsfiddle.net/ghvj4gy9/embedded/result,js/\" rel=\"noreferrer\">here</a> (taken from <a href=\"https://cs.chromium.org/chromium/src/third_party/blink/web_tests/fast/forms/resources/ValidityState-typeMismatch-email.js?q=ValidityState-typeMismatch-email.js&amp;sq=package:chromium&amp;dr\" rel=\"noreferrer\">chromium</a>)</p>\n\n<pre><code>function validateEmail(email) {\n    const re = /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    return re.test(String(email).toLowerCase());\n}\n</code></pre>\n\n<p>Here's the example of regular expresion that accepts unicode:</p>\n\n<pre><code>const re = /^(([^&lt;&gt;()\\[\\]\\.,;:\\s@\\\"]+(\\.[^&lt;&gt;()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^&lt;&gt;()[\\]\\.,;:\\s@\\\"]+\\.)+[^&lt;&gt;()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n</code></pre>\n\n<p>But keep in mind that one should not rely only upon JavaScript validation. JavaScript can easily be disabled. This should be validated on the server side as well.</p>\n\n<p>Here's an example of the above in action:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function validateEmail(email) {\r\n  const re = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n  return re.test(email);\r\n}\r\n\r\nfunction validate() {\r\n  const $result = $(\"#result\");\r\n  const email = $(\"#email\").val();\r\n  $result.text(\"\");\r\n\r\n  if (validateEmail(email)) {\r\n    $result.text(email + \" is valid :)\");\r\n    $result.css(\"color\", \"green\");\r\n  } else {\r\n    $result.text(email + \" is not valid :(\");\r\n    $result.css(\"color\", \"red\");\r\n  }\r\n  return false;\r\n}\r\n\r\n$(\"#validate\").on(\"click\", validate);</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\"&gt;&lt;/script&gt;\r\n\r\n&lt;form&gt;\r\n  &lt;p&gt;Enter an email address:&lt;/p&gt;\r\n  &lt;input id='email'&gt;\r\n  &lt;button type='submit' id='validate'&gt;Validate!&lt;/button&gt;\r\n&lt;/form&gt;\r\n\r\n&lt;h2 id='result'&gt;&lt;/h2&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":407,"body":"<p>Wow, there are lots of complexity here. If all you want to do is just catch the most obvious syntax errors, I would do something like this:</p>\n\n<pre><code>^\\S+@\\S+$\n</code></pre>\n\n<p>It usually catches the most obvious errors that the user makes and assures that the form is mostly right, which is what JavaScript validation is all about.</p>\n"},{"score":339,"body":"<p>There's something you have to understand the second you decide to use a regular expression to validate emails: <a href=\"http://ex-parrot.com/~pdw/Mail-RFC822-Address.html\" rel=\"noreferrer\">It's probably not a good idea</a>. Once you have come to terms with that, there are many implementations out there that can get you halfway there, <a href=\"http://www.regular-expressions.info/email.html\" rel=\"noreferrer\">this article sums them up nicely.</a></p>\n\n<p>In short, however, the only way to be absolutely, positively sure that what the user entered is in fact an email is to actually send an email and see what happens. Other than that it's all just guesses.</p>\n"},{"score":55,"body":"<p>This was stolen from <a href=\"http://codesnippets.joyent.com/posts/show/1917\" rel=\"noreferrer\">http://codesnippets.joyent.com/posts/show/1917</a></p>\n\n<pre><code>email = $('email');\nfilter = /^([a-zA-Z0-9_\\.\\-])+\\@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z0-9]{2,4})+$/;\nif (filter.test(email.value)) {\n  // Yay! valid\n  return true;\n}\nelse\n  {return false;}\n</code></pre>\n"},{"score":-7,"body":"<p>Following regular expression:</p>\n\n<pre><code>/^([\\w]+)(.[\\w]+)*@([\\w]+)(.[\\w]{2,3}){1,2}$/;\n</code></pre>\n"},{"score":19,"body":"<p>It's hard to get an email validator 100% correct. The only real way to get it correct would be to send a test email to the account. That said, there are a few basic checks that can help make sure that you're getting something reasonable.</p>\n\n<p>Some things to improve:</p>\n\n<p>Instead of new <code>RegExp</code>, just try writing the <code>regexp</code> out like this:</p>\n\n<pre><code>if (reg.test(/@/))\n</code></pre>\n\n<p>Second, check to make sure that a period comes after the <code>@</code> sign, and make sure that there are characters between the <code>@</code>s and periods. </p>\n"},{"score":793,"body":"<p>Just for completeness, <a href=\"http://www.regular-expressions.info/email.html\" rel=\"noreferrer\">here you have another RFC 2822 compliant regex</a></p>\n<blockquote>\n<p>The official standard is known as <a href=\"https://tools.ietf.org/html/rfc2822#section-3.4.1\" rel=\"noreferrer\">RFC 2822</a>. It describes the syntax that valid email addresses must adhere to. You can (<strong>but you shouldn't</strong> — <a href=\"http://www.regular-expressions.info/email.html\" rel=\"noreferrer\">read on</a>) implement it with this regular expression:</p>\n<p><code>(?:[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*|&quot;(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*&quot;)@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\])</code></p>\n<p>(...) We get a more practical implementation of RFC 2822 if we omit the syntax using double quotes and square brackets. <strong>It will still match 99.99% of all email addresses in actual use today.</strong></p>\n<p><code>[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?</code></p>\n<p>A further change you could make is to allow any two-letter country code top level domain, and only specific generic top level domains. <strong>This regex filters dummy email addresses like <code>asdf@adsf.adsf</code></strong>. You <strong>will need to update it as new top-level domains are added</strong>.</p>\n<p><code>[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+(?:[A-Z]{2}|com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum)\\b</code></p>\n<p>So even when following official standards, there are still trade-offs to be made. <em><strong>Don't blindly copy regular expressions from online libraries or discussion forums. Always test them on your own data and with your own applications.</strong></em></p>\n</blockquote>\n<p><sub>Emphasis mine</sub></p>\n"},{"score":12,"body":"<p>Here is a very good discussion about using regular expressions to validate email addresses; \"<a href=\"http://fightingforalostcause.net/misc/2006/compare-email-regex.php\" rel=\"noreferrer\">Comparing E-mail Address Validating Regular Expressions</a>\"</p>\n\n<p>Here is the current top expression, that is JavaScript compatible, for reference purposes:</p>\n\n<pre><code>/^[-a-z0-9~!$%^&amp;*_=+}{\\'?]+(\\.[-a-z0-9~!$%^&amp;*_=+}{\\'?]+)*@([a-z0-9_][-a-z0-9_]*(\\.[-a-z0-9_]+)*\\.(aero|arpa|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|mobi|[a-z][a-z])|([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}))(:[0-9]{1,5})?$/i\n</code></pre>\n"},{"score":12,"body":"<p>Apparently, that's it:</p>\n\n<pre><code>/^([\\w\\!\\#$\\%\\&amp;\\'\\*\\+\\-\\/\\=\\?\\^\\`{\\|\\}\\~]+\\.)*[\\w\\!\\#$\\%\\&amp;\\'\\*\\+\\-\\/\\=\\?\\^\\`{\\|\\}\\~]+@((((([a-z0-9]{1}[a-z0-9\\-]{0,62}[a-z0-9]{1})|[a-z])\\.)+[a-z]{2,6})|(\\d{1,3}\\.){3}\\d{1,3}(\\:\\d{1,5})?)$/i\n</code></pre>\n\n<p>Taken from <a href=\"http://fightingforalostcause.net/misc/2006/compare-email-regex.php\" rel=\"noreferrer\">http://fightingforalostcause.net/misc/2006/compare-email-regex.php</a> on Oct 1 '10.</p>\n\n<p>But, of course, that's ignoring internationalization.</p>\n"},{"score":60,"body":"<p>Correct validation of email address in compliance with the RFCs is not something that can be achieved with a one-liner regular expression. An article with the best solution I've found in PHP is <em><a href=\"http://www.dominicsayers.com/isemail/\" rel=\"noreferrer\">What is a valid email address?</a></em>. Obviously, it has been ported to Java. <strike>I think the function is too complex to be ported and used in JavaScript.</strike> JavaScript/node.js port: <a href=\"https://www.npmjs.com/package/email-addresses\" rel=\"noreferrer\">https://www.npmjs.com/package/email-addresses</a>.</p>\n\n<p>A good practice is to validate your data on the client, but double-check the validation on the server. With this in mind, you can simply check whether a string looks like a valid email address on the client and perform the strict check on the server.</p>\n\n<p>Here's the JavaScript function I use to check if a string looks like a valid mail address:</p>\n\n<pre><code>function looksLikeMail(str) {\n    var lastAtPos = str.lastIndexOf('@');\n    var lastDotPos = str.lastIndexOf('.');\n    return (lastAtPos &lt; lastDotPos &amp;&amp; lastAtPos &gt; 0 &amp;&amp; str.indexOf('@@') == -1 &amp;&amp; lastDotPos &gt; 2 &amp;&amp; (str.length - lastDotPos) &gt; 2);\n}\n</code></pre>\n\n<p>Explanation:</p>\n\n<ul>\n<li><p><code>lastAtPos &lt; lastDotPos</code>: Last <code>@</code> should be before last <code>.</code> since <code>@</code> cannot be part of server name (as far as I know).</p></li>\n<li><p><code>lastAtPos &gt; 0</code>: There should be something (the email username) before the last <code>@</code>.</p></li>\n<li><p><code>str.indexOf('@@') == -1</code>: There should be no <code>@@</code> in the address. Even if <code>@</code> appears as the last character in email username, it has to be quoted so <code>\"</code> would be between that <code>@</code> and the last <code>@</code> in the address.</p></li>\n<li><p><code>lastDotPos &gt; 2</code>: There should be at least three characters before the last dot, for example <code>a@b.com</code>.</p></li>\n<li><p><code>(str.length - lastDotPos) &gt; 2</code>: There should be enough characters after the last dot to form a two-character domain. I'm not sure if the brackets are necessary.</p></li>\n</ul>\n"},{"score":225,"body":"<p>HTML5 itself has email validation. If your browser supports HTML5 then you can use the following code.</p>\n<pre><code>&lt;form&gt;&lt;input type=&quot;email&quot; placeholder=&quot;me@example.com&quot; required&gt;\n    &lt;input type=&quot;submit&quot;&gt;\n&lt;/form&gt;\n</code></pre>\n<p><a href=\"http://jsfiddle.net/edwinthomas25/z6wev5L0/\" rel=\"nofollow noreferrer\">jsFiddle</a> link</p>\n<p>From the <a href=\"http://www.w3.org/TR/html5/forms.html#valid-e-mail-address\" rel=\"nofollow noreferrer\">HTML5 spec</a>:</p>\n<blockquote>\n<p>A <strong>valid e-mail address</strong> is a string that matches the <code>email</code> production of the following ABNF, the character set for which is Unicode.</p>\n<pre><code>email   = 1*( atext / &quot;.&quot; ) &quot;@&quot; label *( &quot;.&quot; label )\nlabel   = let-dig [ [ ldh-str ] let-dig ]  ; limited to a length of 63 characters by RFC 1034 section 3.5\natext   = &lt; as defined in RFC 5322 section 3.2.3 &gt;\nlet-dig = &lt; as defined in RFC 1034 section 3.5 &gt;\nldh-str = &lt; as defined in RFC 1034 section 3.5 &gt;\n</code></pre>\n<p>This requirement is a <a href=\"http://www.w3.org/TR/html5/introduction.html#willful-violation\" rel=\"nofollow noreferrer\">willful violation</a> of RFC 5322, which defines a syntax for e-mail addresses that is simultaneously too strict (before the &quot;@&quot; character), too vague (after the &quot;@&quot; character), and too lax (allowing comments, whitespace characters, and quoted strings in manners unfamiliar to most users) to be of practical use here.</p>\n<p>The following JavaScript- and Perl-compatible regular expression is an implementation of the above definition.</p>\n<pre><code>/^[a-zA-Z0-9.!#$%&amp;'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\n</code></pre>\n</blockquote>\n"},{"score":26,"body":"<p>You should not use regular expressions to validate an input string to check if it's an email. It's too complicated and would not cover all the cases.</p>\n\n<p>Now since you can only cover 90% of the cases, write something like:</p>\n\n<pre><code>function isPossiblyValidEmail(txt) {\n   return txt.length &gt; 5 &amp;&amp; txt.indexOf('@')&gt;0;\n}\n</code></pre>\n\n<p>You can refine it. For instance, 'aaa@' is valid. But overall you get the gist. And don't get carried away... A simple 90% solution is better than 100% solution that does not work. </p>\n\n<p>The world needs simpler code...</p>\n"},{"score":923,"body":"<p>I've slightly modified <a href=\"https://stackoverflow.com/a/48800/4832311\">Jaymon's answer</a> for people who want really simple validation in the form of:</p>\n\n<pre><code>anystring@anystring.anystring\n</code></pre>\n\n<p>The regular expression:</p>\n\n<pre><code>/\\S+@\\S+\\.\\S+/\n</code></pre>\n\n<p>Example JavaScript function:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function validateEmail(email) \r\n    {\r\n        var re = /\\S+@\\S+\\.\\S+/;\r\n        return re.test(email);\r\n    }\r\n    \r\nconsole.log(validateEmail('anystring@anystring.anystring'));</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":12,"body":"<p>In contrast to <em>squirtle</em>, here is a complex solution, but it does a mighty fine job of validating emails properly:</p>\n\n<pre><code>function isEmail(email) { \n    return /^((([a-z]|\\d|[!#\\$%&amp;'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&amp;'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i.test(email);\n} \n</code></pre>\n\n<p>Use like so:<br><br></p>\n\n<pre><code>if (isEmail('youremail@yourdomain.com')){ console.log('This is email is valid'); }\n</code></pre>\n"},{"score":6,"body":"<p>Sectrean's solution works great, but it was failing my <a href=\"https://en.wikipedia.org/wiki/Lint_%28software%29\" rel=\"nofollow\">linter</a>. So I added some escapes:</p>\n\n<pre><code>function validateEmail(email){ \n     var re = /^(([^&lt;&gt;()[]\\\\.,;:\\s@\\\"]+(\\.[^&lt;&gt;()[]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([[0-9]{1,3}\\‌​.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; \n     return re.test(email); \n}\n</code></pre>\n"},{"score":-7,"body":"<pre><code>function validateEmail(elementValue){        \n    var emailPattern = /^[a-zA-Z0-9._]+[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z]{2,4}$/;  \n    return emailPattern.test(elementValue);   \n  }   \n</code></pre>\n\n<p>It returns true if the email address is valid. Otherwise, it will return false.</p>\n"},{"score":45,"body":"<p>Do this:</p>\n\n<pre><code>[a-zA-Z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\n</code></pre>\n\n<p>Why?  <strong>It's based on <a href=\"https://www.ietf.org/rfc/rfc2822.txt\" rel=\"noreferrer\">RFC 2822</a></strong>, which is a standard ALL email addresses MUST adhere to.  And I'm not sure why you'd bother with something \"simpler\"... you're gonna copy and paste it anyway ;)</p>\n\n<p>Often when storing email addresses in the database I make them lowercase and, in practice, regexs can usually be marked case insensitive. In those cases this is slightly shorter:</p>\n\n<pre><code>[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\n</code></pre>\n\n<p>Here's an example of it being used in JavaScript (with the case insensitive flag <code>i</code> at the end).</p>\n\n<pre><code>var emailCheck=/^[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i;\nconsole.log( emailCheck.test('some.body@domain.co.uk') );\n</code></pre>\n\n<p><strong>Note</strong>:<br>\nTechnically some emails can include quotes in the section before the <code>@</code> symbol with escape characters inside the quotes (so your email user can be obnoxious and contain stuff like <code>@</code> and <code>\"...\"</code> as long as it's written in quotes). NOBODY DOES THIS EVER! It's obsolete. But, it IS included in the true <a href=\"https://www.ietf.org/rfc/rfc2822.txt\" rel=\"noreferrer\">RFC 2822</a> standard, and omitted here.</p>\n\n<p>More info: <a href=\"http://www.regular-expressions.info/email.html\" rel=\"noreferrer\">http://www.regular-expressions.info/email.html</a></p>\n"},{"score":97,"body":"<p>In modern browsers you can build on top of @Sushil's answer with pure JavaScript and the <a href=\"http://en.wikipedia.org/wiki/Document_Object_Model\" rel=\"noreferrer\">DOM</a>:</p>\n\n<pre><code>function validateEmail(value) {\n  var input = document.createElement('input');\n\n  input.type = 'email';\n  input.required = true;\n  input.value = value;\n\n  return typeof input.checkValidity === 'function' ? input.checkValidity() : /\\S+@\\S+\\.\\S+/.test(value);\n}\n</code></pre>\n\n<p>I've put together an example in the fiddle <a href=\"http://jsfiddle.net/boldewyn/2b6d5/\" rel=\"noreferrer\">http://jsfiddle.net/boldewyn/2b6d5/</a>. Combined with feature detection and the bare-bones validation from <a href=\"https://stackoverflow.com/a/9204568/324094\">Squirtle's Answer</a>, it frees you from the regular expression massacre and does not bork on old browsers.</p>\n"},{"score":10,"body":"<pre><code>&lt;form name=\"validation\" onSubmit=\"return checkbae()\"&gt;\n    Please input a valid email address:&lt;br /&gt;\n\n    &lt;input type=\"text\" size=18 name=\"emailcheck\"&gt;\n    &lt;input type=\"submit\" value=\"Submit\"&gt;\n&lt;/form&gt;\n\n&lt;script language=\"JavaScript1.2\"&gt;\n    var testresults\n    function checkemail(){\n        var str = document.validation.emailcheck.value\n        var filter = /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i\n        if (filter.test(str))\n            testresults = true\n        else {\n            alert(\"Please input a valid email address!\")\n            testresults = false\n        }\n        return (testresults)\n    }\n&lt;/script&gt;\n\n&lt;script&gt;\n    function checkbae(){\n        if (document.layers || document.getElementById || document.all)\n            return checkemail()\n        else\n            return true\n    }\n&lt;/script&gt;\n</code></pre>\n"},{"score":11,"body":"<p>My knowledge of <a href=\"http://en.wikipedia.org/wiki/Regular_expression\" rel=\"noreferrer\">regular expressions</a> is not that good. That's why I check the general syntax with a simple regular expression first and check more specific options with other functions afterwards. This may not be not the best technical solution, but this way I'm way more flexible and faster.</p>\n\n<p>The most common errors I've come across are spaces (especially at the beginning and end) and occasionally a double dot.</p>\n\n<pre><code>function check_email(val){\n    if(!val.match(/\\S+@\\S+\\.\\S+/)){ // Jaymon's / Squirtle's solution\n        // Do something\n        return false;\n    }\n    if( val.indexOf(' ')!=-1 || val.indexOf('..')!=-1){\n        // Do something\n        return false;\n    }\n    return true;\n}\n\ncheck_email('check@thiscom'); // Returns false\ncheck_email('check@this..com'); // Returns false\ncheck_email(' check@this.com'); // Returns false\ncheck_email('check@this.com'); // Returns true\n</code></pre>\n"},{"score":70,"body":"<p>This is the correct RFC822 version.</p>\n\n<pre><code>function checkEmail(emailAddress) {\n  var sQtext = '[^\\\\x0d\\\\x22\\\\x5c\\\\x80-\\\\xff]';\n  var sDtext = '[^\\\\x0d\\\\x5b-\\\\x5d\\\\x80-\\\\xff]';\n  var sAtom = '[^\\\\x00-\\\\x20\\\\x22\\\\x28\\\\x29\\\\x2c\\\\x2e\\\\x3a-\\\\x3c\\\\x3e\\\\x40\\\\x5b-\\\\x5d\\\\x7f-\\\\xff]+';\n  var sQuotedPair = '\\\\x5c[\\\\x00-\\\\x7f]';\n  var sDomainLiteral = '\\\\x5b(' + sDtext + '|' + sQuotedPair + ')*\\\\x5d';\n  var sQuotedString = '\\\\x22(' + sQtext + '|' + sQuotedPair + ')*\\\\x22';\n  var sDomain_ref = sAtom;\n  var sSubDomain = '(' + sDomain_ref + '|' + sDomainLiteral + ')';\n  var sWord = '(' + sAtom + '|' + sQuotedString + ')';\n  var sDomain = sSubDomain + '(\\\\x2e' + sSubDomain + ')*';\n  var sLocalPart = sWord + '(\\\\x2e' + sWord + ')*';\n  var sAddrSpec = sLocalPart + '\\\\x40' + sDomain; // complete RFC822 email address spec\n  var sValidEmail = '^' + sAddrSpec + '$'; // as whole string\n\n  var reValidEmail = new RegExp(sValidEmail);\n\n  return reValidEmail.test(emailAddress);\n}\n</code></pre>\n"},{"score":24,"body":"<p>Simply check out if the entered email address is valid or not using HTML.</p>\n\n<pre><code>&lt;input type=\"email\"/&gt;\n</code></pre>\n\n<p>There isn't any need to write a function for validation.</p>\n"},{"score":62,"body":"<p>All email addresses contain an 'at' (i.e. @) symbol. Test that necessary condition:</p>\n<pre><code>email.indexOf(&quot;@&quot;) &gt; 0\n</code></pre>\n<p>Don't bother with anything more complicated. Even if you could perfectly determine whether an email is RFC-syntactically valid, that wouldn't tell you whether it belongs to the person who supplied it. That's what really matters.</p>\n<p>To test that, send a validation message.</p>\n"},{"score":3,"body":"<p>If you're using Closure you can use the built-in <code>goog.format.EmailAddress</code> type:</p>\n\n<blockquote>\n  <p><a href=\"http://web.archive.org/web/20140130083649/http://docs.closure-library.googlecode.com/git/class_goog_format_EmailAddress.html\" rel=\"nofollow\">http://docs.closure-library.googlecode.com/git/class_goog_format_EmailAddress.html</a></p>\n</blockquote>\n\n<p>For example:</p>\n\n<pre><code>goog.format.EmailAddress.isValidAddrSpec(\"blah@blah.com\")\n</code></pre>\n\n<p>Note that by reading the source (linked above) you can see the comments state that IDN are not supported and that it only aims to cover <em>most</em> addresses:</p>\n\n<pre><code>// This is a fairly naive implementation, but it covers 99% of use cases.\n// For more details, see http://en.wikipedia.org/wiki/Email_address#Syntax\n// TODO(mariakhomenko): we should also be handling i18n domain names as per\n// http://en.wikipedia.org/wiki/Internationalized_domain_name\n</code></pre>\n"},{"score":18,"body":"<p>This is how <a href=\"https://github.com/chriso/validator.js\" rel=\"noreferrer\">node-validator</a> does it:</p>\n\n<pre><code>/^(?:[\\w\\!\\#\\$\\%\\&amp;\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+\\.)*[\\w\\!\\#\\$\\%\\&amp;\\'\\*\\+\\-\\/\\=\\?\\^\\`\\{\\|\\}\\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!\\.)){0,61}[a-zA-Z0-9]?\\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\\[(?:(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\.){3}(?:[01]?\\d{1,2}|2[0-4]\\d|25[0-5])\\]))$/\n</code></pre>\n"},{"score":-6,"body":"<p><a href=\"http://en.wikipedia.org/wiki/W3Schools\" rel=\"nofollow\">W3Schools</a> gives a good simple and efficient script to validate an email:  </p>\n\n<pre><code>function validateEmail(email) {\n    var atpos=email.indexOf(\"@\");\n    var dotpos=email.lastIndexOf(\".\");\n    if (atpos &lt; 1 || dotpos &lt; atpos+2 || dotpos+2 &gt;= email.length) {\n        alert(\"Not a valid e-mail address\");\n        return false;\n    }\n    return true;\n}\n</code></pre>\n\n<p>Note that you will have to remove spaces if there are any though, with something like this:</p>\n\n<pre><code>.replace(/ /g,'')\n</code></pre>\n\n<p>Source: <em><a href=\"http://www.w3schools.com/js/js_form_validation.asp\" rel=\"nofollow\">JavaScript Form Validation</a></em></p>\n"},{"score":15,"body":"<p>Use this code inside your validator function:</p>\n\n<pre><code>var emailID = document.forms[\"formName\"][\"form element id\"].value;\natpos = emailID.indexOf(\"@\");\ndotpos = emailID.lastIndexOf(\".\");\nif (atpos &lt; 1 || ( dotpos - atpos &lt; 2 ))\n{\n    alert(\"Please enter correct email ID\")\n    return false;\n}\n</code></pre>\n\n<p>Else you can use <a href=\"http://en.wikipedia.org/wiki/JQuery\" rel=\"noreferrer\">jQuery</a>. Inside rules define:</p>\n\n<pre><code>eMailId: {\n    required: true,\n    email: true\n}\n</code></pre>\n"},{"score":8,"body":"<p>The regular expression provided by Microsoft within <a href=\"http://en.wikipedia.org/wiki/ASP.NET_MVC_Framework\" rel=\"noreferrer\">ASP.NET MVC</a> is</p>\n\n<pre><code>/^[\\w-]+(\\.[\\w-]+)*@([a-z0-9-]+(\\.[a-z0-9-]+)*?\\.[a-z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$/\n</code></pre>\n\n<p>Which I post here in case it's flawed - though it's always been perfect for my needs.</p>\n"},{"score":3,"body":"<pre><code>&lt;pre&gt;\n**The personal_info part contains the following ASCII characters.\n1.Uppercase (A-Z) and lowercase (a-z) English letters.\n2.Digits (0-9).\n3.Characters ! # $ % &amp; ' * + - / = ? ^ _ ` { | } ~\n4.Character . ( period, dot or fullstop) provided that it is not the first or last character and it will not come one after the other.**\n&lt;/pre&gt;\n*Example of valid email id*\n&lt;pre&gt;\nyoursite@ourearth.com\nmy.ownsite@ourearth.org\nmysite@you.me.net\nxxxx@gmail.com\nxxxxxx@yahoo.com\n&lt;/pre&gt;\n&lt;pre&gt;\nxxxx.ourearth.com [@ is not present] \nxxxx@.com.my [ tld (Top Level domain) can not start with dot \".\" ]\n@you.me.net [ No character before @ ]\nxxxx123@gmail.b [ \".b\" is not a valid tld ]\nxxxx@.org.org [ tld can not start with dot \".\" ]\n.xxxx@mysite.org [ an email should not be start with \".\" ]\nxxxxx()*@gmail.com [ here the regular expression only allows character, digit, underscore and dash ]\nxxxx..1234@yahoo.com [double dots are not allowed\n&lt;/pre&gt;\n**javascript mail code**\n\n    function ValidateEmail(inputText)\n    {\n    var mailformat = /^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/;\n    if(inputText.value.match(mailformat))\n    {\n    document.form1.text1.focus();\n    return true;\n    }\n    else\n    {\n    alert(\"You have entered an invalid email address!\");\n    document.form1.text1.focus();\n    return false;\n    }\n    }\n</code></pre>\n"},{"score":-4,"body":"<p>Very simple in <code>JavaScript</code>. follow this code.</p>\n\n<pre><code>function validate(){\n    var email = document.getElementById('Email');\n    var filter = /^([a-zA-Z0-9_\\.\\-])+\\@(([a-zA-Z0-9\\-])+\\.)+([a-zA-Z0-9]{2,4})+$/;\n\n    if (!filter.test(email.value))\n    {\n        alert('Please Enter the valid email address');\n        email.focus;\n        return false;\n    }\n    else\n{\n        return true;\n    }\n</code></pre>\n\n<p><code>HTML</code> code for this:</p>\n\n<pre><code>form name=\"form\"\n     enctype=\"multipart/form-data\"\n     name=\"form\"\n     action=\"register.php\"\n     method=\"POST\" onsubmit=\"return validate();\" &gt;\n    &lt;input type=\"text\" placeholder=\"Enter ur Email Id\" id=\"Email\" name=\"Email\" /&gt;\n    &lt;input type=\"submit\" id=\"submit\" value=\"save\" name=\"Like\" class=\"button\" /&gt;\n&lt;/form&gt;\n</code></pre>\n"},{"score":-1,"body":"<p>One of my coworker shared this regex with me. I like it a lot.</p>\n\n<pre><code>function isValidEmailAddress (email) {\n    var validEmail = false;\n    if (email) {\n        email = email.trim().toLowerCase();\n        var pattern = /^[\\w-']+(\\.[\\w-']+)*@([a-zA-Z0-9]+[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*?\\.[a-zA-Z]{2,6}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{4})?$/;\n        validEmail = pattern.exec(email);\n    }\n\n    return validEmail;\n}\n\nif (typeof String.prototype.trim !== 'function') {\n    String.prototype.trim = function() {\n        return this.replace(/^\\s+|\\s+$/g, '');\n    };\n}\n</code></pre>\n"},{"score":-5,"body":"<pre><code>function validatecontactEmail(email) { \n\n if (/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(email))  \n  {  \n    return (true)  \n  }  \n\n    return (false)  \n\n}\n</code></pre>\n"},{"score":5,"body":"<p>Here is a function I use for front end email validation. (The Regular Expression came from parsley.js)</p>\n\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;Our Company&lt;/title&gt;\n    &lt;style&gt;\n        .form-style {\n            color: #ccc;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;h1&gt;Email Validation Form Example&lt;/h1&gt;\n    &lt;input type=\"text\" name=\"email\" id=\"emailInput\" class=\"form-style\"&gt;\n    &lt;script&gt;\n        function validateEmail(emailAddress) {\n            var regularExpression = /^((([a-z]|\\d|[!#\\$%&amp;'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&amp;'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))){2,6}$/i;\n             return regularExpression.test(emailAddress);\n        }\n\n        function showEmailValidationState(event) {\n            if (validateEmail(event.target.value)) {\n                document.getElementById(\"emailInput\").style.color = 'black';\n            }\n        }\n    document.getElementById(\"emailInput\").addEventListener(\"keyup\", showEmailValidationState);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n"},{"score":1,"body":"<p>If you are using AngularJS, just add <code>type=\"email\"</code> to the input element: </p>\n\n<blockquote>\n  <p><a href=\"https://docs.angularjs.org/api/ng/input/input%5Bemail%5D\" rel=\"nofollow\">https://docs.angularjs.org/api/ng/input/input%5Bemail%5D</a></p>\n</blockquote>\n\n<p>In case there is no input element, it can be created dynamically:</p>\n\n<pre><code>var isEmail = $compile('&lt;input ng-model=\"m\" type=\"email\"&gt;')($rootScope.$new()).\n    controller('ngModel').$validators[\"email\"];\n\nif (isEmail('email@gmail.com')) {\n  console.log('valid');\n} \n</code></pre>\n"},{"score":-6,"body":"<p>Validation regex for email:</p>\n\n<pre><code>var rex_email = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n\nif(email==\"\") {\n    window.plugins.toast.showShortBottom( \"Please enter the details. \", function(a) {\n        console.log('toast success: ' + a);\n    }, function(b) { });\n} else if(!rex_email.test(email)) {\n    window.plugins.toast.showShortBottom( \"Please enter the valid email id. \", function(a) {\n        console.log('toast success: ' + a);\n    }, function(b) { });\n}\n</code></pre>\n"},{"score":1,"body":"<p>I know its not regex but any way...</p>\n\n<p>This is example with node and npm package <a href=\"https://www.npmjs.com/package/email-existence\" rel=\"nofollow\">email-existence</a> this is ultimate checking if email exist and if its in the right form :)</p>\n\n<p>This will ping the email if its responding if it got no response it will return false or else true.</p>\n\n<pre><code>function doesEmailExist(email) {\n    var emailExistence = require('email-existence');\n    return emailExistence.check(email,function (err,status) {\n            if (status) {\n                return status;\n            }\n            else {\n                throw new Error('Email does not exist');\n            }\n        });\n}\n</code></pre>\n"},{"score":4,"body":"<p><strong><em>Following Regex validations:</em></strong></p>\n\n<ul>\n<li>No spacial characters before @ </li>\n<li>(-) and (.) should not be together\nafter @ No special characters after @ 2 characters must before @\nEmail length should be less 128 characters</li>\n</ul>\n\n\n\n<pre><code>function validateEmail(email) {\nvar chrbeforAt = email.substr(0, email.indexOf('@'));\nif (!($.trim(email).length &gt; 127)) {\n    if (chrbeforAt.length &gt;= 2) {\n        var re = /^(([^&lt;&gt;()[\\]{}'^?\\\\.,!|//#%*-+=&amp;;:\\s@\\\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;\n        //var re = /[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;\n        return re.test(email);\n    } else {\n        return false;\n    }\n} else {\n    return false;\n}\n}\n</code></pre>\n"},{"score":1,"body":"<p><strong><em>Following Regex validations:</em></strong></p>\n\n<ul>\n<li>No spacial characters before @ </li>\n<li>(-) and (.) should not be together after @ </li>\n<li>No special characters after @ 2 characters must before @</li>\n<li><p>Email length should be less 128 characters</p>\n\n<pre><code>function validateEmail(email) {\n    var chrbeforAt = email.substr(0, email.indexOf('@'));\n    if (!($.trim(email).length &gt; 127)) {\n        if (chrbeforAt.length &gt;= 2) {\n            var re = /^(([^&lt;&gt;()[\\]{}'^?\\\\.,!|//#%*-+=&amp;;:\\s@\\\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;\n            return re.test(email);\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n}\n</code></pre></li>\n</ul>\n"},{"score":-1,"body":"<pre><code>\\b[a-z][\\w\\d_\\.]+@\\w+\\.[a-z]{2}[a-z]?\\.?[a-z]{,2}\\s\n</code></pre>\n\n<p>It allows:</p>\n\n<pre><code>abcxyz123@qwert.com    \nabc123xyz@asdf.co.in   \nabc1_xyz1@gmail1.com   \nabc.xyz@gmail.com.in\n</code></pre>\n"},{"score":3,"body":"<p>the best one :D (RFC-friendly &amp; no error \"too complex\") :</p>\n\n<pre><code>function    isMail(mail)\n{\n    pattuser = /^([A-Z0-9_%+\\-!#$&amp;'*\\/=?^`{|}~]+\\.?)*[A-Z0-9_%+\\-!#$&amp;'*\\/=?^`{|}~]+$/i;\n    pattdomain = /^([A-Z0-9-]+\\.?)*[A-Z0-9-]+(\\.[A-Z]{2,9})+$/i;\n\n    tab = mail.split(\"@\");\n    if (tab.length != 2)\n        return false;\n    return (pattuser.test(tab[0]) &amp;&amp; pattdomain.test(tab[1]));\n}\n</code></pre>\n"},{"score":1,"body":"<p>If you want to use Jquery and want to have modern approach then use JQuery input mask with validation. </p>\n\n<p><a href=\"http://bseth99.github.io/projects/jquery-ui/5-jquery-masks.html\" rel=\"nofollow\">http://bseth99.github.io/projects/jquery-ui/5-jquery-masks.html</a> </p>\n\n<p>Demo on how simple jquery input mask is here: <a href=\"http://codepen.io/anon/pen/gpRyBp\" rel=\"nofollow\">http://codepen.io/anon/pen/gpRyBp</a></p>\n\n<p><strong>Example of simple input mask for date forexample NOT full validation</strong></p>\n\n<pre><code> &lt;input id=\"date\" type=\"text\" placeholder=\"YYYY-MM-DD\"/&gt;\n</code></pre>\n\n<p>and the script:</p>\n\n<pre><code> $(\"#date\").mask(\"9999-99-99\",{placeholder:\"YYYY-MM-DD\"});\n</code></pre>\n"},{"score":5,"body":"<p>The best practice is to either use HTML5 built-in email tag.</p>\n\n<pre><code>&lt;input type=\"email\" name=\"email\"&gt;\n</code></pre>\n\n<p>or the common email syntax as recognizing @ and . from the string is given below. </p>\n\n<pre><code>^[a-zA-Z0-9_\\-.]+@[a-zA-Z0-9\\-]+\\.[a-zA-Z0-9\\-.]+$\n</code></pre>\n\n<blockquote>\n  <p>Note that this would still produce <strong>invalid email</strong> that will still match\n  the regex, its almost impossible to catch them all but this will\n  improve the situation a little.</p>\n</blockquote>\n"},{"score":146,"body":"<p>I have found this to be the best solution:</p>\n\n<pre><code>/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n</code></pre>\n\n<p>It allows the following formats:</p>\n\n<pre>\n1.  prettyandsimple@example.com\n2.  very.common@example.com\n3.  disposable.style.email.with+symbol@example.com\n4.  other.email-with-dash@example.com\n9.  #!$%&'*+-/=?^_`{}|~@example.org\n6.  \"()[]:,;@\\\\\\\"!#$%&'*+-/=?^_`{}| ~.a\"@example.org\n7.  \" \"@example.org (space between the quotes)\n8.  üñîçøðé@example.com (Unicode characters in local part)\n9.  üñîçøðé@üñîçøðé.com (Unicode characters in domain part)\n10. Pelé@example.com (Latin)\n11. δοκιμή@παράδειγμα.δοκιμή (Greek)\n12. 我買@屋企.香港 (Chinese)\n13. 甲斐@黒川.日本 (Japanese)\n14. чебурашка@ящик-с-апельсинами.рф (Cyrillic)\n</pre>\n\n<p>It's clearly versatile and allows the all-important international characters, while still enforcing the basic anything@anything.anything format. It will block spaces which are technically allowed by RFC, but they are so rare that I'm happy to do this.</p>\n"},{"score":1,"body":"<p>This regexp prevents duplicate domain names like abc@abc.com.com.com.com, it will allow only domain two time like abc@abc.co.in. It also does not allow statring from number like 123abc@abc.com  </p>\n\n<pre><code>regexp: /^([a-zA-Z])+([a-zA-Z0-9_.+-])+\\@(([a-zA-Z])+\\.+?(com|co|in|org|net|edu|info|gov|vekomy))\\.?(com|co|in|org|net|edu|info|gov)?$/,  \n</code></pre>\n\n<p>All The Best !!!!!</p>\n"},{"score":-4,"body":"<p>Simple regex for email-Id</p>\n\n<pre><code> String EMAIL_PATTERN =\"^(([^&lt;&gt;()\\[\\]\\.,;:\\s@\\\"]+(\\.[^&lt;&gt;()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^&lt;&gt;()[\\]\\.,;:\\s@\\\"]+\\.)+[^&lt;&gt;()[\\]\\.,;:\\s@\\\"]{2,})$\";\n</code></pre>\n"},{"score":4,"body":"<p>Use the regular expression:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code> /^[a-z][a-zA-Z0-9_.]*(\\.[a-zA-Z][a-zA-Z0-9_.]*)?@[a-z][a-zA-Z-0-9]*\\.[a-z]+(\\.[a-z]+)?$/\n</code></pre>\n\n<p>Example:</p>\n\n<pre><code>function validateEmail(email) {\n    var re = /^[a-z][a-zA-Z0-9_.]*(\\.[a-zA-Z][a-zA-Z0-9_.]*)?@[a-z][a-zA-Z-0-9]*\\.[a-z]+(\\.[a-z]+)?$/;\n    return re.test(email);\n}\n</code></pre>\n\n<p>It should allow only  @ ,  . , _</p>\n"},{"score":6,"body":"<p>I've mixed @mevius and @Boldewyn Code to Create this ultimate code for email verification using JavaScript.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function ValidateEmail(email){\r\n \r\n  var re = /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n \r\n  var input = document.createElement('input');\r\n \r\n  input.type = 'email';\r\n  input.value = email;\r\n \r\n  return typeof input.checkValidity == 'function' ? input.checkValidity() : re.test(email);\r\n \r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>I have shared this code on my blog <a href=\"http://mycodingtricks.com/snippets/javascript/javascript-regex-email-validation/\" rel=\"noreferrer\">here</a>.</p>\n"},{"score":42,"body":"<p>I'm really looking forward to solve this problem.\nSo I modified email validation regular expression above </p>\n\n<ul>\n<li><p>Original<br>\n<code>/^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/</code></p></li>\n<li><p>Modified<br>\n<code>/^(([^&lt;&gt;()\\[\\]\\.,;:\\s@\\\"]+(\\.[^&lt;&gt;()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^&lt;&gt;()\\.,;\\s@\\\"]+\\.{0,1})+[^&lt;&gt;()\\.,;:\\s@\\\"]{2,})$/</code></p></li>\n</ul>\n\n<p>to pass the examples in <a href=\"https://en.wikipedia.org/wiki/Email_address#cite_note-20/syntax\">Wikipedia Email Address</a>.</p>\n\n<p>And you can see the result in <a href=\"http://regexr.com/3dnsr\">here</a>.</p>\n\n<p><a href=\"https://i.stack.imgur.com/m2YBr.png\"><img src=\"https://i.stack.imgur.com/m2YBr.png\" alt=\"enter image description here\"></a></p>\n"},{"score":3,"body":"<p>If you are using ng-pattern and material this does the job. </p>\n\n<pre><code>vm.validateEmail = '([a-zA-Z0-9_.]{1,})((@[a-zA-Z]{2,})[\\\\\\.]([a-zA-Z]{2}|[a-zA-Z]{3}))';\n</code></pre>\n"},{"score":1,"body":"<p>Whoever is using @pvl solution and wants it to pass <a href=\"http://eslint.org/docs/rules/prefer-template\" rel=\"nofollow noreferrer\">ESLint Prefer-template</a> then here's a version where I used template literals instead of string concatenation.</p>\n\n<pre><code>validateEmail(email) {\n    let sQtext = '[^\\\\x0d\\\\x22\\\\x5c\\\\x80-\\\\xff]';\n    let sDtext = '[^\\\\x0d\\\\x5b-\\\\x5d\\\\x80-\\\\xff]';\n    let sAtom = '[^\\\\x00-\\\\x20\\\\x22\\\\x28\\\\x29\\\\x2c\\\\x2e\\\\x3a-\\\\x3c\\\\x3e\\\\x40\\\\x5b-\\\\x5d\\\\x7f-\\\\xff]+';\n    let sQuotedPair = '\\\\x5c[\\\\x00-\\\\x7f]';\n    let sDomainLiteral = `\\\\x5b(${sDtext}|${sQuotedPair})*\\\\x5d`;\n    let sQuotedString = `\\\\x22(${sQtext}|${sQuotedPair})*\\\\x22`;\n    let sDomainRef = sAtom;\n    let sSubDomain = `(${sDomainRef}|${sDomainLiteral})`;\n    let sWord = `(${sAtom}|${sQuotedString})`;\n    let sDomain = `${sSubDomain}(\\\\x2e${sSubDomain})*`;\n    let sLocalPart = `${sWord}(\\\\x2e${sWord})*`;\n    let sAddrSpec = `${sLocalPart}\\\\x40${sDomain}`; // complete RFC822 email address spec\n    let sValidEmail = `^${sAddrSpec}$`; // as whole string\n\n    let reValidEmail = new RegExp(sValidEmail);\n\n    return reValidEmail.test(email);\n}\n</code></pre>\n"},{"score":13,"body":"<p>Regex for validating email address</p>\n\n<pre><code>[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])+\n</code></pre>\n"},{"score":14,"body":"<h2>A solution that does not check the existence of the TLD is incomplete.</h2>\n\n<p>Almost all answers to this questions suggest using Regex to validate emails addresses. I think Regex is only good for a rudimentary validation. It seems that the checking validation of email addresses is actually two separate problems:</p>\n\n<p><strong>1- Validation of email format:</strong> Making sure if the email complies with the format and pattern of emails in RFC 5322 and if the TLD actually exists. A list of all valid TLDs can be found <a href=\"http://data.iana.org/TLD/tlds-alpha-by-domain.txt\" rel=\"nofollow noreferrer\">here</a>.</p>\n\n<p>For example, although the address <code>example@example.ccc</code> will pass the regex, it is not a valid email, because <code>ccc</code> is not a top-level domain by IANA.</p>\n\n<p><strong>2- Making sure the email actually exists:</strong> For doing this, <strong>the only option</strong> is <a href=\"https://davidcel.is/posts/stop-validating-email-addresses-with-regex/#just-send-them-an-email-already\" rel=\"nofollow noreferrer\">to send the users an email</a>.</p>\n"},{"score":10,"body":"<p>I was looking for a Regex in JS that passes all Email Address test cases:</p>\n\n<ul>\n<li><p><code>email@example.com</code> Valid email</p></li>\n<li><p><code>firstname.lastname@example.com</code>  Email contains dot in the address field</p></li>\n<li><p><code>email@subdomain.example.com</code> Email contains dot with subdomain</p></li>\n<li><p><code>firstname+lastname@example.com</code>   Plus sign is considered valid character</p></li>\n<li><p><code>email@192.0.2.123</code> Domain is valid IP address</p></li>\n<li><p><code>email@[192.0.2.123]</code> Square bracket around IP address is considered valid</p></li>\n<li><p><code>“email”@example.com</code> Quotes around email is considered valid</p></li>\n<li><p><code>1234567890@example.com</code> Digits in address are valid</p></li>\n<li><p><code>email@domain-one.example</code> Dash in domain name is valid</p></li>\n<li><p><code>_______@example.com</code> Underscore in the address field is valid</p></li>\n<li><p><code>email@example.name</code> <code>.name</code> is valid Top Level Domain name</p></li>\n<li><p><code>email@example.co.jp</code> Dot in Top Level Domain name also considered valid (using <code>co.jp</code> as example here)</p></li>\n<li><p><code>firstname-lastname@example.com</code> Dash in address field is valid</p></li>\n</ul>\n\n<p>Here we go :</p>\n\n<p><a href=\"http://regexr.com/3f07j\" rel=\"noreferrer\">http://regexr.com/3f07j</a></p>\n\n<p>OR regex:</p>\n\n<pre><code>Regex = /(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@[*[a-zA-Z0-9-]+.[a-zA-Z0-9-.]+]*/\n</code></pre>\n"},{"score":2,"body":"<p>In nodeJS you can also use validator node module and simply use like that </p>\n\n<p>Install the library with npm install validator</p>\n\n<pre><code>var validator = require('validator');\n\nvalidator.isEmail('foo@bar.com'); //=&gt; true \n</code></pre>\n"},{"score":-1,"body":"<p>If you define your regular expression as a string then all backslashes need to be escaped, so instead of '\\w' you should have '\\w'.</p>\n\n<p>Alternatively, define it as a regular expression:</p>\n\n<pre><code>var pattern = /^\\w+@[a-zA-Z_]+?\\.[a-zA-Z]{2,3}$/; \n</code></pre>\n"},{"score":1,"body":"<p>There are some complex RegEx written here, that also works.</p>\n\n<p>I tested this one and it works too:</p>\n\n<pre><code>[a-zA-Z0-9._]+[@]+[a-zA-Z0-9]+[.]+[a-zA-Z]{2,6}\n</code></pre>\n\n<p>Please test this here : <a href=\"http://www.regextester.com/?fam=97334\" rel=\"nofollow noreferrer\">http://www.regextester.com/?fam=97334</a></p>\n\n<p>Hope this helps.</p>\n"},{"score":0,"body":"<p>I'd like to add a short note about non-ASCII characters. Rnevius's (and co.) solution is brilliant, but it allows to add Cyrillic, Japanese, Emoticons and other unicode symbols which may be restricted by some servers.</p>\n\n<p>The code below will print <code>true</code> though it contains UTF-8 character <code>Ё</code>.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>console.log (/^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/.test ('Ё@example.org'))</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>In my case all non-ASCII symbols are prohibited so I have modified the original expression to exclude all characters above U+007F:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>/^(([^\\u0080-\\uffff&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^\\u0080-\\uffff&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Maybe this will help someone to prevent undesired behaviour.</p>\n"},{"score":2,"body":"<p>How about creating a function which will test any string against emails' pattern using regular expression in JavaScript, as we know email addresses can be quite different in different regions, like in UK and Australia it usually ends up with <code>.co.uk</code> or <code>.com.au</code>, so I tried to cover those as well, also check if the string passed to the function, something like this:</p>\n\n<pre><code>var isEmail = function(str) {\n  return typeof str==='string' &amp;&amp; /^[\\w+\\d+._]+\\@[\\w+\\d+_+]+\\.[\\w+\\d+._]{2,8}$/.test(str);\n}\n</code></pre>\n\n<p>and check if it's email like below:</p>\n\n<pre><code>isEmail('alex@example.com'); //true\nisEmail('alireza@test.co.uk'); //true\nisEmail('peter.example@yahoo.com.au'); //true\nisEmail('alex@example.com'); //true\nisEmail('peter_123@news.com'); //true\nisEmail('hello7___@ca.com.pt'); //true\nisEmail('example@example.co'); //true\nisEmail('hallo@example.coassjj#sswzazaaaa'); //false\nisEmail('hallo2ww22@example....caaaao'); //false\n</code></pre>\n"},{"score":9,"body":"<p><strong>Wikipedia standard mail syntax :</strong></p>\n\n<p><a href=\"https://en.wikipedia.org/wiki/Email_address#Examples\" rel=\"noreferrer\">https://en.wikipedia.org/wiki/Email_address#Examples</a>\n<a href=\"https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte\" rel=\"noreferrer\">https://fr.wikipedia.org/wiki/Adresse_%C3%A9lectronique#Syntaxe_exacte</a></p>\n\n<pre><code>function validMail(mail)\n{\n    return /^(([^&lt;&gt;()\\[\\]\\.,;:\\s@\\\"]+(\\.[^&lt;&gt;()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^&lt;&gt;()\\.,;\\s@\\\"]+\\.{0,1})+([^&lt;&gt;()\\.,;:\\s@\\\"]{2,}|[\\d\\.]+))$/.test(mail);\n}\n\n// VALID MAILS\n\nvalidMail('Abc@example.com') // Return true\nvalidMail('Abc@example.com.') // Return true\nvalidMail('Abc@10.42.0.1') // Return true\nvalidMail('user@localserver') // Return true\nvalidMail('Abc.123@example.com') // Return true\nvalidMail('user+mailbox/department=shipping@example.com') // Return true\nvalidMail('\"very.(),:;&lt;&gt;[]\\\".VERY.\\\"very@\\\\ \\\"very\\\".unusual\"@strange.example.com') // Return true\nvalidMail('!#$%&amp;\\'*+-/=?^_`.{|}~@example.com') // Return true\nvalidMail('\"()&lt;&gt;[]:,;@\\\\\\\"!#$%&amp;\\'-/=?^_`{}| ~.a\"@example.org') // Return true\nvalidMail('\"Abc@def\"@example.com') // Return true\nvalidMail('\"Fred Bloggs\"@example.com') // Return true\nvalidMail('\"Joe.\\\\Blow\"@example.com') // Return true\nvalidMail('Loïc.Accentué@voilà.fr') // Return true\nvalidMail('\" \"@example.org') // Return true\nvalidMail('user@[IPv6:2001:DB8::1]') // Return true\n\n// INVALID MAILS\n\nvalidMail('Abc.example.com') // Return false\nvalidMail('A@b@c@example.com') // Return false\nvalidMail('a\"b(c)d,e:f;g&lt;h&gt;i[j\\k]l@example.com') // Return false\nvalidMail('just\"not\"right@example.com') // Return false\nvalidMail('this is\"not\\allowed@example.com') // Return false\nvalidMail('this\\ still\\\"not\\\\allowed@example.com') // Return false\nvalidMail('john..doe@example.com') // Return false\nvalidMail('john.doe@example..com') // Return false\n</code></pre>\n\n<p><strong>Show this test : <a href=\"https://regex101.com/r/LHJ9gU/1\" rel=\"noreferrer\">https://regex101.com/r/LHJ9gU/1</a></strong></p>\n"},{"score":2,"body":"<p>ES6 sample</p>\n\n<pre><code>const validateEmail=(email)=&gt; /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/.test(email);\n</code></pre>\n"},{"score":0,"body":"<p>Now ReactNative Version 0.46 Use Below code for email Validation.</p>\n\n<pre><code> validateEmail = (email) =&gt; {\n     var re = /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n     if (re.test(email)) {\n     } else {\n       alert('email: ' + \"Please enter valid emailID.\")\n     }\n }\n</code></pre>\n"},{"score":5,"body":"<p>You can also try</p>\n\n<pre><code>var string = \"hmharsh3@gmail.com\"\nvar exp = /(\\w(=?@)\\w+\\.{1}[a-zA-Z]{2,})/i\nalert(exp.test(string))\n</code></pre>\n"},{"score":14,"body":"<p>Regex update 2018! try this</p>\n\n<pre><code>let val = 'email@domain.com';\nif(/^[a-z0-9][a-z0-9-_\\.]+@([a-z]|[a-z0-9]?[a-z0-9-]+[a-z0-9])\\.[a-z0-9]{2,10}(?:\\.[a-z]{2,10})?$/.test(val)) {\n   console.log('passed');\n}\n</code></pre>\n\n<p>typscript version complete</p>\n\n<pre><code>//\nexport const emailValid = (val:string):boolean =&gt; /^[a-z0-9][a-z0-9-_\\.]+@([a-z]|[a-z0-9]?[a-z0-9-]+[a-z0-9])\\.[a-z0-9]{2,10}(?:\\.[a-z]{2,10})?$/.test(val);\n</code></pre>\n\n<p>more info <a href=\"https://git.io/vhEfc\" rel=\"noreferrer\">https://git.io/vhEfc</a></p>\n"},{"score":1,"body":"<pre><code> &lt;input type=\"email\" class=\"form-control\" required=\"required\" placeholder=\"Email Address\" name=\"Email\" id=\"Email\" autocomplete=\"Email\"&gt;\n &lt;button class=\"btn-1 shadow-0 full-width\" type=\"button\" id=\"register\"&gt;Register account&lt;/button&gt;\n</code></pre>\n\n<p>   </p>\n\n<pre><code> $(\"#register\").click(function(){       \n    var rea = /^[a-zA-Z0-9.!#$%&amp;'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n    var Email = $(\"#Email\").val();\n    var x = rea.test(Email);\n    if (!x) {\n        alert('Type Your valid Email');\n        return false;\n    }           \n &lt;/script&gt;\n</code></pre>\n"},{"score":2,"body":"<p>Here's a simple  regex that would just check for the basic format of an email e.g., <code>X@Y.C</code>:</p>\n\n<p><code>\\S+@\\S+\\.\\S+</code></p>\n"},{"score":2,"body":"<p>This question is more dificult to answer than seems at first sight.</p>\n\n<p>There were loads of people around the world looking for \"the regex to rule them all\" but the truth is that there are tones of email providers.</p>\n\n<p>What's the problem? Well, \"a_z%@gmail.com cannot exists but it may exists an address like that through another provider \"a__z@provider.com.</p>\n\n<p>Why? \nAccording to the RFC:\n<a href=\"https://en.wikipedia.org/wiki/Email_address#RFC_specification\" rel=\"nofollow noreferrer\">https://en.wikipedia.org/wiki/Email_address#RFC_specification</a>.</p>\n\n<p>I'll take an excerpt to facilitate the lecture:</p>\n\n<pre><code>The local-part of the email address may use any of these ASCII characters:\n\n- uppercase and lowercase Latin letters A to Z and a to z;\n- digits 0 to 9;\n- special characters !#$%&amp;'*+-/=?^_`{|}~;\n- dot ., provided that it is not the first or last character unless quoted, and provided also that it does not appear consecutively unless quoted (e.g. John..Doe@example.com is not allowed but \"John..Doe\"@example.com is allowed);[6]\nNote that some mail servers wildcard local parts, typically the characters following a plus and less often the characters following a minus, so fred+bah@domain and fred+foo@domain might end up in the same inbox as fred+@domain or even as fred@domain. This can be useful for tagging emails for sorting, see below, and for spam control. Braces { and } are also used in that fashion, although less often.\n- space and \"(),:;&lt;&gt;@[\\] characters are allowed with restrictions (they are only allowed inside a quoted string, as described in the paragraph below, and in addition, a backslash or double-quote must be preceded by a backslash);\n- comments are allowed with parentheses at either end of the local-part; e.g. john.smith(comment)@example.com and (comment)john.smith@example.com are both equivalent to john.smith@example.com.\n</code></pre>\n\n<p>So, i can own an email address like that:</p>\n\n<pre><code>A__z/J0hn.sm{it!}h_comment@example.com.co\n</code></pre>\n\n<p>If you try this address i bet it will fail in all or the major part of regex posted all across the net. But remember this address follows the RFC rules so it's fair valid.</p>\n\n<p>Imagine my frustration at not being able to register anywhere checked with those regex!!</p>\n\n<p><strong>The only one who really can validate an email address is the provider of the email address.</strong></p>\n\n<p>How to deal with, so?</p>\n\n<p>It doesn't matter if a user adds a non-valid e-mail in almost all cases. You can rely on HTML 5 input type=\"email\" that is running <strong>near</strong> to RFC, little chance to fail.\nHTML5 input type=\"email\" info: <a href=\"https://www.w3.org/TR/2012/WD-html-markup-20121011/input.email.html\" rel=\"nofollow noreferrer\">https://www.w3.org/TR/2012/WD-html-markup-20121011/input.email.html</a></p>\n\n<p>For example, this is an RFC valid email:</p>\n\n<pre><code>\"very.(),:;&lt;&gt;[]\\\".VERY.\\\"very@\\\\ \\\"very\\\".unusual\"@strange.example.com\n</code></pre>\n\n<p>But the html5 validation will tell you that the text before @ must not contain \" or () chars for example, which is actually incorrect.</p>\n\n<p>Anyway, you should do this by accepting the email address and sending an email message to that email address, with a code/link the user must visit to confirm validity.</p>\n\n<p>A good practice while doing this is the \"enter your e-mail again\" input to avoid user typing errors. If this is not enough for you, add a pre-submit modal-window with a title \"is this your current e-mail?\", then the mail entered by the user inside an h2 tag, you know, to show clearly which e-mail they entered, then a \"yes, submit\" button.</p>\n"},{"score":8,"body":"<p><strong>How to write Particular Regular Expression in android or java.</strong></p>\n\n<p>1) <code>USER_NAME = \"^[A-Za-z0-9_-]{min number of character,max number of character}$\";</code></p>\n\n<p>2) <code>TELEPHONE = \"(^\\\\+)?[0-9()-]*\";</code></p>\n\n<p>3) <code>TELEPHONE_OPTIONAL = \"^($|(^\\\\+)?[0-9()-]*)$\";</code></p>\n\n<p>4) <code>EMAIL = \"[a-zA-Z0-9_\\\\.\\\\+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-\\\\.]+\";</code></p>\n\n<p>5) <code>EMAIL_OPTIONAL = \"^($|[a-zA-Z0-9_\\\\.\\\\+-]+@[a-zA-Z0-9-]+\\\\.[a-zA-Z0-9-\\\\.]+)$\";</code></p>\n\n<p>6) <code>WEB_URL = \"^($|(http:\\\\/\\\\/|https:\\\\/\\\\/)?(www.)?([a-zA-Z0-9]+).[a-zA-Z0-9]*.[a-z]{3}.?([a-z]+)?)$\";</code></p>\n\n<p>7) <code>WEB_URL_YOUTUBE_BE = \"https?\\\\:\\\\/\\\\/(www\\\\.)?youtu(\\\\.)?be(\\\\.com)?\\\\/.*(\\\\?v=|\\\\/v\\\\/)?[a-zA-Z0-9_\\\\-]+\";</code></p>\n\n<p>8) <code>POSTAL_ADDRESS = \"[a-zA-Z\\\\d\\\\s\\\\-\\\\,\\\\#\\\\.\\\\+]+\";</code></p>\n\n<p>9) <code>FIELD_NOT_EMPTY = \"[^\\\\s]*\";</code></p>\n\n<p>10) <code>PINCODE = \"^([0-9]{6})?$\";</code></p>\n\n<p>11) <code>IFSC_CODE = \"^[^\\\\s]{4}\\\\d{7}$\";</code></p>\n\n<p>12) <code>SWIFT_CODE = \"^([0-9]{10})?$\";</code></p>\n\n<p>13) <code>PINCODE = \"^([0-9]{6})?$\";</code></p>\n"},{"score":6,"body":"<p>This is a JavaScript translation of the validation suggested by the official Rails guide used by thousands of websites:</p>\n\n<pre><code>/^([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})$/i\n</code></pre>\n\n<p>Relatively simple but tests against most common errors.</p>\n\n<p>Tested on a dataset of thousands of emails and it had zero false negatives/positives.</p>\n\n<p>Example usage:</p>\n\n<pre><code>const emailRegex = /^([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})$/i;\n\nemailRegex.test('email@example.com');    // true\n\n// Multi-word domains\nemailRegex.test('email@example.co.uk');  // true\nemailRegex.test('email@mail.gmail.com'); // true\n\n// Valid special characters\nemailRegex.test('unusual+but+valid+email1900=/!#$%&amp;\\'*+-/=?^_`.{|}~@example.com') // true\n\n// Trailing dots\nemailRegex.test('email@example.co.uk.'); // false\n\n// No domain\nemailRegex.test('email@example');        // false\n\n// Leading space\nemailRegex.test(' email@example.com');   // false\n\n// Trailing space\nemailRegex.test('email@example.com ');   // false\n\n// Incorrect domains\nemailRegex.test('email@example,com ');   // false\n\n// Other invalid emails\nemailRegex.test('invalid.email.com')        // false\nemailRegex.test('invalid@email@domain.com') // false\nemailRegex.test('email@example..com')       // false\n</code></pre>\n"},{"score":0,"body":"<p>Here is a solution that works and includes validation/notification fuctionality in a form:</p>\n\n<p>You can run it <a href=\"https://codepen.io/aabiro/pen/eyGJMV\" rel=\"nofollow noreferrer\">at this link</a></p>\n\n<p><strong><em>JAVASCRIPT</em></strong></p>\n\n<pre><code>(function() {\n  'use strict';\n\n  window.addEventListener('load', function() {\n    var form = document.getElementById('needs-validation');\n    form.addEventListener('submit', function(event) {\n      if (form.checkValidity() === false) {\n        event.preventDefault();\n      }\n      form.classList.add('was-validated');\n      event.preventDefault();              \n    }, false);\n  }, false);\n})();\n</code></pre>\n\n<p><strong><em>HTML</em></strong></p>\n\n<pre><code>&lt;p class='title'&gt;\n    &lt;b&gt;Email validation&lt;/b&gt;\n  &lt;hr size=\"30px;\"&gt;\n&lt;/p&gt;\n&lt;br&gt;\n\n&lt;form id=\"needs-validation\" novalidate&gt;\n  &lt;p class='form_text'&gt;Try it out!&lt;/p&gt;\n  &lt;div class=\"form-row\"&gt;\n    &lt;div class=\"col-12\"&gt;\n      &lt;input type=\"email\" class=\"form-control\" placeholder=\"Email Address\" required&gt;\n        &lt;div class=\"invalid-feedback\"&gt;\n          Please enter a valid email address.\n        &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;div class=\"row\"&gt;\n    &lt;div class=\"col-12\"&gt;\n      &lt;button type=\"submit\" \n          class=\"btn btn-default btn-block\"&gt;Sign up now\n      &lt;/button&gt;\n    &lt;/div&gt;\n   &lt;/div&gt;\n&lt;/form&gt;\n</code></pre>\n\n\n"},{"score":0,"body":"<p>I wrote a JavaScript email validator which is fully compatile with PHP's <code>filter_var($value, FILTER_VALIDATE_EMAIL)</code> implementation.</p>\n\n<p><a href=\"https://github.com/mpyw/FILTER_VALIDATE_EMAIL.js\" rel=\"nofollow noreferrer\">https://github.com/mpyw/FILTER_VALIDATE_EMAIL.js</a></p>\n\n<pre><code>import validateEmail from 'filter-validate-email'\n\nconst value = '...'\nconst result = validateEmail(value)\n</code></pre>\n\n<p>is equivalent to:</p>\n\n<pre><code>&lt;?php\n\n$value = '...';\n$result = (bool)filter_var($value, FILTER_VALIDATE_EMAIL, FILTER_FLAG_EMAIL_UNICODE);\n</code></pre>\n"},{"score":-2,"body":"<pre><code>function ValidateEmail(mail) \n{\n  if (/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(myForm.emailAddr.value))\n  {\n    return (true)\n  }\n  alert(\"You have entered an invalid email address!\")\n  return (false)\n}\n</code></pre>\n\n<p>Ref URL: <a href=\"https://www.w3resource.com/javascript/form/email-validation.php\" rel=\"nofollow noreferrer\">https://www.w3resource.com/javascript/form/email-validation.php</a></p>\n"},{"score":-2,"body":"<p>This works for me:</p>\n\n<pre><code>function Email(mail)\n{\n if (/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(myForm.emailAddr.value))\n  {\n    return (true)\n  }\n    alert(\"Invalid email address!\")\n    return (false)\n}\n</code></pre>\n"},{"score":-3,"body":"<p>The personal_info part contains the following ASCII characters. </p>\n\n<ol>\n<li>Uppercase (A-Z) and lowercase (a-z) English letters. Digits (0-9).</li>\n<li>Characters ! # $ % &amp; ' * + - / = ? ^ _ ` { | } ~ </li>\n<li>Character . ( period, dot or fullstop) provided that it is not the\nfirst or last character and it will not come one after the other.</li>\n</ol>\n\n<p>The domain name [for example com, org, net, in, us, info] part contains letters, digits, hyphens, and dots. </p>\n\n<pre><code> function ValidateEmail(mail) \n{\n if (/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(myForm.emailAddr.value))\n  {\n    return (true)\n  }\n    alert(\"You have entered an invalid email address!\")\n    return (false)\n}\n</code></pre>\n"},{"score":-2,"body":"<p>You could also use the New <code>Regex</code> class and make this way:</p>\n\n<p><code>function validateEmail( str ) {\n    return new RegExp( /([\\w\\.\\-_]+)?\\w+@[\\w-_]+(\\.\\w+){1,}/, 'igm' ).test( str );\n}</code> </p>\n\n<p>reference:\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\" rel=\"nofollow noreferrer\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions</a></p>\n"},{"score":2,"body":"<p>Here is the recommended Regex pattern for HTML5 on MDN:</p>\n\n<blockquote>\n  <p>Browsers that support the email input type automatically provide validation to ensure that only text that matches the standard format for Internet e-mail addresses is entered into the input box. Browsers that implement the specification should be using an algorithm equivalent to the following regular expression:</p>\n</blockquote>\n\n<pre><code>/^[a-zA-Z0-9.!#$%&amp;'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}\n[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/\n</code></pre>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#Validation\" rel=\"nofollow noreferrer\">https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email#Validation</a></p>\n"},{"score":0,"body":"<p>You cold use <a href=\"https://github.com/chriso/validator.js\" rel=\"nofollow noreferrer\">https://github.com/chriso/validator.js</a> and simply do:</p>\n\n<pre><code>var validator = require('validator');\n\nvalidator.isEmail('foo@bar.com'); //=&gt; true\n</code></pre>\n\n<p>Note that this can work on the client.</p>\n"},{"score":1,"body":"<p>Here's how I do it. I'm using match() to check for the standard email pattern and I'm adding a class to the input text to notify the user accordingly. Hope that helps!</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>$(document).ready(function(){\r\n  $('#submit').on('click', function(){\r\n      var email = $('#email').val();\r\n      var pat = /^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/;\r\n      if (email.match(pat)){\r\n        $('#email')\r\n          .addClass('input-valid');\r\n        return false;\r\n      } else {\r\n        $('#email')\r\n        \t.addClass('input-error')\r\n          .val('');\r\n        return false;\r\n      }\r\n  });\r\n});</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>.input-error {\r\n  border: 1px solid red;\r\n  color: red;\r\n}\r\n\r\n.input-valid {\r\n  border: 1px solid green;\r\n  color: green;\r\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;\r\n&lt;form&gt;\r\n    &lt;input type=\"text\" id=\"email\" placeholder=\"name@service.xx\" class=\"\"&gt;\r\n    &lt;input type=\"submit\" id=\"submit\" value=\"Send\"/&gt;\r\n&lt;/form&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":-1,"body":"<p>There is my version of an email validator. This code is done with object-oriented programming and realized as a class with static methods. You will find two versions of the validators: strict(<code>EmailValidator.validate</code>) and kind(<code>EmailValidator.validateKind</code>).</p>\n\n<p>The first throws an error if an email is invalid and returns email otherwise. The second returns Boolean value that says if an email is valid. I prefer the strict version in most of the cases.</p>\n\n<pre><code>export class EmailValidator {\n    /**\n     * @param {string} email\n     * @return {string}\n     * @throws {Error}\n     */\n    static validate(email) {\n        email = this.prepareEmail(email);\n\n        const isValid = this.validateKind(email);\n\n        if (isValid)\n            return email;\n\n        throw new Error(`Got invalid email: ${email}.`);\n    }\n\n    /**\n     * @param {string} email\n     * @return {boolean}\n     */\n    static validateKind(email) {\n        email = this.prepareEmail(email);\n\n        const regex = this.getRegex();\n\n        return regex.test(email);\n    }\n\n    /**\n     * @return {RegExp}\n     * @private\n     */\n    static getRegex() {\n        return /^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    }\n\n    /**\n     * @param {string} email\n     * @return {string}\n     * @private\n     */\n    static prepareEmail(email) {\n        return String(email).toLowerCase();\n    }\n}\n</code></pre>\n\n<p>To validate an email you can follow these ways:</p>\n\n<pre><code>// First way.\n\ntry {\n    EmailValidator.validate('balovbohdan@gmail.com');\n} catch (e) {\n    console.error(e.message);\n}\n</code></pre>\n\n<pre><code>// Second way.\n\nconst email = 'balovbohdan@gmail.com';\nconst isValid = EmailValidator.validateKind(email);\n\nif (isValid)\n    console.log(`Email is valid: ${email}.`);\nelse\n    console.log(`Email is invalid: ${email}.`);\n</code></pre>\n"},{"score":-1,"body":"<p>I am using this function </p>\n\n<pre><code>/**\n * @param {*} email\n */\nexport const validateEmail = email =&gt; {\n    return new RegExp(/[\\w-]+@([\\w-]+\\.)+[\\w-]+/gm).test(email);\n};\n</code></pre>\n"},{"score":1,"body":"<p>General email regex (RFC 5322 Official Standard): <a href=\"https://emailregex.com/\" rel=\"nofollow noreferrer\">https://emailregex.com/</a></p>\n\n<p>JavaScript:</p>\n\n<pre><code>/^(([^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n</code></pre>\n"},{"score":2,"body":"<p>Search for the @ sign in the input field. </p>\n"},{"score":0,"body":"<p>If you want something a human can read and <strong>maintain</strong>, I would recommend <a href=\"https://github.com/masala-oss/masala-parser\" rel=\"nofollow noreferrer\">Masala Parser</a> (I'm one of the creators of it).</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>import {C,Streams} from '@masala/parser'\n\nconst illegalCharset = ' @\\u00A0\\n\\t';\nconst extendedIllegalCharset = illegalCharset + '.';\n\n\n// Assume 'nicolas@internal.masala.co.uk'\nexport function simpleEmail() {\n\n    return C.charNotIn(illegalCharset).rep() // 'nicolas'\n        .then(C.char('@'))\n        .then(subDns())  //'internal.masala.co.'\n        .then(C.charNotIn(extendedIllegalCharset).rep()) //'uk'\n        .eos(); // Must be end of the char stream\n}\n\n// x@internal.masala.co.uk =&gt; extract 'internal.masala.co.'\nfunction  subDns() {\n    return C.charNotIn(extendedIllegalCharset).rep().then(C.char('.')).rep()\n}\n\nfunction validateEmail(email:string) {\n    console.log(email + ': ' + (simpleEmail().parse(Streams.ofString(email)).isAccepted()));\n}\n\n\nvalidateEmail('nicolas@internal.masala.co.uk'); // True\nvalidateEmail('nz@co.'); // False, trailing \".\"\n</code></pre>\n\n<p>If you want to accept the ultimate ugly email version, you can add in quotes in the first part:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>\nfunction inQuote() {\n    return C.char('\"')\n        .then(C.notChar('\"').rep())\n        .then(C.char('\"'))\n}\n\nfunction allEmail() {\n\n    return inQuote().or(C.charNotIn(illegalCharset))\n        .rep() // repeat (inQuote or anyCharacter)\n        .then(C.char('@'))\n        .then(subDns())\n        .then(C.charNotIn(extendedIllegalCharset).rep())\n        .eos() // Must be end of the character stream\n        // Create a structure\n        .map(function (characters) { return ({ email: characters.join('') }); });\n}\n</code></pre>\n\n<p><code>'\"nicolas\"\"love-quotes\"@masala.co.uk'</code> is officially valid, but should it be in your system?</p>\n\n<p>At least with Masala, you give yourself a chance to understand it. And so for the next year, colleague.</p>\n"},{"score":2,"body":"<p>I add my Regex - i solved for me more little issues like characters from other languages or capital letters </p>\n\n<pre><code>^[a-zA-Z0-9][a-zA-Z0-9-_\\.]+@([a-zA-Z]|[a-zA-Z0-9]?[a-zA-Z0-9-]+[a-zA-Z0-9])\\.[a-zA-Z0-9]{2,10}(?:\\.[a-zA-Z]{2,10})?$\n</code></pre>\n"},{"score":1,"body":"<p>Use the browser/runtime to handle parsing the input by prepending a protocol and pass it to the <code>URL</code> API, trapping any errors and check the resulting <code>username</code> and <code>hostname</code> properties of the result. It will handle basically all transformations and possibilities (<a href=\"https://en.wikipedia.org/wiki/Punycode\" rel=\"nofollow noreferrer\">punycode</a> of character sets, etc). This only establishes that the input is parsable, not that is valid--that is only possible through checking if the destination machine receives messages for that alias. This provides a close (imo reasonable) guess though, and can be expanded to be more specific and realistic if you're comfortable both maintaining it and also risking invalid rejections. (Note it doesn't attempt to address IPv4 or IPv6 addresses, simply the broad range of customer-facing scenarios using a domain.)</p>\n\n<pre><code>function validEmail(email=''){\n    var $0, url, isValid = false, emailPatternInput = /^[^@]{1,64}@[^@]{4,253}$/, emailPatternUrl = /^[^@]{1,64}@[a-z][a-z0-9\\.-]{3,252}$/i;\n    email = email.trim();\n    try{\n        url = new URL('http://'+email);\n        $0 = `${url.username}@${url.hostname}`;\n        isValid = emailPatternInput.test( email );\n        if(!isValid) throw 'invalid email pattern on input:' + email;\n        isValid = emailPatternUrl.test( $0 );\n        if(!isValid) throw 'invalid email pattern on url:' + $0;\n        console.log(`email looks legit \"${email}\" checking url-parts: \"${$0 === email ? '-SAME-':$0}\"`);\n    }catch(err){\n        console.error(`probably not an email address: \"${email}\"`, err);\n    };\n    return isValid;\n}\n\n['user+this@はじめよう.みんな', 'stuff@things', 'user+that@host.com', 'Jean+François@anydomain.museum','هيا@יאללה', '试@例子.测试.مثال.آزمایشی', 'not@@really', 'no'].forEach(email=&gt;console.log(validEmail(email), email));\n</code></pre>\n\n<p>This is the both the simplest and most generally permissive example I can come up with. Please edit it in cases where it can be made to be more accurate while maintain its simplicity and reasonable generally permissive validity.</p>\n\n<p>Also see MDN URL docs <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\" rel=\"nofollow noreferrer\">URL</a>, <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL\" rel=\"nofollow noreferrer\">window.URL</a> and Nodejs for <a href=\"https://nodejs.org/api/url.html\" rel=\"nofollow noreferrer\">URL</a> APIs.</p>\n"},{"score":-1,"body":"<p>for email validation you can create your custom function and use regex syntax for validate email:</p>\n\n<pre><code>function validateEmail(email){\n        var reg = /^([A-Za-z0-9_\\-\\.])+\\@([A-Za-z0-9_\\-\\.])+\\.([A-Za-z]{2,4})$/;\n\n       //your custom code here to check your email address \n\n}\n</code></pre>\n"},{"score":0,"body":"<p>These will work with the top used emails(<strong>they match exactly the rules of each one</strong>).\n<br><br>\n<strong>Gmail</strong>\n<br>\n<code>/^[a-z]((?!\\.\\.)([a-z\\.])){4,28}[a-z0-9]@gmail.com$/i</code>\n<br><br>\n<strong>Yahoo</strong>\n<br>\n<code>/^[a-z]((?!\\.\\.)([\\w\\.])){3,30}[\\w]@yahoo.com$/i</code>\n<br><br>\n<strong>Outlook</strong>/<strong>Hotmail</strong>\n<br>\n<code>/[a-z]((?!\\.\\.)([\\w\\.])){0,62}[\\w]@(outlook.com|hotmail.com)$/i</code></p>\n"},{"score":1,"body":"<p>You may try <code>RegExp</code></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function isValidEmail( value ) {\r\n\treturn /^[\\w\\-\\.\\+]+\\@[a-zA-Z0-9\\.\\-]+\\.[a-zA-z0-9]{2,5}$/.test( value );\r\n}\r\n\r\nconsole.log( isValidEmail(\"mymail@mydomain.com\") )</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":-1,"body":"<p>In my case i want to avoid ~ and # that's why i have use another solution <a href=\"https://regex101.com/r/SOgUIV/1\" rel=\"nofollow noreferrer\">Click Here</a> For more information </p>\n\n<pre><code>function validEmail(email){\n  const regex = /^((?!\\.)[\\w-_.]*[^.])(@\\w+)(\\.\\w+(\\.\\w+)?[^.\\W])$/;\n  return regex.test(email);\n}\n</code></pre>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function validEmail(email){\r\n  const regex = /^((?!\\.)[\\w-_.]*[^.])(@\\w+)(\\.\\w+(\\.\\w+)?[^.\\W])$/;\r\n  return regex.test(email);\r\n}\r\n\r\nconst emails = [\r\n'pio_pio@factory.com',\r\n'~pio_pio@factory.com',\r\n'pio_~pio@factory.com',\r\n'pio_#pio@factory.com',\r\n'pio_pio@#factory.com',\r\n'pio_pio@factory.c#om',\r\n'pio_pio@factory.c*om',\r\n'pio^_pio@factory.com'\r\n]\r\n\r\nfor(const email of emails){\r\n  document.write(email+' : '+validEmail(email)+'&lt;/br&gt;');\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":4,"body":"<p>Use <code>W3C</code> especially created regular expression.</p>\n\n<p>Reference with full explanation of the <code>RegEx</code>:</p>\n\n<p><a href=\"https://www.w3resource.com/javascript/form/email-validation.php\" rel=\"nofollow noreferrer\">https://www.w3resource.com/javascript/form/email-validation.php</a></p>\n\n<pre><code>/^\\w+([\\.-]?\\w+)*@\\w+([\\.-]?\\w+)*(\\.\\w{2,3})+$/.test(emailValue)\n</code></pre>\n\n<p>If you use Node you can use this in the back-end as well as the front-end.</p>\n\n<p>I don't know other back-end languages so I cannot evaluate for other use cases.</p>\n"},{"score":4,"body":"<p>Wow there are a lot of answers that contain slightly different regular expressions. I've tried some many that I've got different results and a variety of different issues with all of them.</p>\n\n<p>For UI validation, I'm good with the most basic check of <a href=\"https://www.endyourif.com/validate-an-email-address-in-javascript/\" rel=\"nofollow noreferrer\">looking for an @ sign</a>. It's important to note, that I always do server-side validation with a standard \"validate email\" that contains a unique link for the user to confirm their email address.</p>\n\n<pre><code>if (email.indexOf('@') &gt; 0)\n</code></pre>\n\n<p>I have purposely chosen 0 even with zero-based as it also ensures there is a single character before the @.</p>\n"},{"score":5,"body":"<p>I prefer to keep it simple and keep my users happy.  I also prefer code which is easy to understand. RegEx is not.</p>\n\n<pre><code>function isValidEmail(value) {\n    const atLocation = value.lastIndexOf(\"@\");\n    const dotLocation = value.lastIndexOf(\".\"); \n    return (\n        atLocation &gt; 0 &amp;&amp;\n        dotLocation &gt; atLocation + 1 &amp;&amp;\n        dotLocation &lt; value.length - 1\n    );\n};\n</code></pre>\n\n<ul>\n<li>Get the location of the last \"@\" and the last \".\"</li>\n<li>Make sure the \"@\" is not the first char (there is something before it) </li>\n<li>Make sure the \".\" is after the \"@\" and that there is at least one char between them</li>\n<li>Make sure there is at least a single char after the \".\"</li>\n</ul>\n\n<p>Will this allow invalid email addresses to pass?  Sure, but I don't think you need much more for a good user experience that allows you to enable/disable a button, display an error message, etc.  You only know for sure that an email address is valid when you attempt to send an email to that address.</p>\n"},{"score":0,"body":"<p>If you get this error: Using regular expressions is security-sensitive.</p>\n\n<p>Then here is what you are looking for.This solution is free from \" Regular expression Denial of Service (ReDoS) \"</p>\n\n<p>Regex to validate emails without (ReDoS): </p>\n\n<pre><code>/^[a-z0-9](?!.*?[^\\na-z0-9]{2})[^\\s@]+@[^\\s@]+\\.[^\\s@]+[a-z0-9]$/\n</code></pre>\n\n<p>Please let me know if this solutions works for you.\nThanks.</p>\n"},{"score":0,"body":"<pre><code>if (rules.isEmail) {\n            const pattern = /[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&amp;'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?/;\n            isValid = pattern.test(value) &amp;&amp; isValid\n        }\n</code></pre>\n<p>You can use this for Email validaiton .</p>\n"},{"score":4,"body":"<p>Most of the answers here are not linter friendly, it's a mess! Some of them are also out-dated!\nAfter a lot of time spending, I decided to use an external library named <code>email-validator</code>, install it easily by npm for example and import/require it in your own project:</p>\n<p><a href=\"https://www.npmjs.com/package/email-validator\" rel=\"nofollow noreferrer\">https://www.npmjs.com/package/email-validator</a></p>\n<pre><code>//NodeJs\nconst validator = require(&quot;email-validator&quot;);\nvalidator.validate(&quot;test@email.com&quot;); // true\n\n//TypeScript/JavaScript\nimport * as EmailValidator from 'email-validator';\nEmailValidator.validate(&quot;test@email.com&quot;); // true\n</code></pre>\n"},{"score":0,"body":"<pre><code>     // Html form call function name at submit button\n\n    &lt;form name=&quot;form1&quot; action=&quot;#&quot;&gt; \n    &lt;input type='text' name='text1'/&gt;\n    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; \n    onclick=&quot;ValidateEmail(document.form1.text1)&quot;/&gt;\n   &lt;/from&gt;\n\n    // Write the function name ValidateEmail below\n\n    &lt;script&gt;\n     function ValidateEmail(inputText)\n    {\n  var mailformat = /^[a-zA-Z0-9.!#$%&amp;'*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n    if(inputText.value.match(mailformat))\n    {\n    alert(&quot;Valid email address!&quot;);\n    document.form1.text1.focus();\n    return true;\n    }\n    else\n   {\n    alert(&quot;You have entered an invalid email address!&quot;);\n    document.form1.text1.focus();\n    return false;\n    }\n    }\n   &lt;/script&gt;\n</code></pre>\n"}],"score":4639}