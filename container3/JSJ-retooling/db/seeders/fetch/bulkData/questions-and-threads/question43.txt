{"body":"<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = [];\n// let's create 3 functions\nfor (var i = 0; i &lt; 3; i++) {\n  // and store them in funcs\n  funcs[i] = function() {\n    // each should log its value.\n    console.log(\"My value: \" + i);\n  };\n}\nfor (var j = 0; j &lt; 3; j++) {\n  // and now let's run each one to see\n  funcs[j]();\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>It outputs this:</p>\n<blockquote>\n<p>My value: 3<br />\nMy value: 3<br />\nMy value: 3</p>\n</blockquote>\n<p>Whereas I'd like it to output:</p>\n<blockquote>\n<p>My value: 0<br />\nMy value: 1<br />\nMy value: 2</p>\n</blockquote>\n<hr />\n<p>The same problem occurs when the delay in running the function is caused by using event listeners:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var buttons = document.getElementsByTagName(\"button\");\n// let's create 3 functions\nfor (var i = 0; i &lt; buttons.length; i++) {\n  // as event listeners\n  buttons[i].addEventListener(\"click\", function() {\n    // each should log its value.\n    console.log(\"My value: \" + i);\n  });\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;button&gt;0&lt;/button&gt;\n&lt;br /&gt;\n&lt;button&gt;1&lt;/button&gt;\n&lt;br /&gt;\n&lt;button&gt;2&lt;/button&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>… or asynchronous code, e.g. using Promises:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// Some async wait function\nconst wait = (ms) =&gt; new Promise((resolve, reject) =&gt; setTimeout(resolve, ms));\n\nfor (var i = 0; i &lt; 3; i++) {\n  // Log `i` as soon as each promise resolves.\n  wait(i * 100).then(() =&gt; console.log(i));\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>It is also apparent in <code>for in</code> and <code>for of</code> loops:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const arr = [1,2,3];\nconst fns = [];\n\nfor(var i in arr){\n  fns.push(() =&gt; console.log(`index: ${i}`));\n}\n\nfor(var v of arr){\n  fns.push(() =&gt; console.log(`value: ${v}`));\n}\n\nfor(var f of fns){\n  f();\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>What’s the solution to this basic problem?</p>\n","title":"JavaScript closure inside loops – simple practical example","answers":[{"score":390,"body":"<p>Try:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = [];\r\n    \r\nfor (var i = 0; i &lt; 3; i++) {\r\n    funcs[i] = (function(index) {\r\n        return function() {\r\n            console.log(\"My value: \" + index);\r\n        };\r\n    }(i));\r\n}\r\n\r\nfor (var j = 0; j &lt; 3; j++) {\r\n    funcs[j]();\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong>Edit</strong> (2014):</p>\n\n<p>Personally I think @Aust's <a href=\"https://stackoverflow.com/a/19323214/918959\">more recent answer about using <code>.bind</code></a> is the best way to do this kind of thing now. There's also lo-dash/underscore's <code>_.partial</code> when you don't need or want to mess with <code>bind</code>'s <code>thisArg</code>.</p>\n"},{"score":2216,"body":"<p>Well, the problem is that the variable <code>i</code>, within each of your anonymous functions, is bound to the same variable outside of the function.</p>\n<h1>ES6 solution: <code>let</code></h1>\n<p>ECMAScript 6 (ES6) introduces new <code>let</code> and <code>const</code> keywords that are scoped differently than <code>var</code>-based variables. For example, in a loop with a <code>let</code>-based index, each iteration through the loop will have a new variable <code>i</code> with loop scope, so your code would work as you expect. There are many resources, but I'd recommend <a href=\"http://www.2ality.com/2015/02/es6-scoping.html\" rel=\"noreferrer\">2ality's block-scoping post</a> as a great source of information.</p>\n<pre><code>for (let i = 0; i &lt; 3; i++) {\n  funcs[i] = function() {\n    console.log(&quot;My value: &quot; + i);\n  };\n}\n</code></pre>\n<p>Beware, though, that IE9-IE11 and Edge prior to Edge 14 support <code>let</code> but get the above wrong (they don't create a new <code>i</code> each time, so all the functions above would log 3 like they would if we used <code>var</code>). Edge 14 finally gets it right.</p>\n<hr />\n<h1>ES5.1 solution: forEach</h1>\n<p>With the relatively widespread availability of the <code>Array.prototype.forEach</code> function (in 2015), it's worth noting that in those situations involving iteration primarily over an array of values, <code>.forEach()</code> provides a clean, natural way to get a distinct closure for every iteration. That is, assuming you've got some sort of array containing values (DOM references, objects, whatever), and the problem arises of setting up callbacks specific to each element, you can do this:</p>\n<pre><code>var someArray = [ /* whatever */ ];\n// ...\nsomeArray.forEach(function(arrayElement) {\n  // ... code code code for this one element\n  someAsynchronousFunction(arrayElement, function() {\n    arrayElement.doSomething();\n  });\n});\n</code></pre>\n<p>The idea is that each invocation of the callback function used with the <code>.forEach</code> loop will be its own closure. The parameter passed in to that handler is the array element specific to that particular step of the iteration. If it's used in an asynchronous callback, it won't collide with any of the other callbacks established at other steps of the iteration.</p>\n<p>If you happen to be working in jQuery, the <code>$.each()</code> function gives you a similar capability.</p>\n<hr />\n<h1>Classic solution: Closures</h1>\n<p>What you want to do is bind the variable within each function to a separate, unchanging value outside of the function:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = [];\n\nfunction createfunc(i) {\n  return function() {\n    console.log(\"My value: \" + i);\n  };\n}\n\nfor (var i = 0; i &lt; 3; i++) {\n  funcs[i] = createfunc(i);\n}\n\nfor (var j = 0; j &lt; 3; j++) {\n  // and now let's run each one to see\n  funcs[j]();\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>Since there is no block scope in JavaScript - only function scope - by wrapping the function creation in a new function, you ensure that the value of &quot;i&quot; remains as you intended.</p>\n"},{"score":9,"body":"<p>The reason your original example did not work is that all the closures you created in the loop referenced the same frame. In effect, having 3 methods on one object with only a single <code>i</code> variable. They all printed out the same value.</p>\n"},{"score":74,"body":"<p>What you need to understand is the scope of the variables in javascript is based on the function. This is an important difference than say c# where you have block scope, and just copying the variable to one inside the for will work.</p>\n\n<p>Wrapping it in a function that evaluates returning the function like apphacker's answer will do the trick, as the variable now has the function scope.</p>\n\n<p>There is also a let keyword instead of var, that would allow using the block scope rule. In that case defining a variable inside the for would do the trick. That said, the let keyword isn't a practical solution because of compatibility.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = {};\r\n\r\nfor (var i = 0; i &lt; 3; i++) {\r\n  let index = i; //add this\r\n  funcs[i] = function() {\r\n    console.log(\"My value: \" + index); //change to the copy\r\n  };\r\n}\r\n\r\nfor (var j = 0; j &lt; 3; j++) {\r\n  funcs[j]();\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":91,"body":"<p>Another way of saying it is that the <code>i</code> in your function is bound at the time of executing the function, not the time of creating the function.</p>\n\n<p>When you create the closure, <code>i</code> is a reference to the variable defined in the outside scope, not a copy of it as it was when you created the closure. It will be evaluated at the time of execution.</p>\n\n<p>Most of the other answers provide ways to work around by creating another variable that won't change the value for you.</p>\n\n<p>Just thought I'd add an explanation for clarity. For a solution, personally, I'd go with Harto's since it is the most self-explanatory way of doing it from the answers here. Any of the code posted will work, but I'd opt for a closure factory over having to write a pile of comments to explain why I'm declaring a new variable(Freddy and 1800's) or have weird embedded closure syntax(apphacker).</p>\n"},{"score":63,"body":"<p>Here's another variation on the technique, similar to Bjorn's (apphacker), which lets you assign the variable value inside the function rather than passing it as a parameter, which might be clearer sometimes:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = [];\r\nfor (var i = 0; i &lt; 3; i++) {\r\n    funcs[i] = (function() {\r\n        var index = i;\r\n        return function() {\r\n            console.log(\"My value: \" + index);\r\n        }\r\n    })();\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Note that whatever technique you use, the <code>index</code> variable becomes a sort of static variable, bound to the returned copy of the inner function. I.e., changes to its value are preserved between calls. It can be very handy.</p>\n"},{"score":58,"body":"<p>This describes the common mistake with using closures in JavaScript.</p>\n\n<h2>A function defines a new environment</h2>\n\n<p>Consider:</p>\n\n<pre><code>function makeCounter()\n{\n  var obj = {counter: 0};\n  return {\n    inc: function(){obj.counter ++;},\n    get: function(){return obj.counter;}\n  };\n}\n\ncounter1 = makeCounter();\ncounter2 = makeCounter();\n\ncounter1.inc();\n\nalert(counter1.get()); // returns 1\nalert(counter2.get()); // returns 0\n</code></pre>\n\n<p>For each time <code>makeCounter</code> is invoked, <code>{counter: 0}</code> results in a new object being created. Also, a new copy of <code>obj</code> \nis created as well to reference the new object. Thus, <code>counter1</code> and <code>counter2</code> are independent of each other.</p>\n\n<h2>Closures in loops</h2>\n\n<p>Using a closure in a loop is tricky.</p>\n\n<p>Consider: </p>\n\n<pre><code>var counters = [];\n\nfunction makeCounters(num)\n{\n  for (var i = 0; i &lt; num; i++)\n  {\n    var obj = {counter: 0};\n    counters[i] = {\n      inc: function(){obj.counter++;},\n      get: function(){return obj.counter;}\n    }; \n  }\n}\n\nmakeCounters(2);\n\ncounters[0].inc();\n\nalert(counters[0].get()); // returns 1\nalert(counters[1].get()); // returns 1\n</code></pre>\n\n<p>Notice that <code>counters[0]</code> and <code>counters[1]</code> are <em>not</em> independent. In fact, they operate on the same <code>obj</code>!</p>\n\n<p>This is because there is only one copy of <code>obj</code> shared across all iterations of the loop, perhaps for performance reasons.\nEven though <code>{counter: 0}</code> creates a new object in each iteration, the same copy of <code>obj</code> will just get updated with a\nreference to the newest object.</p>\n\n<p>Solution is to use another helper function:</p>\n\n<pre><code>function makeHelper(obj)\n{\n  return {\n    inc: function(){obj.counter++;},\n    get: function(){return obj.counter;}\n  }; \n}\n\nfunction makeCounters(num)\n{\n  for (var i = 0; i &lt; num; i++)\n  {\n    var obj = {counter: 0};\n    counters[i] = makeHelper(obj);\n  }\n}\n</code></pre>\n\n<p>This works because local variables in the function scope directly, as well as function argument variables, are allocated \nnew copies upon entry.</p>\n"},{"score":158,"body":"<p>With ES6 now widely supported, the best answer to this question has changed.  ES6 provides the <code>let</code> and <code>const</code> keywords for this exact circumstance.  Instead of messing around with closures, we can just use <code>let</code> to set a loop scope variable like this:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = [];\r\n\r\nfor (let i = 0; i &lt; 3; i++) {          \r\n    funcs[i] = function() {            \r\n      console.log(\"My value: \" + i); \r\n    };\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><code>val</code> will then point to an object that is specific to that particular turn of the loop, and will return the correct value without the additional closure notation.  This obviously significantly simplifies this problem.</p>\n\n<p><code>const</code> is similar to <code>let</code> with the additional restriction that the variable name can't be rebound to a new reference after initial assignment.</p>\n\n<p>Browser support is now here for those targeting the latest versions of browsers. <code>const</code>/<code>let</code> are currently supported in the latest Firefox, Safari, Edge and Chrome. It also is supported in Node, and you can use it anywhere by taking advantage of build tools like Babel.  You can see a working example here: <a href=\"http://jsfiddle.net/ben336/rbU4t/2/\" rel=\"noreferrer\">http://jsfiddle.net/ben336/rbU4t/2/</a></p>\n\n<p>Docs here:</p>\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const\" rel=\"noreferrer\">const</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let\" rel=\"noreferrer\">let</a></li>\n</ul>\n\n<p>Beware, though, that IE9-IE11 and Edge prior to Edge 14 support <code>let</code> but get the above wrong (they don't create a new <code>i</code> each time, so all the functions above would log 3 like they would if we used <code>var</code>). Edge 14 finally gets it right.</p>\n"},{"score":51,"body":"<p>The most simple solution would be,</p>\n\n<p>Instead of using:</p>\n\n<pre><code>var funcs = [];\nfor(var i =0; i&lt;3; i++){\n    funcs[i] = function(){\n        alert(i);\n    }\n}\n\nfor(var j =0; j&lt;3; j++){\n    funcs[j]();\n}\n</code></pre>\n\n<p>which alerts \"2\", for 3 times. This is because anonymous functions created in for loop, shares same closure, and in that closure, the value of <code>i</code> is the same. Use this to prevent shared closure:</p>\n\n<pre><code>var funcs = [];\nfor(var new_i =0; new_i&lt;3; new_i++){\n    (function(i){\n        funcs[i] = function(){\n            alert(i);\n        }\n    })(new_i);\n}\n\nfor(var j =0; j&lt;3; j++){\n    funcs[j]();\n}\n</code></pre>\n\n<p>The idea behind this is, encapsulating the entire body of the for loop with an <a href=\"https://en.wikipedia.org/wiki/Immediately-invoked_function_expression\" rel=\"noreferrer\">IIFE</a> (Immediately-Invoked Function Expression) and passing <code>new_i</code> as a parameter and capturing it as <code>i</code>. Since the anonymous function is executed immediately, the <code>i</code> value is different for each function defined inside the anonymous function.</p>\n\n<p>This solution seems to fit any such problem since it will require minimal changes to the original code suffering from this issue. In fact, this is by design, it should not be an issue at all!</p>\n"},{"score":32,"body":"<h2>try this shorter one</h2>\n\n<ul>\n<li><p>no array</p></li>\n<li><p>no extra for loop</p></li>\n</ul>\n\n<p><br/></p>\n\n<pre><code>for (var i = 0; i &lt; 3; i++) {\n    createfunc(i)();\n}\n\nfunction createfunc(i) {\n    return function(){console.log(\"My value: \" + i);};\n}\n</code></pre>\n\n<p><a href=\"http://jsfiddle.net/7P6EN/\">http://jsfiddle.net/7P6EN/</a></p>\n"},{"score":358,"body":"<p>Another way that hasn't been mentioned yet is the use of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" rel=\"noreferrer\"><code>Function.prototype.bind</code></a></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = {};\r\nfor (var i = 0; i &lt; 3; i++) {\r\n  funcs[i] = function(x) {\r\n    console.log('My value: ' + x);\r\n  }.bind(this, i);\r\n}\r\nfor (var j = 0; j &lt; 3; j++) {\r\n  funcs[j]();\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong>UPDATE</strong></p>\n\n<p>As pointed out by @squint and @mekdev, you get better performance by creating the function outside the loop first and then binding the results within the loop.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function log(x) {\r\n  console.log('My value: ' + x);\r\n}\r\n\r\nvar funcs = [];\r\n\r\nfor (var i = 0; i &lt; 3; i++) {\r\n  funcs[i] = log.bind(this, i);\r\n}\r\n\r\nfor (var j = 0; j &lt; 3; j++) {\r\n  funcs[j]();\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":275,"body":"<p>Using an <a href=\"http://en.wikipedia.org/wiki/Immediately-invoked_function_expression\" rel=\"noreferrer\">Immediately-Invoked Function Expression</a>, the simplest and most readable way to enclose an index variable:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>for (var i = 0; i &lt; 3; i++) {\r\n\r\n    (function(index) {\r\n\r\n        console.log('iterator: ' + index);\r\n        //now you can also loop an ajax call here \r\n        //without losing track of the iterator value:   $.ajax({});\r\n    \r\n    })(i);\r\n\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>This sends the iterator <code>i</code> into the anonymous function of which we define as <code>index</code>.  This creates a closure, where the variable <code>i</code> gets saved for later use in any asynchronous functionality within the IIFE.</p>\n"},{"score":29,"body":"<p>The main issue with the code shown by the OP is that <code>i</code> is never read until the second loop. To demonstrate, imagine seeing an error inside of the code</p>\n\n<pre><code>funcs[i] = function() {            // and store them in funcs\n    throw new Error(\"test\");\n    console.log(\"My value: \" + i); // each should log its value.\n};\n</code></pre>\n\n<p>The error actually does not occur until <code>funcs[someIndex]</code> is executed <code>()</code>. Using this same logic, it should be apparent that the value of <code>i</code> is also not collected until this point either. Once the original loop finishes, <code>i++</code> brings <code>i</code> to the value of <code>3</code> which results in the condition <code>i &lt; 3</code> failing and the loop ending. At this point, <code>i</code> is <code>3</code> and so when <code>funcs[someIndex]()</code> is used, and <code>i</code> is evaluated, it is 3 - every time.</p>\n\n<p>To get past this, you must evaluate <code>i</code> as it is encountered. Note that this has already happened in the form of <code>funcs[i]</code> (where there are 3 unique indexes). There are several ways to capture this value. One is to pass it in as a parameter to a function which is shown in several ways already here. </p>\n\n<p>Another option is to construct a function object which will be able to close over the variable. That can be accomplished thusly</p>\n\n<p><em><strong><a href=\"http://jsfiddle.net/QcUjH/\"><code>jsFiddle Demo</code></a></em></strong></p>\n\n<pre><code>funcs[i] = new function() {   \n    var closedVariable = i;\n    return function(){\n        console.log(\"My value: \" + closedVariable); \n    };\n};\n</code></pre>\n"},{"score":33,"body":"<p>Here's a simple solution that uses <code>forEach</code> (works back to IE9):</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = [];\r\n[0,1,2].forEach(function(i) {          // let's create 3 functions\r\n    funcs[i] = function() {            // and store them in funcs\r\n        console.log(\"My value: \" + i); // each should log its value.\r\n    };\r\n})\r\nfor (var j = 0; j &lt; 3; j++) {\r\n    funcs[j]();                        // and now let's run each one to see\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Prints:</p>\n\n<blockquote>\n<pre><code>My value: 0\nMy value: 1\nMy value: 2\n</code></pre>\n</blockquote>\n"},{"score":15,"body":"<p>After reading through various solutions, I'd like to add that the reason those solutions work is to rely on the concept of <strong>scope chain</strong>. It's the way JavaScript resolve a variable during execution.  </p>\n\n<ul>\n<li>Each function definition forms a scope consisting of all the local \nvariables declared by <code>var</code> and its <code>arguments</code>.   </li>\n<li>If we have inner function defined inside another (outer) function, this \nforms a chain, and will be used during execution   </li>\n<li>When a function gets executed, the runtime evaluates variables by searching the <strong>scope chain</strong>. If a variable can be found in a certain point of the chain it will stop searching and use it, otherwise it continues until the global scope reached which belongs to <code>window</code>.</li>\n</ul>\n\n<p>In the initial code:</p>\n\n<pre><code>funcs = {};\nfor (var i = 0; i &lt; 3; i++) {         \n  funcs[i] = function inner() {        // function inner's scope contains nothing\n    console.log(\"My value: \" + i);    \n  };\n}\nconsole.log(window.i)                  // test value 'i', print 3\n</code></pre>\n\n<p>When <code>funcs</code> gets executed, the scope chain will be <code>function inner -&gt; global</code>. Since the variable <code>i</code> cannot be found in <code>function inner</code> (neither declared using <code>var</code> nor passed as arguments), it continues to search, until the value of <code>i</code> is eventually found in the global scope which is <code>window.i</code>.</p>\n\n<p>By wrapping it in an outer function either explicitly define a helper function like <a href=\"https://stackoverflow.com/a/750506\">harto</a> did or use an anonymous function like <a href=\"https://stackoverflow.com/a/750495\">Bjorn</a> did:</p>\n\n<pre><code>funcs = {};\nfunction outer(i) {              // function outer's scope contains 'i'\n  return function inner() {      // function inner, closure created\n   console.log(\"My value: \" + i);\n  };\n}\nfor (var i = 0; i &lt; 3; i++) {\n  funcs[i] = outer(i);\n}\nconsole.log(window.i)          // print 3 still\n</code></pre>\n\n<p>When <code>funcs</code> gets executed, now the scope chain will be <code>function inner -&gt; function outer</code>. This time <code>i</code> can be found in the outer function's scope which is executed 3 times in the for loop, each time has value <code>i</code> bound correctly. It won't use the value of <code>window.i</code> when inner executed.</p>\n\n<p>More detail can be found <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Closures\" rel=\"noreferrer\">here</a><br>\nIt includes the common mistake in creating closure in the loop as what we have here, as well as why we need closure and the performance consideration.</p>\n"},{"score":10,"body":"<p>I'm surprised no one yet has suggested using the <code>forEach</code> function to better avoid (re)using local variables. In fact, I'm not using <code>for(var i ...)</code> at all anymore for this reason.</p>\n\n<pre><code>[0,2,3].forEach(function(i){ console.log('My value:', i); });\n// My value: 0\n// My value: 2\n// My value: 3\n</code></pre>\n\n<p>// edited to use <code>forEach</code> instead of map.</p>\n"},{"score":170,"body":"<p>Bit late to the party, but I was exploring this issue today and noticed that many of the answers don't completely address how Javascript treats scopes, which is essentially what this boils down to.</p>\n<p>So as many others mentioned, the problem is that the inner function is referencing the same <code>i</code> variable. So why don't we just create a new local variable each iteration, and have the inner function reference that instead?</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>//overwrite console.log() so you can see the console output\nconsole.log = function(msg) {document.body.innerHTML += '&lt;p&gt;' + msg + '&lt;/p&gt;';};\n\nvar funcs = {};\nfor (var i = 0; i &lt; 3; i++) {\n    var ilocal = i; //create a new local variable\n    funcs[i] = function() {\n        console.log(\"My value: \" + ilocal); //each should reference its own local variable\n    };\n}\nfor (var j = 0; j &lt; 3; j++) {\n    funcs[j]();\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>Just like before, where each inner function outputted the last value assigned to <code>i</code>, now each inner function just outputs the last value assigned to <code>ilocal</code>. But shouldn't each iteration have it's own <code>ilocal</code>?</p>\n<p>Turns out, that's the issue. Each iteration is sharing the same scope, so every iteration after the first is just overwriting <code>ilocal</code>. From <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block#No_block_scope\" rel=\"noreferrer\">MDN</a>:</p>\n<blockquote>\n<p>Important: JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script, and the effects of setting them persist beyond the block itself. In other words, block statements do not introduce a scope. Although &quot;standalone&quot; blocks are valid syntax, you do not want to use standalone blocks in JavaScript, because they don't do what you think they do, if you think they do anything like such blocks in C or Java.</p>\n</blockquote>\n<p>Reiterated for emphasis:</p>\n<blockquote>\n<h2>JavaScript does not have block scope. Variables introduced with a block are scoped to the containing function or script</h2>\n</blockquote>\n<p>We can see this by checking <code>ilocal</code> before we declare it in each iteration:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>//overwrite console.log() so you can see the console output\nconsole.log = function(msg) {document.body.innerHTML += '&lt;p&gt;' + msg + '&lt;/p&gt;';};\n\nvar funcs = {};\nfor (var i = 0; i &lt; 3; i++) {\n  console.log(ilocal);\n  var ilocal = i;\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>This is exactly why this bug is so tricky. Even though you are redeclaring a variable, Javascript won't throw an error, and JSLint won't even throw a warning. This is also why the best way to solve this is to take advantage of closures, which is essentially the idea that in Javascript, inner functions have access to outer variables because inner scopes &quot;enclose&quot; outer scopes.</p>\n<p><img src=\"https://i.stack.imgur.com/60fH9.png\" alt=\"Closures\" /></p>\n<p>This also means that inner functions &quot;hold onto&quot; outer variables and keep them alive, even if the outer function returns. To utilize this, we create and call a wrapper function purely to make a new scope, declare <code>ilocal</code> in the new scope, and return an inner function that uses <code>ilocal</code> (more explanation below):</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>//overwrite console.log() so you can see the console output\nconsole.log = function(msg) {document.body.innerHTML += '&lt;p&gt;' + msg + '&lt;/p&gt;';};\n\nvar funcs = {};\nfor (var i = 0; i &lt; 3; i++) {\n    funcs[i] = (function() { //create a new scope using a wrapper function\n        var ilocal = i; //capture i into a local var\n        return function() { //return the inner function\n            console.log(\"My value: \" + ilocal);\n        };\n    })(); //remember to run the wrapper function\n}\nfor (var j = 0; j &lt; 3; j++) {\n    funcs[j]();\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>Creating the inner function inside a wrapper function gives the inner function a private environment that only it can access, a &quot;closure&quot;. Thus, every time we call the wrapper function we create a new inner function with it's own separate environment, ensuring that the <code>ilocal</code> variables don't collide and overwrite each other. A few minor optimizations gives the final answer that many other SO users gave:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>//overwrite console.log() so you can see the console output\nconsole.log = function(msg) {document.body.innerHTML += '&lt;p&gt;' + msg + '&lt;/p&gt;';};\n\nvar funcs = {};\nfor (var i = 0; i &lt; 3; i++) {\n    funcs[i] = wrapper(i);\n}\nfor (var j = 0; j &lt; 3; j++) {\n    funcs[j]();\n}\n//creates a separate environment for the inner function\nfunction wrapper(ilocal) {\n    return function() { //return the inner function\n        console.log(\"My value: \" + ilocal);\n    };\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p><strong>Update</strong></p>\n<p>With ES6 now mainstream, we can now use the new <code>let</code> keyword to create block-scoped variables:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>//overwrite console.log() so you can see the console output\nconsole.log = function(msg) {document.body.innerHTML += '&lt;p&gt;' + msg + '&lt;/p&gt;';};\n\nvar funcs = {};\nfor (let i = 0; i &lt; 3; i++) { // use \"let\" to declare \"i\"\n    funcs[i] = function() {\n        console.log(\"My value: \" + i); //each should reference its own local variable\n    };\n}\nfor (var j = 0; j &lt; 3; j++) { // we can use \"var\" here without issue\n    funcs[j]();\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>Look how easy it is now! For more information see <a href=\"https://stackoverflow.com/a/16661498/1852456\">this answer</a>, which my info is based off of.</p>\n"},{"score":2,"body":"<p>This is a problem often encountered with asynchronous code, the variable <code>i</code> is mutable and at the time at which the function call is made the code using <code>i</code> will be executed and <code>i</code> will have mutated to its last value, thus meaning all functions created within the loop will create a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" rel=\"nofollow noreferrer\">closure</a> and <code>i</code> will be equal to 3 (the upper bound + 1 of the <code>for</code> loop.</p>\n\n<p>A workaround to this, is to create a function that will hold the value of <code>i</code> for each iteration and force a copy <code>i</code> (as it is a primitive, think of it as a snapshot if it helps you).</p>\n"},{"score":4,"body":"<p>You could use a declarative module for lists of data such as <a href=\"https://github.com/runefs/query-js\" rel=\"nofollow\">query-js</a>(*). In these situations I personally find a declarative approach less surprising</p>\n\n<pre><code>var funcs = Query.range(0,3).each(function(i){\n     return  function() {\n        console.log(\"My value: \" + i);\n    };\n});\n</code></pre>\n\n<p>You could then use your second loop and get the expected result or you could do </p>\n\n<pre><code>funcs.iterate(function(f){ f(); });\n</code></pre>\n\n<p>(*) I'm the author of query-js and therefor biased towards using it, so don't take my words as a recommendation for said library only for the declarative approach :)</p>\n"},{"score":4,"body":"<p>I prefer to use <code>forEach</code> function, which has its own closure with creating a pseudo range:</p>\n\n<pre><code>var funcs = [];\n\nnew Array(3).fill(0).forEach(function (_, i) { // creating a range\n    funcs[i] = function() {            \n        // now i is safely incapsulated \n        console.log(\"My value: \" + i);\n    };\n});\n\nfor (var j = 0; j &lt; 3; j++) {\n    funcs[j](); // 0, 1, 2\n}\n</code></pre>\n\n<p>That looks uglier than ranges in other languages, but IMHO less monstrous than other solutions.</p>\n"},{"score":4,"body":"<p>And yet another solution: instead of creating another loop, just bind the <code>this</code> to the return function.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = [];\r\n\r\nfunction createFunc(i) {\r\n  return function() {\r\n    console.log('My value: ' + i); //log value of i.\r\n  }.call(this);\r\n}\r\n\r\nfor (var i = 1; i &lt;= 5; i++) {  //5 functions\r\n  funcs[i] = createFunc(i);     // call createFunc() i=5 times\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>By binding <strong><em>this</em></strong>, solves the problem as well.</p>\n"},{"score":8,"body":"<p>First of all, understand what's wrong with this code:</p>\n\n<pre><code>var funcs = [];\nfor (var i = 0; i &lt; 3; i++) {          // let's create 3 functions\n    funcs[i] = function() {            // and store them in funcs\n        console.log(\"My value: \" + i); // each should log its value.\n    };\n}\nfor (var j = 0; j &lt; 3; j++) {\n    funcs[j]();                        // and now let's run each one to see\n}\n</code></pre>\n\n<p>Here when the <code>funcs[]</code> array is being initialized, <code>i</code> is being incremented, the <code>funcs</code> array is initialized and the size of <code>func</code> array becomes 3,  so <code>i = 3,</code>. \nNow when the <code>funcs[j]()</code> is called, it is again using the variable <code>i</code>, which has already been incremented to 3.</p>\n\n<p>Now to solve this, we have many options. Below are two of them:</p>\n\n<ol>\n<li><p>We can initialize <code>i</code> with <code>let</code> or initialize a new variable <code>index</code> with <code>let</code> and make it equal to <code>i</code>. So when the call is being made, <code>index</code> will be used and its scope will end after initialization. And for calling, <code>index</code> will be initialized again:</p>\n\n<pre><code>var funcs = [];\nfor (var i = 0; i &lt; 3; i++) {          \n    let index = i;\n    funcs[i] = function() {            \n        console.log(\"My value: \" + index); \n    };\n}\nfor (var j = 0; j &lt; 3; j++) {\n    funcs[j]();                        \n}\n</code></pre></li>\n<li><p>Other Option can be to introduce a <code>tempFunc</code> which returns the actual function:</p>\n\n<pre><code>var funcs = [];\nfunction tempFunc(i){\n    return function(){\n        console.log(\"My value: \" + i);\n    };\n}\nfor (var i = 0; i &lt; 3; i++) {  \n    funcs[i] = tempFunc(i);                                     \n}\nfor (var j = 0; j &lt; 3; j++) {\n    funcs[j]();                        \n}\n</code></pre></li>\n</ol>\n"},{"score":3,"body":"<p>Your code doesn't work, because what it does is:</p>\n\n<pre><code>Create variable `funcs` and assign it an empty array;  \nLoop from 0 up until it is less than 3 and assign it to variable `i`;\n    Push to variable `funcs` next function:  \n        // Only push (save), but don't execute\n        **Write to console current value of variable `i`;**\n\n// First loop has ended, i = 3;\n\nLoop from 0 up until it is less than 3 and assign it to variable `j`;\n    Call `j`-th function from variable `funcs`:  \n        **Write to console current value of variable `i`;**  \n        // Ask yourself NOW! What is the value of i?\n</code></pre>\n\n<p>Now the question is, what is the value of variable <code>i</code> when the function is called? Because the first loop is created with the condition of <code>i &lt; 3</code>, it stops immediately when the condition is false, so it is <code>i = 3</code>. </p>\n\n<p>You need to understand that, in time when your functions are created, none of their code is executed, it is only saved for later. And so when they are called later, the interpreter executes them and asks: \"What is the current value of <code>i</code>?\"</p>\n\n<p>So, your goal is to first save the value of <code>i</code> to function and only after that save the function to <code>funcs</code>. This could be done for example this way:</p>\n\n<pre><code>var funcs = [];\nfor (var i = 0; i &lt; 3; i++) {          // let's create 3 functions\n    funcs[i] = function(x) {            // and store them in funcs\n        console.log(\"My value: \" + x); // each should log its value.\n    }.bind(null, i);\n}\nfor (var j = 0; j &lt; 3; j++) {\n    funcs[j]();                        // and now let's run each one to see\n}\n</code></pre>\n\n<p>This way, each function will have it's own variable <code>x</code> and we set this <code>x</code> to the value of <code>i</code> in each iteration.</p>\n\n<p>This is only one of the multiple ways to solve this problem.</p>\n"},{"score":13,"body":"<p>With new features of ES6 block level scoping is managed:</p>\n\n<pre><code>var funcs = [];\nfor (let i = 0; i &lt; 3; i++) {          // let's create 3 functions\n    funcs[i] = function() {            // and store them in funcs\n        console.log(\"My value: \" + i); // each should log its value.\n    };\n}\nfor (let j = 0; j &lt; 3; j++) {\n    funcs[j]();                        // and now let's run each one to see\n}\n</code></pre>\n\n<p>The code in OP's question is replaced with <strong><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/let\" rel=\"noreferrer\"><code>let</code></a></strong> instead of <strong><code>var</code></strong>.</p>\n"},{"score":0,"body":"<p>Let's take advantage of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function\" rel=\"nofollow noreferrer\"><code>new Function</code></a>. Thus <code>i</code> stops to be a variable of a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" rel=\"nofollow noreferrer\">closure</a> and becomes just a part of the text:</p>\n\n<pre><code>var funcs = [];\nfor (var i = 0; i &lt; 3; i++) {\n    var functionBody = 'console.log(\"My value: ' + i + '\");';\n    funcs[i] = new Function(functionBody);\n}\n\nfor (var j = 0; j &lt; 3; j++) {\n    funcs[j]();\n}\n</code></pre>\n"},{"score":24,"body":"<p>JavaScript functions \"close over\" the scope they have access to upon declaration, and retain access to that scope even as variables in that scope change.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = []\r\n\r\nfor (var i = 0; i &lt; 3; i += 1) {\r\n  funcs[i] = function () {\r\n    console.log(i)\r\n  }\r\n}\r\n\r\nfor (var k = 0; k &lt; 3; k += 1) {\r\n  funcs[k]()\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Each function in the array above closes over the global scope (global, simply because that happens to be the scope they're declared in).</p>\n\n<p>Later those functions are invoked logging the most current value of <code>i</code> in the global scope. That's the magic, and frustration, of closure.</p>\n\n<p><strong>\"JavaScript Functions close over the scope they are declared in, and retain access to that scope even as variable values inside of that scope change.\"</strong></p>\n\n<p>Using <code>let</code> instead of <code>var</code> solves this by creating a new scope each time the <code>for</code> loop runs, creating a separated scope for each function to close over. Various other techniques do the same thing with extra functions.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = []\r\n\r\nfor (let i = 0; i &lt; 3; i += 1) {\r\n  funcs[i] = function () {\r\n    console.log(i)\r\n  }\r\n}\r\n\r\nfor (var k = 0; k &lt; 3; k += 1) {\r\n  funcs[k]()\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>(<code>let</code> makes variables block scoped. Blocks are denoted by curly braces, but in the case of the for loop the initialization variable, <code>i</code> in our case, is considered to be declared in the braces.)</p>\n"},{"score":8,"body":"<p>Use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" rel=\"noreferrer\">closure</a> structure, this would reduce your extra for loop. You can do it in a single for loop:</p>\n\n<pre><code>var funcs = [];\nfor (var i = 0; i &lt; 3; i++) {     \n  (funcs[i] = function() {         \n    console.log(\"My value: \" + i); \n  })(i);\n}\n</code></pre>\n"},{"score":3,"body":"<p>Many solutions seem correct but they don't mention it's called <a href=\"https://www.sitepoint.com/currying-in-functional-javascript/\" rel=\"nofollow noreferrer\"><code>Currying</code></a> which is a functional programming design pattern for situations like here. 3-10 times faster than bind depending on the browser.</p>\n\n<pre><code>var funcs = [];\nfor (var i = 0; i &lt; 3; i++) {      // let's create 3 functions\n  funcs[i] = curryShowValue(i);\n}\nfor (var j = 0; j &lt; 3; j++) {\n  funcs[j]();                      // and now let's run each one to see\n}\n\nfunction curryShowValue(i) {\n  return function showValue() {\n    console.log(\"My value: \" + i);\n  }\n}\n</code></pre>\n\n<p>See <a href=\"https://jsperf.com/bind-vs-curry\" rel=\"nofollow noreferrer\">the performance gain in different browsers</a>.</p>\n"},{"score":2,"body":"<p><strong>COUNTER BEING A PRIMITIVE</strong></p>\n\n<p>Let's define callback functions as follows:</p>\n\n<pre><code>// ****************************\n// COUNTER BEING A PRIMITIVE\n// ****************************\nfunction test1() {\n    for (var i=0; i&lt;2; i++) {\n        setTimeout(function() {\n            console.log(i);\n        });\n    }\n}\ntest1();\n// 2\n// 2\n</code></pre>\n\n<p>After timeout completes it will print 2 for both. This is because the callback function accesses the value based on the <a href=\"https://stackoverflow.com/q/1047454/7032856\">lexical scope</a>, where it was function was defined.</p>\n\n<p>To pass and preserve the value while callback was defined, we can create a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\" rel=\"nofollow noreferrer\">closure</a>, to preserve the value before the callback is invoked. This can be done as follows:</p>\n\n<pre><code>function test2() {\n    function sendRequest(i) {\n        setTimeout(function() {\n            console.log(i);\n        });\n    }\n\n    for (var i = 0; i &lt; 2; i++) {\n        sendRequest(i);\n    }\n}\ntest2();\n// 1\n// 2\n</code></pre>\n\n<p>Now what's special about this is \"The primitives are passed by value and copied. Thus when the closure is defined, they keep the value from the previous loop.\"</p>\n\n<p><strong>COUNTER BEING AN OBJECT</strong></p>\n\n<p>Since closures have access to parent function variables via reference, this approach would differ from that for primitives.</p>\n\n<pre><code>// ****************************\n// COUNTER BEING AN OBJECT\n// ****************************\nfunction test3() {\n    var index = { i: 0 };\n    for (index.i=0; index.i&lt;2; index.i++) {\n        setTimeout(function() {\n            console.log('test3: ' + index.i);\n        });\n    }\n}\ntest3();\n// 2\n// 2\n</code></pre>\n\n<p>So, even if a closure is created for the variable being passed as an object, the value of the loop index will not be preserved. This is to show that the values of an object are not copied whereas they are accessed via reference.</p>\n\n<pre><code>function test4() {\n    var index = { i: 0 };\n    function sendRequest(index, i) {\n        setTimeout(function() {\n            console.log('index: ' + index);\n            console.log('i: ' + i);\n            console.log(index[i]);\n        });\n    }\n\n    for (index.i=0; index.i&lt;2; index.i++) {\n        sendRequest(index, index.i);\n    }\n}\ntest4();\n// index: { i: 2}\n// 0\n// undefined\n\n// index: { i: 2}\n// 1\n// undefined\n</code></pre>\n"},{"score":-2,"body":"<p>Already many valid answers to this question. Not many using a functional approach though. Here is an alternative solution using the <code>forEach</code> method, which works well with callbacks and closures:</p>\n\n<p><code>let arr = [1,2,3];</code></p>\n\n<p><code>let myFunc = (val, index) =&gt; { \n    console.log('val: '+val+'\\nindex: '+index);\n};</code></p>\n\n<p><code>arr.forEach(myFunc);</code></p>\n"},{"score":9,"body":"<p>This question really shows the history of JavaScript! Now we can avoid block scoping with arrow functions and handle loops directly from DOM nodes using Object methods.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const funcs = [1, 2, 3].map(i =&gt; () =&gt; console.log(i));\r\nfuncs.map(fn =&gt; fn())</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const buttons = document.getElementsByTagName(\"button\");\r\nObject\r\n  .keys(buttons)\r\n  .map(i =&gt; buttons[i].addEventListener('click', () =&gt; console.log(i)));</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;button&gt;0&lt;/button&gt;&lt;br&gt;\r\n&lt;button&gt;1&lt;/button&gt;&lt;br&gt;\r\n&lt;button&gt;2&lt;/button&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":7,"body":"<blockquote>\n  <p>We will check , what actually happens when you declare <code>var</code> and <code>let</code>\n  one by one.</p>\n</blockquote>\n\n<h2><strong>Case1</strong> : <strong>using <code>var</code></strong></h2>\n\n<pre><code>&lt;script&gt;\n   var funcs = [];\n   for (var i = 0; i &lt; 3; i++) {\n     funcs[i] = function () {\n        debugger;\n        console.log(\"My value: \" + i);\n     };\n   }\n   console.log(funcs);\n&lt;/script&gt;\n</code></pre>\n\n<p>Now open your <strong>chrome console window</strong> by pressing <strong>F12</strong> and refresh the page.\nExpend every 3 functions inside the array.You will see an property called <code>[[Scopes]]</code>.Expand that one. You will see one \narray object called <code>\"Global\"</code>,expand that one. You will find a property <code>'i'</code> declared into the object which having value 3.</p>\n\n<p><a href=\"https://i.stack.imgur.com/f6I2J.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/f6I2J.png\" alt=\"enter image description here\"></a></p>\n\n<p><a href=\"https://i.stack.imgur.com/kF3Yv.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/kF3Yv.png\" alt=\"enter image description here\"></a></p>\n\n<p><strong>Conclusion:</strong> </p>\n\n<ol>\n<li>When you declare a variable using <code>'var'</code> outside a function ,it becomes global variable(you can check by typing <code>i</code> or \n<code>window.i</code> in console window.It will return 3).</li>\n<li>The annominous function you declared will not call and check the value inside the function unless you invoke the \nfunctions.</li>\n<li>When you invoke the function , <code>console.log(\"My value: \" + i)</code> takes the value from its <code>Global</code> object and display the \nresult.</li>\n</ol>\n\n<h2><strong>CASE2 : using let</strong></h2>\n\n<p>Now replace the <code>'var'</code> with <code>'let'</code></p>\n\n<pre><code>&lt;script&gt;\n    var funcs = [];\n    for (let i = 0; i &lt; 3; i++) {\n        funcs[i] = function () {\n           debugger;\n           console.log(\"My value: \" + i);\n        };\n    }\n    console.log(funcs);\n&lt;/script&gt;\n</code></pre>\n\n<p>Do the same thing, Go to the scopes . Now you will see two objects <code>\"Block\"</code> and <code>\"Global\"</code>. Now expand <code>Block</code> object , you \nwill see 'i' is defined there , and the strange thing is that , for every functions , the value if <code>i</code> is different (0 , 1, 2). </p>\n\n<p><a href=\"https://i.stack.imgur.com/HGqXU.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/HGqXU.png\" alt=\"enter image description here\"></a></p>\n\n<p><strong>Conclusion:</strong></p>\n\n<p>When you declare variable using <code>'let'</code> even outside the function but inside the loop , this variable will not be a Global \nvariable , it will become a <code>Block</code> level variable which is only available for the same function only.That is the reason , we \nare getting value of <code>i</code> different for each function when we invoke the functions.</p>\n\n<p>For more detail about how closer works , please go through the awesome video tutorial <a href=\"https://youtu.be/71AtaJpJHw0\" rel=\"noreferrer\">https://youtu.be/71AtaJpJHw0</a></p>\n"},{"score":0,"body":"<p>While this question is old and answered,  I have yet another fairly interesting solution:</p>\n\n<pre><code>var funcs = [];\n\nfor (var i = 0; i &lt; 3; i++) {     \n  funcs[i] = function() {          \n    console.log(\"My value: \" + i); \n };\n}\n\nfor (var i = 0; i &lt; 3; i++) {\n  funcs[i]();\n}\n</code></pre>\n\n<p>The change is so small it's almost difficult to see what I did. I switched the second iterator from a j to an i. This somehow refreshes the state of i in time to give you the desired result. I did this by accident but it makes sense considering previous answers.</p>\n\n<p>I wrote this up to point out this small, yet very important difference. Hope that helps to clear up some confusion for other learners like me.</p>\n\n<p>Note: I am not sharing this because I think it's the right answer. This is a flakey solution that probably will break under certain circumstances. Actually, I'm quite amazed that it really works.</p>\n"},{"score":0,"body":"<p>Let's say you don't use es6;\nYou can use IFFY function:</p>\n\n<pre><code>var funcs = [];\nfor (var i = 0; i &lt; 13; i++) {      \nfuncs[i] = (function(x) {\nconsole.log(\"My value: \" + i)})(i);}\n</code></pre>\n\n<p>But it will be different.</p>\n"},{"score":0,"body":"<p>Ok. I read through all of the answers. Even though there is a good explanation here - I just could not get this to work. So I went looking on the internet. The person at <a href=\"https://dzone.com/articles/why-does-javascript-loop-only-use-last-value\" rel=\"nofollow noreferrer\">https://dzone.com/articles/why-does-javascript-loop-only-use-last-value</a> had an answer which is not presented here. So I thought I'd post a short example. This made a lot more sense to me.</p>\n\n<p>The long and short of it is that the LET command is nice but is only now being used. HOWEVER, the LET command is really just a TRY-CATCH combo. This works all the way back to IE3 (I believe). Using the TRY-CATCH combo - life is simple and good. Probably why the EMCScript people decided to use it. It also does not need a setTimeout() function. So no time is lost. Basically, you need one TRY-CATCH combo per FOR loop. Here is an example:</p>\n\n<pre><code>    for( var i in myArray ){\n       try{ throw i }\n       catch(ii){\n// Do whatever it is you want to do with ii\n          }\n       }\n</code></pre>\n\n<p>If you have more than one FOR loop, you just put a TRY-CATCH combo for each one. Also, personally, I always use the double letter of whatever FOR variable I am using. So \"ii\" for \"i\" and so on. I am using this technique in a routine to send mouseover commands to a different routine.</p>\n"},{"score":-1,"body":"<p>Why not simply call each function inside the first (and only) loop just after they were created, such as:</p>\n\n<pre><code> var funcs = [];\n    for (var i = 0; i &lt; 3; i++) {\n    // let's create 3 functions\n    funcs[i] = function() {\n    // and store them in funcs\n    console.log(\"My value: \" + i); // each should log its value.\n    };\n    funcs[i]();// and now let's run each one to see\n    }\n</code></pre>\n"},{"score":3,"body":"<pre><code>var funcs = [];\nfor (var i = 0; i &lt; 3; i++) {      // let's create 3 functions\n  funcs[i] = function(param) {          // and store them in funcs\n    console.log(\"My value: \" + param); // each should log its value.\n  };\n}\nfor (var j = 0; j &lt; 3; j++) {\n  funcs[j](j);                      // and now let's run each one to see with j\n}\n</code></pre>\n"},{"score":0,"body":"<p>This proves how ugly javascript is with regard to how 'closure' and 'non-closure' works.</p>\n\n<p>In the case of:</p>\n\n<pre><code>var funcs = [];\n\nfor (var i = 0; i &lt; 3; i++) {      // let's create 3 functions\n  funcs[i] = function() {          // and store them in funcs\n    console.log(\"My value: \" + i); // each should log its value.\n  };\n}\n</code></pre>\n\n<p>funcs[i] is a global function, and 'console.log(\"My value: \" + i);' is printing global variable i</p>\n\n<p>In the case of </p>\n\n<pre><code>var funcs = [];\n\nfunction createfunc(i) {\n    return function() { console.log(\"My value: \" + i); };\n}\n\nfor (var i = 0; i &lt; 3; i++) {\n    funcs[i] = createfunc(i);\n}\n</code></pre>\n\n<p>because of this twisted closure design of javascript, 'console.log(\"My value: \" + i);' is printing the i from outer function 'createfunc(i)'</p>\n\n<p>all because javascript can not design something decent like the 'static' variable inside a function like what C programming language is doing!</p>\n"},{"score":1,"body":"<p>Just change the var keyword to let. </p>\n\n<p>var is function scoped.</p>\n\n<p>let is block scoped.</p>\n\n<p>When you start you code the for loop will iterate and assign the value of i to 3, which will remain 3 throughout your code. I suggest you to read more about scopes in node (let,var,const and others)</p>\n\n<pre><code>funcs = [];\nfor (let i = 0; i &lt; 3; i++) {      // let's create 3 functions\n  funcs[i] =async function() {          // and store them in funcs\n    await console.log(\"My value: \" + i); // each should log its value.\n  };\n}\nfor (var j = 0; j &lt; 3; j++) {\n  funcs[j]();                      // and now let's run each one to see\n}\n</code></pre>\n"},{"score":0,"body":"<pre><code>  asyncIterable = [1,2,3,4,5,6,7,8];\n\n  (async function() {\n       for await (let num of asyncIterable) {\n         console.log(num);\n       }\n    })();\n</code></pre>\n"},{"score":3,"body":"<p>Use let(blocked-scope) instead of var.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = [];\r\nfor (let i = 0; i &lt; 3; i++) {      \r\n  funcs[i] = function() {          \r\n    console.log(\"My value: \" + i); \r\n  };\r\n}\r\nfor (var j = 0; j &lt; 3; j++) {\r\n  funcs[j]();                      \r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":0,"body":"<p>With the support of <code>ES6</code>, the best way to this is to use <code>let</code> and <code>const</code> keywords for this exact circumstance. So <code>var</code> variable get <code>hoisted</code> and with the end of loop the value of <code>i</code> gets updated for all the <code>closures</code>..., we can just use <code>let</code> to set a loop scope variable like this:</p>\n\n<pre><code>var funcs = [];\nfor (let i = 0; i &lt; 3; i++) {          \n    funcs[i] = function() {            \n      console.log(\"My value: \" + i); \n    };\n}\n</code></pre>\n"},{"score":4,"body":"<p>Till ES5, This problem can only be solved using <strong>closure</strong>.</p>\n\n<p>But now in ES6, we have block level scope variables. Changing <strong>var</strong> to <strong>let</strong> in first <strong>for loop</strong> will solve the problem.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var funcs = [];\r\nfor (let i = 0; i &lt; 3; i++) {      // let's create 3 functions\r\n  funcs[i] = function() {          // and store them in funcs\r\n    console.log(\"My value: \" + i); // each should log its value.\r\n  };\r\n}\r\nfor (var j = 0; j &lt; 3; j++) {\r\n  funcs[j]();                      // and now let's run each one to see\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":3,"body":"<p>If you're having this sort of problem with a <code>while</code> loop, rather than a <code>for</code> loop, for example:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var i = 0;\nwhile (i &lt; 5) {\n  setTimeout(function() {\n    console.log(i);\n  }, i * 1000);\n  i++;\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>The technique to close over the current value is a bit different. Declare a block-scoped variable with <code>const</code> inside the <code>while</code> block, and assign the current <code>i</code> to it. Then, wherever the variable is being used asynchronously, replace <code>i</code> with the new block-scoped variable:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var i = 0;\nwhile (i &lt; 5) {\n  const thisIterationI = i;\n  setTimeout(function() {\n    console.log(thisIterationI);\n  }, i * 1000);\n  i++;\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>For older browsers that don't support block-scoped variables, you can use an IIFE called with <code>i</code>:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var i = 0;\nwhile (i &lt; 5) {\n  (function(innerI) {\n    setTimeout(function() {\n      console.log(innerI);\n    }, innerI * 1000);\n  })(i);\n  i++;\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>If the asynchronous action to be invoked happens to be <code>setTimeout</code> like the above, you can also call <code>setTimeout</code> with a <em>third</em> parameter to indicate the argument to call the passed function with:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var i = 0;\nwhile (i &lt; 5) {\n  setTimeout(\n    (thisIterationI) =&gt; { // Callback\n      console.log(thisIterationI);\n    },\n    i * 1000, // Delay\n    i // Gets passed to the callback; becomes thisIterationI\n  );\n  i++;\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"}],"score":2917}