{"body":"<p>What is the difference between using <code>call</code> and <code>apply</code> to invoke a function?</p>\n\n<pre><code>var func = function() {\n  alert('hello!');\n};\n</code></pre>\n\n<p><code>func.apply();</code> vs <code>func.call();</code></p>\n\n<p>Are there performance differences between the two aforementioned methods? When is it best to use <code>call</code> over <code>apply</code> and vice versa?</p>\n","title":"What is the difference between call and apply?","answers":[{"score":236,"body":"<p>K. Scott Allen has <a href=\"http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx\" rel=\"noreferrer\">a nice writeup</a> on the matter.</p>\n\n<p>Basically, they differ on how they handle function arguments.  </p>\n\n<blockquote>\n  <p>The apply() method is identical to call(), except apply() requires an array as the second parameter. The array represents the arguments for the target method.\"</p>\n</blockquote>\n\n<p>So:</p>\n\n<pre><code>// assuming you have f\nfunction f(message) { ... }\nf.call(receiver, \"test\");\nf.apply(receiver, [\"test\"]);\n</code></pre>\n"},{"score":3718,"body":"<p>The difference is that <code>apply</code> lets you invoke the function with <code>arguments</code> as an array; <code>call</code> requires the parameters be listed explicitly. A useful mnemonic is <em>\"<strong>A</strong> for <strong>a</strong>rray and <strong>C</strong> for <strong>c</strong>omma.\"</em></p>\n\n<p>See MDN's documentation on <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/apply\" rel=\"noreferrer\">apply</a> and <a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/call\" rel=\"noreferrer\">call</a>.</p>\n\n<p>Pseudo syntax:</p>\n\n<p><code>theFunction.apply(valueForThis, arrayOfArgs)</code></p>\n\n<p><code>theFunction.call(valueForThis, arg1, arg2, ...)</code></p>\n\n<p>There is also, as of ES6, the possibility to <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator\" rel=\"noreferrer\"><code>spread</code></a> the array for use with the <code>call</code> function, you can see the compatibilities <a href=\"http://kangax.github.io/compat-table/es6/\" rel=\"noreferrer\">here</a>.</p>\n\n<p>Sample code:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function theFunction(name, profession) {\r\n    console.log(\"My name is \" + name + \" and I am a \" + profession +\".\");\r\n}\r\ntheFunction(\"John\", \"fireman\");\r\ntheFunction.apply(undefined, [\"Susan\", \"school teacher\"]);\r\ntheFunction.call(undefined, \"Claude\", \"mathematician\");\r\ntheFunction.call(undefined, ...[\"Matthew\", \"physicist\"]); // used with the spread operator</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":164,"body":"<p>To answer the part about when to use each function, use <code>apply</code> if you don't know the number of arguments you will be passing, or if they are already in an array or array-like object (like the <code>arguments</code> object to forward your own arguments. Use <code>call</code> otherwise, since there's no need to wrap the arguments in an array.</p>\n\n<pre><code>f.call(thisObject, a, b, c); // Fixed number of arguments\n\nf.apply(thisObject, arguments); // Forward this function's arguments\n\nvar args = [];\nwhile (...) {\n    args.push(some_value());\n}\nf.apply(thisObject, args); // Unknown number of arguments\n</code></pre>\n\n<p>When I'm not passing any arguments (like your example), I prefer <code>call</code> since I'm <em>calling</em> the function. <code>apply</code> would imply you are <em>applying</em> the function to the (non-existent) arguments.</p>\n\n<p>There shouldn't be any performance differences, except maybe if you use <code>apply</code> and wrap the arguments in an array (e.g. <code>f.apply(thisObject, [a, b, c])</code> instead of <code>f.call(thisObject, a, b, c)</code>). I haven't tested it, so there could be differences, but it would be very browser specific. It's likely that <code>call</code> is faster if you don't already have the arguments in an array and <code>apply</code> is faster if you do.</p>\n"},{"score":94,"body":"<p>While this is an old topic, I just wanted to point out that .call is slightly faster than .apply. I can't tell you exactly why.</p>\n\n<p>See jsPerf, <a href=\"http://jsperf.com/test-call-vs-apply/3\" rel=\"noreferrer\">http://jsperf.com/test-call-vs-apply/3</a></p>\n\n<hr>\n\n<p>[<code>UPDATE!</code>]</p>\n\n<p>Douglas Crockford mentions briefly the difference between the two, which may help explain the performance difference... <a href=\"http://youtu.be/ya4UHuXNygM?t=15m52s\" rel=\"noreferrer\">http://youtu.be/ya4UHuXNygM?t=15m52s</a></p>\n\n<p>Apply takes an array of arguments, while Call takes zero or more individual parameters! Ah hah!</p>\n\n<p><code>.apply(this, [...])</code></p>\n\n<p><code>.call(this, param1, param2, param3, param4...)</code></p>\n"},{"score":23,"body":"<p>I'd like to show an example, where the 'valueForThis' argument is used:</p>\n\n<pre><code>Array.prototype.push = function(element) {\n   /*\n   Native code*, that uses 'this'       \n   this.put(element);\n   */\n}\nvar array = [];\narray.push(1);\narray.push.apply(array,[2,3]);\nArray.prototype.push.apply(array,[4,5]);\narray.push.call(array,6,7);\nArray.prototype.push.call(array,8,9);\n//[1, 2, 3, 4, 5, 6, 7, 8, 9] \n</code></pre>\n\n<p>**details: <a href=\"http://es5.github.io/#x15.4.4.7\" rel=\"noreferrer\">http://es5.github.io/#x15.4.4.7</a>*</p>\n"},{"score":115,"body":"<p>Here's a good mnemonic.  <b>A</b>pply uses <b>A</b>rrays and <b>A</b>lways takes one or two Arguments.  When you use <b>C</b>all you have to <b>C</b>ount the number of arguments.</p>\n"},{"score":6,"body":"<p>We can differentiate call and apply methods as below</p>\n\n<p>CALL : A function with argument provide individually.\nIf you know the arguments to be passed or there are no argument to pass you can use call.</p>\n\n<p>APPLY : Call a function with argument provided as an array. You can use apply if you don't know how many argument are going to pass to the function.</p>\n\n<p>There is a advantage of using apply over call, we don't need to change the number of argument only we can change a array that is passed.</p>\n\n<p>There is not big difference in performance. But we can say call is bit faster as compare to apply because an array need to evaluate in apply method.</p>\n"},{"score":77,"body":"<p>Follows an extract from <a href=\"https://rads.stackoverflow.com/amzn/click/com/1449381871\" rel=\"noreferrer\" rel=\"nofollow noreferrer\">Closure: The Definitive Guide by Michael Bolin</a>. It might look a bit lengthy, but it's saturated with a lot of insight. From \"Appendix B. Frequently Misunderstood JavaScript Concepts\":</p>\n\n<hr>\n\n<h1>What <code>this</code> Refers to When a Function is Called</h1>\n\n<p>When calling a function of the form <code>foo.bar.baz()</code>, the object <code>foo.bar</code> is referred to as the receiver. When the function is called, it is the receiver that is used as the value for <code>this</code>:</p>\n\n<pre><code>var obj = {};\nobj.value = 10;\n/** @param {...number} additionalValues */\nobj.addValues = function(additionalValues) {\n  for (var i = 0; i &lt; arguments.length; i++) {\n    this.value += arguments[i];\n  }\n  return this.value;\n};\n// Evaluates to 30 because obj is used as the value for 'this' when\n// obj.addValues() is called, so obj.value becomes 10 + 20.\nobj.addValues(20);\n</code></pre>\n\n<p>If there is no explicit receiver when a function is called, then the global object becomes the receiver. As explained in \"goog.global\" on page 47, window is the global object when JavaScript is executed in a web browser. This leads to some surprising behavior:</p>\n\n<pre><code>var f = obj.addValues;\n// Evaluates to NaN because window is used as the value for 'this' when\n// f() is called. Because and window.value is undefined, adding a number to\n// it results in NaN.\nf(20);\n// This also has the unintentional side effect of adding a value to window:\nalert(window.value); // Alerts NaN\n</code></pre>\n\n<p>Even though <code>obj.addValues</code> and <code>f</code> refer to the same function, they behave differently when called because the value of the receiver is different in each call. For this reason, when calling a function that refers to <code>this</code>, it is important to ensure that <code>this</code> will have the correct value when it is called. To be clear, if <code>this</code> were not referenced in the function body, then the behavior of <code>f(20)</code> and <code>obj.addValues(20)</code> would be the same.</p>\n\n<p>Because functions are first-class objects in JavaScript, they can have their own methods. All functions have the methods <code>call()</code> and <code>apply()</code> which make it possible to redefine the receiver (i.e., the object that <code>this</code> refers to) when calling the function. The method signatures are as follows:</p>\n\n<pre><code>/**\n* @param {*=} receiver to substitute for 'this'\n* @param {...} parameters to use as arguments to the function\n*/\nFunction.prototype.call;\n/**\n* @param {*=} receiver to substitute for 'this'\n* @param {Array} parameters to use as arguments to the function\n*/\nFunction.prototype.apply;\n</code></pre>\n\n<p>Note that the only difference between <code>call()</code> and <code>apply()</code> is that <code>call()</code> receives the function parameters as individual arguments, whereas <code>apply()</code> receives them as a single array:</p>\n\n<pre><code>// When f is called with obj as its receiver, it behaves the same as calling\n// obj.addValues(). Both of the following increase obj.value by 60:\nf.call(obj, 10, 20, 30);\nf.apply(obj, [10, 20, 30]);\n</code></pre>\n\n<p>The following calls are equivalent, as <code>f</code> and <code>obj.addValues</code> refer to the same function:</p>\n\n<pre><code>obj.addValues.call(obj, 10, 20, 30);\nobj.addValues.apply(obj, [10, 20, 30]);\n</code></pre>\n\n<p>However, since neither <code>call()</code> nor <code>apply()</code> uses the value of its own receiver to substitute for the receiver argument when it is unspecified, the following will not work:</p>\n\n<pre><code>// Both statements evaluate to NaN\nobj.addValues.call(undefined, 10, 20, 30);\nobj.addValues.apply(undefined, [10, 20, 30]);\n</code></pre>\n\n<p>The value of <code>this</code> can never be <code>null</code> or <code>undefined</code> when a function is called. When <code>null</code> or <code>undefined</code> is supplied as the receiver to <code>call()</code> or <code>apply()</code>, the global object is used as the value for receiver instead. Therefore, the previous code has the same undesirable side effect of adding a property named <code>value</code> to the global object.</p>\n\n<p>It may be helpful to think of a function as having no knowledge of the variable to which it is assigned. This helps reinforce the idea that the value of this will be bound when the function is called rather than when it is defined.</p>\n\n<hr>\n\n<p>End of extract.</p>\n"},{"score":10,"body":"<p>Here's a small-ish post, I wrote on this:</p>\n\n<p><a href=\"http://sizeableidea.com/call-versus-apply-javascript/\" rel=\"noreferrer\">http://sizeableidea.com/call-versus-apply-javascript/</a></p>\n\n<pre><code>var obj1 = { which : \"obj1\" },\nobj2 = { which : \"obj2\" };\n\nfunction execute(arg1, arg2){\n    console.log(this.which, arg1, arg2);\n}\n\n//using call\nexecute.call(obj1, \"dan\", \"stanhope\");\n//output: obj1 dan stanhope\n\n//using apply\nexecute.apply(obj2, [\"dan\", \"stanhope\"]);\n//output: obj2 dan stanhope\n\n//using old school\nexecute(\"dan\", \"stanhope\");\n//output: undefined \"dan\" \"stanhope\"\n</code></pre>\n"},{"score":21,"body":"<p>Call() takes comma-separated arguments, ex: </p>\n\n<p><code>.call(scope, arg1, arg2, arg3)</code> </p>\n\n<p>and apply() takes an array of arguments, ex: </p>\n\n<p><code>.apply(scope, [arg1, arg2, arg3])</code> </p>\n\n<p>here are few more usage examples: \n<a href=\"http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/\">http://blog.i-evaluation.com/2012/08/15/javascript-call-and-apply/</a></p>\n"},{"score":35,"body":"<p>It is useful at times for one object to borrow the function of another object, meaning that the borrowing object simply executes the lent function as if it were its own.  </p>\n\n<p><strong>A small code example:</strong></p>\n\n<pre><code>var friend = {\n    car: false,\n    lendCar: function ( canLend ){\n      this.car = canLend;\n }\n\n}; \n\nvar me = {\n    car: false,\n    gotCar: function(){\n      return this.car === true;\n  }\n};\n\nconsole.log(me.gotCar()); // false\n\nfriend.lendCar.call(me, true); \n\nconsole.log(me.gotCar()); // true\n\nfriend.lendCar.apply(me, [false]);\n\nconsole.log(me.gotCar()); // false\n</code></pre>\n\n<p>These methods are very useful for giving objects temporary functionality.</p>\n"},{"score":12,"body":"<p>Fundamental difference is that <code>call()</code> accepts an <strong><em>argument list</em></strong>, while <code>apply()</code> accepts a <strong><em>single array of arguments</em></strong>.</p>\n"},{"score":4,"body":"<p>Even though <code>call</code> and <code>apply</code> achive the same thing, I think there is atleast one place where you cannot use <code>call</code> but can only use <code>apply</code>. That is when you want to support inheritance and want to call the constructor.</p>\n\n<p>Here is a function allows you to create classes which also supports creating classes by extending other classes.</p>\n\n<pre><code>function makeClass( properties ) {\n    var ctor = properties['constructor'] || function(){}\n    var Super = properties['extends'];\n    var Class = function () {\n                 // Here 'call' cannot work, only 'apply' can!!!\n                 if(Super)\n                    Super.apply(this,arguments);  \n                 ctor.apply(this,arguments);\n                }\n     if(Super){\n        Class.prototype = Object.create( Super.prototype );\n        Class.prototype.constructor = Class;\n     }\n     Object.keys(properties).forEach( function(prop) {\n           if(prop!=='constructor' &amp;&amp; prop!=='extends')\n            Class.prototype[prop] = properties[prop];\n     });\n   return Class; \n}\n\n//Usage\nvar Car = makeClass({\n             constructor: function(name){\n                         this.name=name;\n                        },\n             yourName: function() {\n                     return this.name;\n                   }\n          });\n//We have a Car class now\n var carInstance=new Car('Fiat');\ncarInstance.youName();// ReturnsFiat\n\nvar SuperCar = makeClass({\n               constructor: function(ignore,power){\n                     this.power=power;\n                  },\n               extends:Car,\n               yourPower: function() {\n                    return this.power;\n                  }\n              });\n//We have a SuperCar class now, which is subclass of Car\nvar superCar=new SuperCar('BMW xy',2.6);\nsuperCar.yourName();//Returns BMW xy\nsuperCar.yourPower();// Returns 2.6\n</code></pre>\n"},{"score":26,"body":"<p>Another example with Call, Apply and Bind.\nThe difference between Call and Apply is evident, but <strong>Bind</strong> works like this:</p>\n\n<ol>\n<li>Bind returns an instance of a function that can be executed</li>\n<li>First Parameter is '<em>this</em>'</li>\n<li>Second parameter is a <em>Comma separated</em> list of arguments (like <em>Call</em>)</li>\n</ol>\n\n<p>} </p>\n\n<pre><code>function Person(name) {\n    this.name = name; \n}\nPerson.prototype.getName = function(a,b) { \n     return this.name + \" \" + a + \" \" + b; \n}\n\nvar reader = new Person('John Smith');\n\nreader.getName = function() {\n   // Apply and Call executes the function and returns value\n\n   // Also notice the different ways of extracting 'getName' prototype\n   var baseName = Object.getPrototypeOf(this).getName.apply(this,[\"is a\", \"boy\"]);\n   console.log(\"Apply: \" + baseName);\n\n   var baseName = Object.getPrototypeOf(reader).getName.call(this, \"is a\", \"boy\"); \n   console.log(\"Call: \" + baseName);\n\n   // Bind returns function which can be invoked\n   var baseName = Person.prototype.getName.bind(this, \"is a\", \"boy\"); \n   console.log(\"Bind: \" + baseName());\n}\n\nreader.getName();\n/* Output\nApply: John Smith is a boy\nCall: John Smith is a boy\nBind: John Smith is a boy\n*/\n</code></pre>\n"},{"score":5,"body":"<p>Difference between these to methods are, how you want to pass the parameters.</p>\n\n<p>“A for array and C for comma” is a handy mnemonic.</p>\n"},{"score":5,"body":"<p>Call and apply both are used to force the <code>this</code> value when a function is executed. The only difference is that <code>call</code> takes <code>n+1</code> arguments where 1 is <code>this</code> and <code>'n' arguments</code>. <code>apply</code> takes only two arguments, one is <code>this</code> the other is argument array.</p>\n\n<p>The advantage I see in <code>apply</code> over <code>call</code> is that we can easily delegate a function call to other function without much effort;</p>\n\n<pre><code>function sayHello() {\n  console.log(this, arguments);\n}\n\nfunction hello() {\n  sayHello.apply(this, arguments);\n}\n\nvar obj = {name: 'my name'}\nhello.call(obj, 'some', 'arguments');\n</code></pre>\n\n<p>Observe how easily we delegated <code>hello</code> to <code>sayHello</code> using <code>apply</code>, but with <code>call</code> this is very difficult to achieve.</p>\n"},{"score":19,"body":"<p>From <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\" rel=\"noreferrer\"><strong>the MDN docs on Function.prototype.apply()</strong></a> :</p>\n\n<blockquote>\n  <p>The apply() method calls a function with a given <code>this</code> value and\n  arguments provided as an array (or an array-like object).</p>\n  \n  <h3>Syntax</h3>\n\n<pre><code>fun.apply(thisArg, [argsArray])\n</code></pre>\n</blockquote>\n\n<p>From <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\" rel=\"noreferrer\"><strong>the MDN docs on Function.prototype.call()</strong></a> :</p>\n\n<blockquote>\n  <p>The call() method calls a function with a given <code>this</code> value and arguments provided individually.</p>\n  \n  <h3>Syntax</h3>\n\n<pre><code>fun.call(thisArg[, arg1[, arg2[, ...]]])\n</code></pre>\n</blockquote>\n\n<p>From <a href=\"http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx\" rel=\"noreferrer\"><strong>Function.apply and Function.call in JavaScript</strong></a> :</p>\n\n<blockquote>\n  <p>The apply() method is identical to call(), except apply() requires an\n  array as the second parameter. The array represents the arguments for\n  the target method.</p>\n</blockquote>\n\n<hr>\n\n<h3>Code example :</h3>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var doSomething = function() {\r\n    var arr = [];\r\n    for(i in arguments) {\r\n        if(typeof this[arguments[i]] !== 'undefined') {\r\n            arr.push(this[arguments[i]]);\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n\r\nvar output = function(position, obj) {\r\n    document.body.innerHTML += '&lt;h3&gt;output ' + position + '&lt;/h3&gt;' + JSON.stringify(obj) + '\\n&lt;br&gt;\\n&lt;br&gt;&lt;hr&gt;';\r\n}\r\n\r\noutput(1, doSomething(\r\n    'one',\r\n    'two',\r\n    'two',\r\n    'one'\r\n));\r\n\r\noutput(2, doSomething.apply({one : 'Steven', two : 'Jane'}, [\r\n    'one',\r\n    'two',\r\n    'two',\r\n    'one'\r\n]));\r\n\r\noutput(3, doSomething.call({one : 'Steven', two : 'Jane'},\r\n    'one',\r\n    'two',\r\n    'two',\r\n    'one'\r\n));</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>See also <a href=\"https://jsfiddle.net/k7y5o0d6/9/\" rel=\"noreferrer\"><strong>this Fiddle</strong></a>.</p>\n"},{"score":8,"body":"<p>The difference is that <code>call()</code> takes the function arguments separately, and <code>apply()</code> takes the function arguments in an array.</p>\n"},{"score":4,"body":"<p>The main difference is, using call, we can change the scope and pass arguments as normal, but apply lets you call it using arguments as an Array (pass them as an array). But in terms of what they to do in your code, they are pretty similar.</p>\n\n<blockquote>\n  <p>While the syntax of this function is almost identical to that of\n  apply(), the fundamental difference is that call() accepts an argument\n  list, while apply() accepts a single array of arguments.</p>\n</blockquote>\n\n<p>So as you see, there is not a big difference, but still, there are cases we prefer using call() or apply(). For example, look at the code below, which finding the smallest and largest number in an array from MDN, using the apply method:</p>\n\n<pre><code>// min/max number in an array\nvar numbers = [5, 6, 2, 3, 7];\n\n// using Math.min/Math.max apply\nvar max = Math.max.apply(null, numbers); \n// This about equal to Math.max(numbers[0], ...)\n// or Math.max(5, 6, ...)\n\nvar min = Math.min.apply(null, numbers)\n</code></pre>\n\n<p>So the main difference is just the way we passing the arguments:<br> <br> \n<strong>Call:</strong><br> </p>\n\n<pre><code>function.call(thisArg, arg1, arg2, ...);\n</code></pre>\n\n<p><strong>Apply:</strong><br> </p>\n\n<pre><code>function.apply(thisArg, [argsArray]);\n</code></pre>\n"},{"score":4,"body":"<h2>Summary:</h2>\n\n<p>Both <code>call()</code> and <code>apply()</code> are methods which are located on <code>Function.prototype</code>. Therefore they are available on every function object via the prototype chain. Both <code>call()</code> and <code>apply()</code> can execute a function with a specified value of the <code>this</code>.</p>\n\n<p>The main difference between <code>call()</code> and <code>apply()</code> is the way you have to pass in arguments into it. In both <code>call()</code> and <code>apply()</code> you pass as a first argument the object you want to be the value as <code>this</code>. The other arguments differ in the following way:</p>\n\n<ul>\n<li>With <code>call()</code> you have to put in the arguments normally (starting from the second argument)</li>\n<li>With <code>apply()</code> you have to pass in array of arguments.</li>\n</ul>\n\n<h2>Example:</h2>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>let obj = {\r\n  val1: 5,\r\n  val2: 10\r\n}\r\n\r\nconst summation = function (val3, val4) {\r\n  return  this.val1 + this.val2 + val3 + val4;\r\n}\r\n\r\nconsole.log(summation.apply(obj, [2 ,3]));\r\n// first we assign we value of this in the first arg\r\n// with apply we have to pass in an array\r\n\r\n\r\nconsole.log(summation.call(obj, 2, 3));\r\n// with call we can pass in each arg individually</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<h2>Why would I need to use these functions?</h2>\n\n<p>The <code>this</code> value can be tricky sometimes in javascript. The value of <code>this</code> determined <strong>when a function is executed not when a function is defined.</strong> If our function is dependend on a right <code>this</code> binding we can use <code>call()</code> and <code>apply()</code> to enforce this behaviour. For example:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var name = 'unwantedGlobalName';\r\n\r\nconst obj =  {\r\n  name: 'Willem',\r\n  sayName () { console.log(this.name);}\r\n}\r\n\r\n\r\nlet copiedMethod = obj.sayName;\r\n// we store the function in the copiedmethod variable\r\n\r\n\r\n\r\ncopiedMethod();\r\n// this is now window, unwantedGlobalName gets logged\r\n\r\ncopiedMethod.call(obj);\r\n// we enforce this to be obj, Willem gets logged</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":2,"body":"<p>Let me add a little detail to this.</p>\n\n<p>these two calls are almost equivalent:</p>\n\n<pre><code>func.call(context, ...args); // pass an array as list with spread operator\n\nfunc.apply(context, args);   // is same as using apply\n</code></pre>\n\n<p>There’s only a minor difference:</p>\n\n<blockquote>\n  <ul>\n  <li>The <code>spread</code> operator ... allows passing <strong><em>iterable</em></strong> <code>args</code> as the list to call.</li>\n  <li>The <code>apply</code> accepts only <strong><em>array-like</em></strong> args.</li>\n  </ul>\n</blockquote>\n\n<p>So, these calls complement each other. Where we expect an <em>iterable</em>, <code>call</code> works, where we expect an <em>array-like</em>, <code>apply</code> works.</p>\n\n<p>And for objects that are both <em>iterable</em> and <em>array-like</em>, like a real array, we technically could use any of them, but <strong><em>apply</em></strong> will probably be <strong>faster</strong> because most JavaScript engines internally optimize it better.</p>\n"},{"score":0,"body":"<p>A well explained by <a href=\"https://stackoverflow.com/a/1986909/9224597\">flatline</a>. I just want to add a simple example. which makes it easy to understand for beginners.</p>\n\n<pre><code>func.call(context, args1 , args2 ); // pass arguments as \",\" saprated value\n\nfunc.apply(context, [args1 , args2 ]);   //  pass arguments as \"Array\"\n</code></pre>\n\n<p>we also use \"Call\" and \"Apply\" method for changing  <strong>reference</strong> as defined in code below </p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>    let Emp1 = {\r\n        name: 'X',\r\n        getEmpDetail: function (age, department) {\r\n            console.log('Name :', this.name, '  Age :', age, '  Department :', department)\r\n        }\r\n    }\r\n    Emp1.getEmpDetail(23, 'Delivery')\r\n\r\n    // 1st approch of chenging \"this\"\r\n    let Emp2 = {\r\n        name: 'Y',\r\n        getEmpDetail: Emp1.getEmpDetail\r\n    }\r\n    Emp2.getEmpDetail(55, 'Finance')\r\n\r\n    // 2nd approch of changing \"this\" using \"Call\" and \"Apply\"\r\n    let Emp3 = {\r\n        name: 'Z',\r\n    }\r\n\r\n    Emp1.getEmpDetail.call(Emp3, 30, 'Admin')        \r\n// here we have change the ref from **Emp1 to Emp3**  object\r\n// now this will print \"Name =  X\" because it is pointing to Emp3 object\r\n    Emp1.getEmpDetail.apply(Emp3, [30, 'Admin']) //</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":0,"body":"<p>The <code>call()</code> method calls a function with a given <code>this</code> value and arguments provided individually.<a href=\"https://i.stack.imgur.com/vwr0B.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/vwr0B.jpg\" alt=\"enter image description here\" /></a></p>\n<p><code>apply()</code> -\nSimilar to the <code>call()</code> method, the first parameter in the <code>apply()</code> method sets the <code>this</code> value which is the object upon which the function is invoked. In this case, it's the <code>obj</code> object above. The only difference between the <code>apply()</code> and <code>call()</code> method is that the second parameter of the <code>apply()</code> method accepts the arguments to the actual function as an array.\n<a href=\"https://i.stack.imgur.com/orgBS.jpg\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/orgBS.jpg\" alt=\"enter image description here\" /></a></p>\n"},{"score":0,"body":"<p>Both call and apply the same way. It calls immediately when we use call and apply.</p>\n<p>Both call and apply takes &quot;this&quot; parameter as the first argument and the second argument only differs.</p>\n<p>the call takes the arguments of the functions as a list  (comma )\nApply takes the arguments of the functions as an array.</p>\n<p>You can find the complete difference between bind, call, and apply in the bellow youtube video.</p>\n<p><a href=\"https://www.youtube.com/watch?v=G-EfxnG0DtY&amp;t=180s\" rel=\"nofollow noreferrer\">https://www.youtube.com/watch?v=G-EfxnG0DtY&amp;t=180s</a></p>\n"}],"score":3169}