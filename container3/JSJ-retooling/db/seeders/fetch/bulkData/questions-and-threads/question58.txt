{"body":"<p>What is the most appropriate way to test if a variable is undefined in JavaScript?</p>\n<p>I've seen several possible ways:</p>\n<pre><code>if (window.myVariable)\n</code></pre>\n<p>Or</p>\n<pre><code>if (typeof(myVariable) != &quot;undefined&quot;)\n</code></pre>\n<p>Or</p>\n<pre><code>if (myVariable) // This throws an error if undefined. Should this be in Try/Catch?\n</code></pre>\n","title":"How can I check for &quot;undefined&quot; in JavaScript?","answers":[{"score":75,"body":"<p>You can use <code>typeof</code>, like this:</p>\n\n<pre><code>if (typeof something != \"undefined\") {\n    // ...\n}\n</code></pre>\n"},{"score":23,"body":"<p>If it is undefined, it will not be equal to a string that contains the characters \"undefined\", as the string is not undefined.</p>\n\n<p>You can check the type of the variable:</p>\n\n<pre><code>if (typeof(something) != \"undefined\") ...\n</code></pre>\n\n<p>Sometimes you don't even have to check the type. If the value of the variable can't evaluate to false when it's set (for example if it's a function), then you can just evalue the variable. Example:</p>\n\n<pre><code>if (something) {\n  something(param);\n}\n</code></pre>\n"},{"score":18,"body":"<pre><code>if (typeof foo == 'undefined') {\n // Do something\n};\n</code></pre>\n\n<p>Note that strict comparison (<code>!==</code>) is not necessary in this case, since <code>typeof</code> will always return a string.</p>\n"},{"score":2792,"body":"<p>If you are interested in finding out whether a variable has been declared regardless of its value, then using the <code>in</code> operator is the safest way to go. Consider this example:</p>\n\n<pre><code>// global scope\nvar theFu; // theFu has been declared, but its value is undefined\ntypeof theFu; // \"undefined\"\n</code></pre>\n\n<p>But this may not be the intended result for some cases, since the variable or property was declared but just not initialized. Use the <code>in</code> operator for a more robust check.</p>\n\n<pre><code>\"theFu\" in window; // true\n\"theFoo\" in window; // false\n</code></pre>\n\n<p>If you are interested in knowing whether the variable hasn't been declared or has the value <code>undefined</code>, then use the <code>typeof</code> operator, which is guaranteed to return a string:</p>\n\n<pre><code>if (typeof myVar !== 'undefined')\n</code></pre>\n\n<p>Direct comparisons against <code>undefined</code> are troublesome as <code>undefined</code> can be overwritten. </p>\n\n<pre><code>window.undefined = \"foo\";\n\"foo\" == undefined // true\n</code></pre>\n\n<p>As @CMS pointed out, this has been patched in ECMAScript 5th ed., and <code>undefined</code> is non-writable.</p>\n\n<p><code>if (window.myVar)</code> will also include these falsy values, so it's not very robust:</p>\n\n<pre>\nfalse\n0\n\"\"\nNaN\nnull\nundefined\n</pre>\n\n<p>Thanks to @CMS for pointing out that your third case - <code>if (myVariable)</code> can also throw an error in two cases. The first is when the variable hasn't been defined which throws a <code>ReferenceError</code>. </p>\n\n<pre><code>// abc was never declared.\nif (abc) {\n    // ReferenceError: abc is not defined\n} \n</code></pre>\n\n<p>The other case is when the variable has been defined, but has a getter function which throws an error when invoked. For example,</p>\n\n<pre><code>// or it's a property that can throw an error\nObject.defineProperty(window, \"myVariable\", { \n    get: function() { throw new Error(\"W00t?\"); }, \n    set: undefined \n});\nif (myVariable) {\n    // Error: W00t?\n}\n</code></pre>\n"},{"score":0,"body":"<p>I use it as a function parameter and exclude it on function execution that way I get the \"real\" undefined. Although it does require you to put your code inside a function. I found this while reading the jQuery source.</p>\n\n<pre><code>undefined = 2;\n\n(function (undefined) {\n   console.log(undefined); // prints out undefined\n   // and for comparison:\n   if (undeclaredvar === undefined) console.log(\"it works!\")\n})()\n</code></pre>\n\n<p>Of course you could just use <code>typeof</code> though. But all my code is usually inside a containing function anyways, so using this method probably saves me a few bytes here and there.</p>\n"},{"score":225,"body":"<p><strong>2020 Update</strong></p>\n\n<p>One of my reasons for preferring a <code>typeof</code> check (namely, that <code>undefined</code> can be redefined) became irrelevant with the mass adoption of ECMAScript 5. The other, that you can use <code>typeof</code> to check the type of an undeclared variable, was always niche. Therefore, I'd now recommend using a direct comparison in most situations:</p>\n\n<pre><code>myVariable === undefined\n</code></pre>\n\n<p><strong>Original answer from 2010</strong></p>\n\n<p>Using <code>typeof</code> is my preference. It will work when the variable has never been declared, unlike any comparison with the <code>==</code> or <code>===</code> operators or type coercion using <code>if</code>. (<code>undefined</code>, unlike <code>null</code>, may also be redefined in ECMAScript 3 environments, making it unreliable for comparison, although nearly all common environments now are compliant with ECMAScript 5 or above).</p>\n\n<pre><code>if (typeof someUndeclaredVariable == \"undefined\") {\n    // Works\n}\n\nif (someUndeclaredVariable === undefined) { \n    // Throws an error\n}\n</code></pre>\n"},{"score":1229,"body":"<p>I personally use </p>\n\n<pre><code>myVar === undefined\n</code></pre>\n\n<p>Warning: Please note that <code>===</code> is used over <code>==</code> and that <code>myVar</code> has been previously <em>declared</em> (not <em>defined</em>).</p>\n\n<hr>\n\n<p>I do not like <code>typeof myVar === \"undefined\"</code>. I think it is long winded and unnecessary. (I can get the same done in less code.)</p>\n\n<p>Now some people will keel over in pain when they read this, screaming: \"Wait! WAAITTT!!! <code>undefined</code> can be redefined!\"</p>\n\n<p>Cool. I know this. Then again, most variables in Javascript can be redefined. Should you never use any built-in identifier that can be redefined?</p>\n\n<p>If you follow this rule, good for you: you aren't a hypocrite.</p>\n\n<p>The thing is, in order to do lots of real work in JS, developers need to rely on redefinable identifiers to be what they are. I don't hear people telling me that I shouldn't use <code>setTimeout</code> because someone can</p>\n\n<pre><code>window.setTimeout = function () {\n    alert(\"Got you now!\");\n};\n</code></pre>\n\n<p>Bottom line, the \"it can be redefined\" argument to not use a raw <code>=== undefined</code> is bogus. </p>\n\n<p>(If you are still scared of <code>undefined</code> being redefined, why are you blindly integrating untested library code into your code base? Or even simpler: a linting tool.)</p>\n\n<hr>\n\n<p>Also, like the <code>typeof</code> approach, this technique can \"detect\" undeclared variables: </p>\n\n<pre><code>if (window.someVar === undefined) {\n    doSomething();\n}\n</code></pre>\n\n<p>But both these techniques leak in their abstraction. I urge you not to use this or even </p>\n\n<pre><code>if (typeof myVar !== \"undefined\") {\n    doSomething();\n}\n</code></pre>\n\n<p>Consider:</p>\n\n<pre><code>var iAmUndefined;\n</code></pre>\n\n<p>To catch whether or not that variable is declared or not, you may need to resort to the <code>in</code> operator. (In many cases, you can simply read the code O_o).</p>\n\n<pre><code>if (\"myVar\" in window) {\n    doSomething();\n}\n</code></pre>\n\n<p>But wait! There's more! What if some prototype chain magic is happeningâ€¦? Now even the superior <code>in</code> operator does not suffice. (Okay, I'm done here about this part except to say that for 99% of the time, <code>=== undefined</code> (and ****cough**** <code>typeof</code>) works just fine. If you really care, you can read about this subject on its own.)</p>\n"},{"score":6,"body":"<p>Since none of the other answers helped me, I suggest doing this. It worked for me in Internet&nbsp;Explorer&nbsp;8:</p>\n\n<pre><code>if (typeof variable_name.value === 'undefined') {\n    // variable_name is undefined\n}\n</code></pre>\n"},{"score":17,"body":"<p>Some scenarios illustrating the results of the various answers:\n<a href=\"http://jsfiddle.net/drzaus/UVjM4/\">http://jsfiddle.net/drzaus/UVjM4/</a></p>\n\n<p><em>(Note that the use of <code>var</code> for <code>in</code> tests make a difference when in a scoped wrapper)</em></p>\n\n<p>Code for reference:</p>\n\n<pre><code>(function(undefined) {\n    var definedButNotInitialized;\n    definedAndInitialized = 3;\n    someObject = {\n        firstProp: \"1\"\n        , secondProp: false\n        // , undefinedProp not defined\n    }\n    // var notDefined;\n\n    var tests = [\n        'definedButNotInitialized in window',\n        'definedAndInitialized in window',\n        'someObject.firstProp in window',\n        'someObject.secondProp in window',\n        'someObject.undefinedProp in window',\n        'notDefined in window',\n\n        '\"definedButNotInitialized\" in window',\n        '\"definedAndInitialized\" in window',\n        '\"someObject.firstProp\" in window',\n        '\"someObject.secondProp\" in window',\n        '\"someObject.undefinedProp\" in window',\n        '\"notDefined\" in window',\n\n        'typeof definedButNotInitialized == \"undefined\"',\n        'typeof definedButNotInitialized === typeof undefined',\n        'definedButNotInitialized === undefined',\n        '! definedButNotInitialized',\n        '!! definedButNotInitialized',\n\n        'typeof definedAndInitialized == \"undefined\"',\n        'typeof definedAndInitialized === typeof undefined',\n        'definedAndInitialized === undefined',\n        '! definedAndInitialized',\n        '!! definedAndInitialized',\n\n        'typeof someObject.firstProp == \"undefined\"',\n        'typeof someObject.firstProp === typeof undefined',\n        'someObject.firstProp === undefined',\n        '! someObject.firstProp',\n        '!! someObject.firstProp',\n\n        'typeof someObject.secondProp == \"undefined\"',\n        'typeof someObject.secondProp === typeof undefined',\n        'someObject.secondProp === undefined',\n        '! someObject.secondProp',\n        '!! someObject.secondProp',\n\n        'typeof someObject.undefinedProp == \"undefined\"',\n        'typeof someObject.undefinedProp === typeof undefined',\n        'someObject.undefinedProp === undefined',\n        '! someObject.undefinedProp',\n        '!! someObject.undefinedProp',\n\n        'typeof notDefined == \"undefined\"',\n        'typeof notDefined === typeof undefined',\n        'notDefined === undefined',\n        '! notDefined',\n        '!! notDefined'\n    ];\n\n    var output = document.getElementById('results');\n    var result = '';\n    for(var t in tests) {\n        if( !tests.hasOwnProperty(t) ) continue; // bleh\n\n        try {\n            result = eval(tests[t]);\n        } catch(ex) {\n            result = 'Exception--' + ex;\n        }\n        console.log(tests[t], result);\n        output.innerHTML += \"\\n\" + tests[t] + \": \" + result;\n    }\n})();\n</code></pre>\n\n<p>And results:</p>\n\n<pre><code>definedButNotInitialized in window: true\ndefinedAndInitialized in window: false\nsomeObject.firstProp in window: false\nsomeObject.secondProp in window: false\nsomeObject.undefinedProp in window: true\nnotDefined in window: Exception--ReferenceError: notDefined is not defined\n\"definedButNotInitialized\" in window: false\n\"definedAndInitialized\" in window: true\n\"someObject.firstProp\" in window: false\n\"someObject.secondProp\" in window: false\n\"someObject.undefinedProp\" in window: false\n\"notDefined\" in window: false\ntypeof definedButNotInitialized == \"undefined\": true\ntypeof definedButNotInitialized === typeof undefined: true\ndefinedButNotInitialized === undefined: true\n! definedButNotInitialized: true\n!! definedButNotInitialized: false\ntypeof definedAndInitialized == \"undefined\": false\ntypeof definedAndInitialized === typeof undefined: false\ndefinedAndInitialized === undefined: false\n! definedAndInitialized: false\n!! definedAndInitialized: true\ntypeof someObject.firstProp == \"undefined\": false\ntypeof someObject.firstProp === typeof undefined: false\nsomeObject.firstProp === undefined: false\n! someObject.firstProp: false\n!! someObject.firstProp: true\ntypeof someObject.secondProp == \"undefined\": false\ntypeof someObject.secondProp === typeof undefined: false\nsomeObject.secondProp === undefined: false\n! someObject.secondProp: true\n!! someObject.secondProp: false\ntypeof someObject.undefinedProp == \"undefined\": true\ntypeof someObject.undefinedProp === typeof undefined: true\nsomeObject.undefinedProp === undefined: true\n! someObject.undefinedProp: true\n!! someObject.undefinedProp: false\ntypeof notDefined == \"undefined\": true\ntypeof notDefined === typeof undefined: true\nnotDefined === undefined: Exception--ReferenceError: notDefined is not defined\n! notDefined: Exception--ReferenceError: notDefined is not defined\n!! notDefined: Exception--ReferenceError: notDefined is not defined\n</code></pre>\n"},{"score":3,"body":"<p>On the contrary of @Thomas Eding answer:</p>\n\n<p>If I forget to declare <code>myVar</code> in my code, then I'll get <code>myVar is not defined</code>.</p>\n\n<p>Let's take a real example:</p>\n\n<p>I've a variable name, but I am not sure if it is declared somewhere or not.</p>\n\n<p>Then @Anurag's answer will help:</p>\n\n<pre><code>var myVariableToCheck = 'myVar';\nif (window[myVariableToCheck] === undefined)\n    console.log(\"Not declared or declared, but undefined.\");\n\n// Or you can check it directly \nif (window['myVar'] === undefined) \n    console.log(\"Not declared or declared, but undefined.\");\n</code></pre>\n"},{"score":61,"body":"<h1>Update 2018-07-25</h1>\n\n<p>It's been nearly five years since this post was first made, and JavaScript has come a long way.  In repeating the tests in the original post, I found no consistent difference between the following test methods:</p>\n\n<ul>\n<li><code>abc === undefined</code></li>\n<li><code>abc === void 0</code></li>\n<li><code>typeof abc == 'undefined'</code></li>\n<li><code>typeof abc === 'undefined'</code></li>\n</ul>\n\n<p>Even when I modified the tests to prevent Chrome from optimizing them away, the differences were insignificant.  As such, I'd now recommend <code>abc === undefined</code> for clarity.</p>\n\n<p>Relevant content from <code>chrome://version</code>:</p>\n\n<ul>\n<li>Google Chrome: 67.0.3396.99 (Official Build) (64-bit) (cohort: Stable)</li>\n<li>Revision: a337fbf3c2ab8ebc6b64b0bfdce73a20e2e2252b-refs/branch-heads/3396@{#790}</li>\n<li>OS: Windows</li>\n<li>JavaScript: V8 6.7.288.46</li>\n<li>User Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36</li>\n</ul>\n\n<h1>Original post 2013-11-01</h1>\n\n<p>In Google Chrome, the following was ever so slightly faster than a <code>typeof</code> test:</p>\n\n<pre><code>if (abc === void 0) {\n    // Undefined\n}\n</code></pre>\n\n<p>The difference was negligible.  However, this code is more concise, and clearer at a glance to someone who knows what <code>void 0</code> means. Note, however, that <code>abc</code> <strong>must still be declared</strong>.</p>\n\n<p>Both <code>typeof</code> and <code>void</code> were significantly faster than comparing directly against <code>undefined</code>.  I used the following test format in the Chrome developer console:</p>\n\n<pre><code>var abc;\nstart = +new Date();\nfor (var i = 0; i &lt; 10000000; i++) {\n    if (TEST) {\n        void 1;\n    }\n}\nend = +new Date();\nend - start;\n</code></pre>\n\n<p>The results were as follows:</p>\n\n<pre><code>Test: | abc === undefined      abc === void 0      typeof abc == 'undefined'\n------+---------------------------------------------------------------------\nx10M  |     13678 ms               9854 ms                 9888 ms\n  x1  |    1367.8 ns              985.4 ns                988.8 ns\n</code></pre>\n\n<p>Note that the first row is in <em>milli</em>seconds, while the second row is in <em>nano</em>seconds.  A difference of 3.4 nanoseconds is nothing.  The times were pretty consistent in subsequent tests.</p>\n"},{"score":16,"body":"<p>In <a href=\"http://flippinawesome.org/2013/12/09/exploring-the-abyss-of-null-and-undefined-in-javascript/\" rel=\"noreferrer\">this article</a> I read that frameworks like <a href=\"https://en.wikipedia.org/wiki/Underscore.js\" rel=\"noreferrer\">Underscore.js</a> use this function:</p>\n\n<pre><code>function isUndefined(obj){\n    return obj === void 0;\n}\n</code></pre>\n"},{"score":13,"body":"<p>Personally, I always use the following:</p>\n\n<pre><code>var x;\nif( x === undefined) {\n    //Do something here\n}\nelse {\n   //Do something else here\n}\n</code></pre>\n\n<p>The window.undefined property is non-writable in all modern browsers (JavaScript 1.8.5 or later). From Mozilla's documentation: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined\" rel=\"noreferrer\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined</a>, I see this: One reason to use typeof() is that it does not throw an error if the variable has not been defined.</p>\n\n<p>I prefer to have the approach of using</p>\n\n<pre><code>x === undefined \n</code></pre>\n\n<p>because it fails and blows up in my face rather than silently passing/failing if x has not been declared before. This alerts me that x is not declared. I believe all variables used in JavaScript should be declared.</p>\n"},{"score":10,"body":"<p>The most reliable way I know of checking for <code>undefined</code> is to use <code>void 0</code>.</p>\n\n<p>This is compatible with newer and older browsers, alike, and cannot be overwritten like <code>window.undefined</code> can in some cases.</p>\n\n<pre><code>if( myVar === void 0){\n    //yup it's undefined\n}\n</code></pre>\n"},{"score":3,"body":"<pre><code>    var x;\n    if (x === undefined) {\n        alert (\"I am declared, but not defined.\")\n    };\n    if (typeof y === \"undefined\") {\n        alert (\"I am not even declared.\")\n    };\n\n    /* One more thing to understand: typeof ==='undefined' also checks \n       for if a variable is declared, but no value is assigned. In other \n       words, the variable is declared, but not defined. */\n\n    // Will repeat above logic of x for typeof === 'undefined'\n    if (x === undefined) {\n        alert (\"I am declared, but not defined.\")\n    };\n    /* So typeof === 'undefined' works for both, but x === undefined \n       only works for a variable which is at least declared. */\n\n    /* Say if I try using typeof === undefined (not in quotes) for \n       a variable which is not even declared, we will get run a \n       time error. */\n\n    if (z === undefined) {\n        alert (\"I am neither declared nor defined.\")\n    };\n    // I got this error for z ReferenceError: z is not defined \n</code></pre>\n"},{"score":4,"body":"<pre><code>// x has not been defined before\nif (typeof x === 'undefined') { // Evaluates to true without errors.\n   // These statements execute.\n}\n\nif (x === undefined) { // Throws a ReferenceError\n\n}\n</code></pre>\n"}],"score":2555}