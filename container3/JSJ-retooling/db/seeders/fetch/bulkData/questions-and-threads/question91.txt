{"body":"<p>I'm looking for a good JavaScript equivalent of the C/PHP <code>printf()</code> or for C#/Java programmers, <code>String.Format()</code> (<code>IFormatProvider</code> for .NET).</p>\n\n<p>My basic requirement is a thousand separator format for numbers for now, but something that handles lots of combinations (including dates) would be good.</p>\n\n<p>I realize Microsoft's <a href=\"http://en.wikipedia.org/wiki/Ajax_%28programming%29\" rel=\"noreferrer\">Ajax</a> library provides a version of <code>String.Format()</code>, but we don't want the entire overhead of that framework.</p>\n","title":"JavaScript equivalent to printf/String.Format","answers":[{"score":1207,"body":"<p>From ES6 on you could use template strings:</p>\n\n<pre><code>let soMany = 10;\nconsole.log(`This is ${soMany} times easier!`);\n// \"This is 10 times easier!\n</code></pre>\n\n<p>See Kim's <a href=\"https://stackoverflow.com/a/32202320/2430448\">answer</a> below for details. </p>\n\n<hr>\n\n<h1>Otherwise:</h1>\n\n<p>Try <a href=\"https://github.com/alexei/sprintf.js\" rel=\"noreferrer\">sprintf() for JavaScript</a>.</p>\n\n<hr>\n\n<p>If you really want to do a simple format method on your own, don’t do the replacements successively but do them simultaneously.</p>\n\n<p>Because most of the other proposals that are mentioned fail when a replace string of previous replacement does also contain a format sequence like this:</p>\n\n<pre><code>\"{0}{1}\".format(\"{1}\", \"{0}\")\n</code></pre>\n\n<p>Normally you would expect the output to be <code>{1}{0}</code> but the actual output is <code>{1}{1}</code>. So do a simultaneously replacement instead like in <a href=\"https://stackoverflow.com/questions/610406/javascript-printf-string-format/4673436#4673436\">fearphage’s suggestion</a>.</p>\n"},{"score":8,"body":"<p>There is \"sprintf\" for JavaScript which you can find at <a href=\"http://www.webtoolkit.info/javascript-sprintf.html\" rel=\"nofollow noreferrer\">http://www.webtoolkit.info/javascript-sprintf.html</a>.</p>\n"},{"score":15,"body":"<p>I'll add my own discoveries which I've found since I asked:</p>\n\n<ul>\n<li><a href=\"http://locutus.io/php/strings/number_format/index.html\" rel=\"nofollow noreferrer\">number_format (for thousand separator/currency formatting)</a></li>\n<li><a href=\"http://locutus.io/php/strings/sprintf/index.html\" rel=\"nofollow noreferrer\">sprintf (same author as above)</a></li>\n</ul>\n\n<p>Sadly it seems sprintf doesn't handle thousand separator formatting like .NET's string format.</p>\n"},{"score":11,"body":"<p>If you are looking to handle the thousands separator, you should really use toLocaleString() from the JavaScript <a href=\"http://www.hunlock.com/blogs/The_Complete_Javascript_Number_Reference\" rel=\"nofollow noreferrer\">Number</a> class since it will format the string for the user's region.</p>\n\n<p>The JavaScript <a href=\"http://www.hunlock.com/blogs/Javascript_Dates-The_Complete_Reference\" rel=\"nofollow noreferrer\">Date</a> class can format localized dates and times.</p>\n"},{"score":14,"body":"<p>I use a small library called <a href=\"http://www.masterdata.se/r/string_format_for_javascript/\" rel=\"noreferrer\">String.format for JavaScript</a> which supports most of the format string capabilities (including format of numbers and dates), and uses the .NET syntax. The script itself is smaller than 4 kB, so it doesn't create much of overhead.</p>\n"},{"score":113,"body":"<p>I use this simple function:</p>\n\n<pre><code>String.prototype.format = function() {\n    var formatted = this;\n    for( var arg in arguments ) {\n        formatted = formatted.replace(\"{\" + arg + \"}\", arguments[arg]);\n    }\n    return formatted;\n};\n</code></pre>\n\n<p>That's very similar to string.format:</p>\n\n<pre><code>\"{0} is dead, but {1} is alive!\".format(\"ASP\", \"ASP.NET\")\n</code></pre>\n"},{"score":21,"body":"<p>+1 Zippo with the exception that the function body needs to be as below or otherwise it appends the current string on every iteration:</p>\n\n<pre><code>String.prototype.format = function() {\n    var formatted = this;\n    for (var arg in arguments) {\n        formatted = formatted.replace(\"{\" + arg + \"}\", arguments[arg]);\n    }\n    return formatted;\n};\n</code></pre>\n"},{"score":31,"body":"<p>JavaScript programmers can use String.prototype.sprintf at <a href=\"https://github.com/ildar-shaimordanov/jsxt/blob/master/js/String.js\" rel=\"noreferrer\">https://github.com/ildar-shaimordanov/jsxt/blob/master/js/String.js</a>. Below is example:</p>\n\n<pre><code>var d = new Date();\nvar dateStr = '%02d:%02d:%02d'.sprintf(\n    d.getHours(), \n    d.getMinutes(), \n    d.getSeconds());\n</code></pre>\n"},{"score":173,"body":"<p>jsxt, Zippo</p>\n\n<p>This option fits better.</p>\n\n<pre><code>String.prototype.format = function() {\n    var formatted = this;\n    for (var i = 0; i &lt; arguments.length; i++) {\n        var regexp = new RegExp('\\\\{'+i+'\\\\}', 'gi');\n        formatted = formatted.replace(regexp, arguments[i]);\n    }\n    return formatted;\n};\n</code></pre>\n\n<p>With this option I can replace strings like these:</p>\n\n<pre><code>'The {0} is dead. Don\\'t code {0}. Code {1} that is open source!'.format('ASP', 'PHP');\n</code></pre>\n\n<p>With your code the second {0} wouldn't be replaced. ;)</p>\n"},{"score":1419,"body":"<p>Building on the previously suggested solutions:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>// First, checks if it isn't implemented yet.\nif (!String.prototype.format) {\n  String.prototype.format = function() {\n    var args = arguments;\n    return this.replace(/{(\\d+)}/g, function(match, number) { \n      return typeof args[number] != 'undefined'\n        ? args[number]\n        : match\n      ;\n    });\n  };\n}\n</code></pre>\n\n<p><code>\"{0} is dead, but {1} is alive! {0} {2}\".format(\"ASP\", \"ASP.NET\")</code></p>\n\n<p>outputs</p>\n\n<blockquote>\n  <p>ASP is dead, but ASP.NET is alive! ASP {2}</p>\n</blockquote>\n\n<hr>\n\n<p>If you prefer not to modify <code>String</code>'s prototype:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>if (!String.format) {\n  String.format = function(format) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return format.replace(/{(\\d+)}/g, function(match, number) { \n      return typeof args[number] != 'undefined'\n        ? args[number] \n        : match\n      ;\n    });\n  };\n}\n</code></pre>\n\n<p>Gives you the much more familiar:</p>\n\n<p><code>String.format('{0} is dead, but {1} is alive! {0} {2}', 'ASP', 'ASP.NET');</code></p>\n\n<p>with the same result:</p>\n\n<blockquote>\n  <p>ASP is dead, but ASP.NET is alive! ASP {2}</p>\n</blockquote>\n"},{"score":51,"body":"<p>Here's a <em>minimal</em> implementation of sprintf in JavaScript: it only does \"%s\" and \"%d\", but I have left space for it to be extended. It is useless to the OP, but other people who stumble across this thread coming from Google might benefit from it.</p>\n\n<pre><code>function sprintf() {\n    var args = arguments,\n    string = args[0],\n    i = 1;\n    return string.replace(/%((%)|s|d)/g, function (m) {\n        // m is the matched format, e.g. %s, %d\n        var val = null;\n        if (m[2]) {\n            val = m[2];\n        } else {\n            val = args[i];\n            // A switch statement so that the formatter can be extended. Default is %s\n            switch (m) {\n                case '%d':\n                    val = parseFloat(val);\n                    if (isNaN(val)) {\n                        val = 0;\n                    }\n                    break;\n            }\n            i++;\n        }\n        return val;\n    });\n}\n</code></pre>\n\n<p>Example:</p>\n\n<pre><code>alert(sprintf('Latitude: %s, Longitude: %s, Count: %d', 41.847, -87.661, 'two'));\n// Expected output: Latitude: 41.847, Longitude: -87.661, Count: 0\n</code></pre>\n\n<p>In contrast with similar solutions in previous replies, this one does all substitutions <em>in one go</em>, so it will not replace parts of previously replaced values.</p>\n"},{"score":9,"body":"<p>The <a href=\"http://phpjs.org/\" rel=\"nofollow\">PHPJS project</a> has written JavaScript implementations for many of PHP's functions. Since PHP's <code>sprintf()</code> function is basically the same as C's <code>printf()</code>, <a href=\"http://phpjs.org/functions/sprintf\" rel=\"nofollow\">their JavaScript implementation of it</a> should satisfy your needs.</p>\n"},{"score":1,"body":"<p><code>arg</code> function: </p>\n\n<pre><code>/**\n * Qt stil arg()\n * var scr = \"&lt;div id='%1' class='%2'&gt;&lt;/div&gt;\".arg(\"mydiv\").arg(\"mydivClass\");\n */\nString.prototype.arg = function() {\n    var signIndex = this.indexOf(\"%\");\n    var result = this;\n    if (signIndex &gt; -1 &amp;&amp; arguments.length &gt; 0) {\n        var argNumber = this.charAt(signIndex + 1);\n        var _arg = \"%\"+argNumber;\n        var argCount = this.split(_arg);\n        for (var itemIndex = 0; itemIndex &lt; argCount.length; itemIndex++) {\n            result = result.replace(_arg, arguments[0]);\n        }\n    }\n    return result;\n}\n</code></pre>\n"},{"score":1,"body":"<p>There is also <code>Globalize.format</code> in the <a href=\"https://github.com/jquery/globalize\" rel=\"nofollow\">jQuery Globalize</a> project, the official globalization service for jQuery UI. IT's nice when you need culture-aware formatting. </p>\n"},{"score":332,"body":"<h1>Number Formatting in JavaScript</h1>\n\n<p>I got to this question page hoping to find how to <strong>format numbers</strong> in JavaScript, without introducing yet another library.  Here's what I've found:</p>\n\n<h2>Rounding floating-point numbers</h2>\n\n<p>The equivalent of <code>sprintf(\"%.2f\", num)</code> in JavaScript seems to be <code>num.toFixed(2)</code>, which formats <code>num</code> to 2 decimal places, with rounding (but see @ars265's comment about <code>Math.round</code> below).</p>\n\n<pre><code>(12.345).toFixed(2); // returns \"12.35\" (rounding!)\n(12.3).toFixed(2); // returns \"12.30\" (zero padding)\n</code></pre>\n\n<h2>Exponential form</h2>\n\n<p>The equivalent of <code>sprintf(\"%.2e\", num)</code> is <code>num.toExponential(2)</code>.  </p>\n\n<pre><code>(33333).toExponential(2); // \"3.33e+4\"\n</code></pre>\n\n<h2>Hexadecimal and other bases</h2>\n\n<p>To print numbers in base B, try <code>num.toString(B)</code>.  JavaScript supports automatic conversion to and from bases 2 through 36 (in addition, some browsers have <a href=\"https://developer.mozilla.org/en-US/docs/DOM/window.btoa\" rel=\"noreferrer\">limited support for base64 encoding</a>).</p>\n\n<pre><code>(3735928559).toString(16); // to base 16: \"deadbeef\"\nparseInt(\"deadbeef\", 16); // from base 16: 3735928559\n</code></pre>\n\n<h2>Reference Pages</h2>\n\n<p><a href=\"http://www.mredkj.com/javascript/numberFormat.html\" rel=\"noreferrer\">Quick tutorial on JS number formatting</a></p>\n\n<p><a href=\"https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Number/toFixed\" rel=\"noreferrer\">Mozilla reference page for toFixed()</a> (with links to toPrecision(), toExponential(), toLocaleString(), ...)</p>\n"},{"score":14,"body":"<p>Very elegant:</p>\n\n<pre><code>String.prototype.format = function (){\n    var args = arguments;\n    return this.replace(/\\{\\{|\\}\\}|\\{(\\d+)\\}/g, function (curlyBrack, index) {\n        return ((curlyBrack == \"{{\") ? \"{\" : ((curlyBrack == \"}}\") ? \"}\" : args[index]));\n    });\n};\n\n// Usage:\n\"{0}{1}\".format(\"{1}\", \"{0}\")\n</code></pre>\n\n<p>Credit goes to <del><a href=\"http://technoblogia.net/2011/11/08/%D7%98%D7%99%D7%A4-%D7%A4%D7%95%D7%A0%D7%A7%D7%A6%D7%99%D7%99%D7%AA-%D7%A2%D7%96%D7%A8-%D7%91-javascript-%D7%9C%D7%A2%D7%99%D7%A6%D7%95%D7%91-%D7%9E%D7%97%D7%A8%D7%95%D7%96%D7%95%D7%AA/\">(broken link)</a></del> <a href=\"https://gist.github.com/0i0/1519811\">https://gist.github.com/0i0/1519811</a></p>\n"},{"score":5,"body":"<p>I have a slightly longer formatter for JavaScript <a href=\"https://github.com/tracker1/core-js/blob/master/js-extensions/100-String.format.js\" rel=\"nofollow\">here</a>...  </p>\n\n<p>You can do formatting several ways:</p>\n\n<ul>\n<li><code>String.format(input, args0, arg1, ...)</code></li>\n<li><code>String.format(input, obj)</code></li>\n<li><code>\"literal\".format(arg0, arg1, ...)</code></li>\n<li><code>\"literal\".format(obj)</code></li>\n</ul>\n\n<p>Also, if you have say a ObjectBase.prototype.format (such as with <a href=\"http://www.datejs.com/\" rel=\"nofollow\">DateJS</a>) it will use that.</p>\n\n<p>Examples...</p>\n\n<pre><code>var input = \"numbered args ({0}-{1}-{2}-{3})\";\nconsole.log(String.format(input, \"first\", 2, new Date()));\n//Outputs \"numbered args (first-2-Thu May 31 2012...Time)-{3})\"\n\nconsole.log(input.format(\"first\", 2, new Date()));\n//Outputs \"numbered args(first-2-Thu May 31 2012...Time)-{3})\"\n\nconsole.log(input.format(\n    \"object properties ({first}-{second}-{third:yyyy-MM-dd}-{fourth})\"\n    ,{\n        'first':'first'\n        ,'second':2\n        ,'third':new Date() //assumes Date.prototype.format method\n    }\n));\n//Outputs \"object properties (first-2-2012-05-31-{3})\"\n</code></pre>\n\n<p>I've also aliased with .asFormat and have some detection in place in case there's already a string.format (such as with MS Ajax Toolkit (I hate that library).</p>\n"},{"score":0,"body":"<p>This one works with {0}, {1} and {}.</p>\n\n<pre><code>String.prototype.format = function format()\n{                                                                                                               \n  var msg = this;\n  for(var i in arguments)\n    msg = msg.replace(/\\{\\}/,arguments[i]).replace(new RegExp('\\\\{'+i+'\\\\}','g'),arguments[i]);\n  return msg;\n}\n</code></pre>\n"},{"score":2,"body":"<p>I did not see the <code>String.format</code> variant:</p>\n\n<pre><code>String.format = function (string) {\n    var args = Array.prototype.slice.call(arguments, 1, arguments.length);\n    return string.replace(/{(\\d+)}/g, function (match, number) {\n        return typeof args[number] != \"undefined\" ? args[number] : match;\n    });\n};\n</code></pre>\n"},{"score":7,"body":"<p>One very slightly different version, the one I prefer (this one uses {xxx} tokens rather than {0} numbered arguments, this is much more self-documenting and suits localization much better):</p>\n\n<pre><code>String.prototype.format = function(tokens) {\n  var formatted = this;\n  for (var token in tokens)\n    if (tokens.hasOwnProperty(token))\n      formatted = formatted.replace(RegExp(\"{\" + token + \"}\", \"g\"), tokens[token]);\n  return formatted;\n};\n</code></pre>\n\n<p>A variation would be:</p>\n\n<pre><code>  var formatted = l(this);\n</code></pre>\n\n<p>that calls an l() localization function first.</p>\n"},{"score":21,"body":"<p>I want to share my solution for the 'problem'. I haven't re-invented the wheel but tries to find a solution based on what JavaScript already does. The advantage is, that you get all implicit conversions for free. Setting the prototype property $ of String gives a very nice and compact syntax (see examples below). It is maybe not the most efficient way, but in most cases dealing with output it does not have to be super optimized.</p>\n\n<pre><code>String.form = function(str, arr) {\n    var i = -1;\n    function callback(exp, p0, p1, p2, p3, p4) {\n        if (exp=='%%') return '%';\n        if (arr[++i]===undefined) return undefined;\n        exp  = p2 ? parseInt(p2.substr(1)) : undefined;\n        var base = p3 ? parseInt(p3.substr(1)) : undefined;\n        var val;\n        switch (p4) {\n            case 's': val = arr[i]; break;\n            case 'c': val = arr[i][0]; break;\n            case 'f': val = parseFloat(arr[i]).toFixed(exp); break;\n            case 'p': val = parseFloat(arr[i]).toPrecision(exp); break;\n            case 'e': val = parseFloat(arr[i]).toExponential(exp); break;\n            case 'x': val = parseInt(arr[i]).toString(base?base:16); break;\n            case 'd': val = parseFloat(parseInt(arr[i], base?base:10).toPrecision(exp)).toFixed(0); break;\n        }\n        val = typeof(val)=='object' ? JSON.stringify(val) : val.toString(base);\n        var sz = parseInt(p1); /* padding size */\n        var ch = p1 &amp;&amp; p1[0]=='0' ? '0' : ' '; /* isnull? */\n        while (val.length&lt;sz) val = p0 !== undefined ? val+ch : ch+val; /* isminus? */\n       return val;\n    }\n    var regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n    return str.replace(regex, callback);\n}\n\nString.prototype.$ = function() {\n    return String.form(this, Array.prototype.slice.call(arguments));\n}\n</code></pre>\n\n<p>Here are a few examples:</p>\n\n<pre><code>String.format(\"%s %s\", [ \"This is a string\", 11 ])\nconsole.log(\"%s %s\".$(\"This is a string\", 11))\nvar arr = [ \"12.3\", 13.6 ]; console.log(\"Array: %s\".$(arr));\nvar obj = { test:\"test\", id:12 }; console.log(\"Object: %s\".$(obj));\nconsole.log(\"%c\", \"Test\");\nconsole.log(\"%5d\".$(12)); // '   12'\nconsole.log(\"%05d\".$(12)); // '00012'\nconsole.log(\"%-5d\".$(12)); // '12   '\nconsole.log(\"%5.2d\".$(123)); // '  120'\nconsole.log(\"%5.2f\".$(1.1)); // ' 1.10'\nconsole.log(\"%10.2e\".$(1.1)); // '   1.10e+0'\nconsole.log(\"%5.3p\".$(1.12345)); // ' 1.12'\nconsole.log(\"%5x\".$(45054)); // ' affe'\nconsole.log(\"%20#2x\".$(\"45054\")); // '    1010111111111110'\nconsole.log(\"%6#2d\".$(\"111\")); // '     7'\nconsole.log(\"%6#16d\".$(\"affe\")); // ' 45054'\n</code></pre>\n"},{"score":0,"body":"<p>You can use this function</p>\n\n<pre><code>            String.prototype.format = function (args) {\n            var str = this;\n            return str.replace(String.prototype.format.regex, function(item) {\n                var intVal = parseInt(item.substring(1, item.length - 1));\n                var replace;\n                if (intVal &gt;= 0) {\n                    replace = args[intVal];\n                } else if (intVal === -1) {\n                    replace = \"{\";\n                } else if (intVal === -2) {\n                    replace = \"}\";\n                } else {\n                    replace = \"\";\n                }\n                return replace;\n            });\n        };\n        String.prototype.format.regex = new RegExp(\"{-?[0-9]+}\", \"g\");\n\n        // Sample usage.\n        var str = \"She {1} {0}{2} by the {0}{3}. {-1}^_^{-2}\";\n        str = str.format([\"sea\", \"sells\", \"shells\", \"shore\"]);\n        alert(str);\n</code></pre>\n"},{"score":2,"body":"<p>For use with jQuery.ajax() success functions.  Pass only a single argument and string replace with the properties of that object as {propertyName}:</p>\n\n<pre><code>String.prototype.format = function () {\n    var formatted = this;\n    for (var prop in arguments[0]) {\n        var regexp = new RegExp('\\\\{' + prop + '\\\\}', 'gi');\n        formatted = formatted.replace(regexp, arguments[0][prop]);\n    }\n    return formatted;\n};\n</code></pre>\n\n<p>Example:</p>\n\n<pre><code>var userInfo = (\"Email: {Email} - Phone: {Phone}\").format({ Email: \"someone@somewhere.com\", Phone: \"123-123-1234\" });\n</code></pre>\n"},{"score":2,"body":"<p>With sprintf.js in place - one can make a nifty little format-thingy </p>\n\n<pre><code>String.prototype.format = function(){\n    var _args = arguments \n    Array.prototype.unshift.apply(_args,[this])\n    return sprintf.apply(undefined,_args)\n}   \n// this gives you:\n\"{%1$s}{%2$s}\".format(\"1\", \"0\")\n// {1}{0}\n</code></pre>\n"},{"score":24,"body":"<p>Adding to <code>zippoxer</code>'s answer, I use this function:</p>\n\n<pre><code>String.prototype.format = function () {\n    var a = this, b;\n    for (b in arguments) {\n        a = a.replace(/%[a-z]/, arguments[b]);\n    }\n    return a; // Make chainable\n};\n\nvar s = 'Hello %s The magic number is %d.';\ns.format('world!', 12); // Hello World! The magic number is 12.\n</code></pre>\n\n<p>I also have a non-prototype version which I use more often for its Java-like syntax:</p>\n\n<pre><code>function format() {\n    var a, b, c;\n    a = arguments[0];\n    b = [];\n    for(c = 1; c &lt; arguments.length; c++){\n        b.push(arguments[c]);\n    }\n    for (c in b) {\n        a = a.replace(/%[a-z]/, b[c]);\n    }\n    return a;\n}\nformat('%d ducks, 55 %s', 12, 'cats'); // 12 ducks, 55 cats\n</code></pre>\n\n<h2>ES 2015 update</h2>\n\n<p>All the cool new stuff in ES 2015 makes this a lot easier:</p>\n\n<pre><code>function format(fmt, ...args){\n    return fmt\n        .split(\"%%\")\n        .reduce((aggregate, chunk, i) =&gt;\n            aggregate + chunk + (args[i] || \"\"), \"\");\n}\n\nformat(\"Hello %%! I ate %% apples today.\", \"World\", 44);\n// \"Hello World, I ate 44 apples today.\"\n</code></pre>\n\n<p>I figured that since this, like the older ones, doesn't actually parse the letters, it might as well just use a single token <code>%%</code>. This has the benefit of being obvious and not making it difficult to use a single <code>%</code>. However, if you need <code>%%</code> for some reason, you would need to replace it with itself:</p>\n\n<pre><code>format(\"I love percentage signs! %%\", \"%%\");\n// \"I love percentage signs! %%\"\n</code></pre>\n"},{"score":0,"body":"<p><a href=\"http://www.bobjs.com\" rel=\"nofollow\">bobjs</a> can do this:</p>\n\n<pre><code>var sFormat = \"My name is {0} and I am {1} years old.\"; \nvar result = bob.string.formatString(sFormat, \"Bob\", 29); \nconsole.log(result); \n//output: \n//========== \n// My name is Bob and I am 29 years old. \n</code></pre>\n"},{"score":0,"body":"<pre><code>String.prototype.repeat = function(n) { \n    return new Array(++n).join(this); \n};\n\nString.prototype.pad = function(requiredLength, paddingStr, paddingType) {    \n    var n = requiredLength - this.length; \n\n    if (n) {\n        paddingType = paddingType ? paddingType.toLowerCase() : '';\n        paddingStr = paddingStr || ' ';\n        paddingStr = paddingStr.repeat( Math.ceil(n / paddingStr.length) ).substr(0, n);\n\n        if (paddingType == 'both') {\n            n /= 2;\n            return paddingStr.substr( 0, Math.ceil(n) ) + this + paddingStr.substr( 0, Math.floor(n) );\n        }   \n\n        if (paddingType == 'left') {\n            return paddingStr + this;\n        }\n\n        return this + paddingStr;\n    } \n\n    return this; \n}; \n\n// синтаксис аналогичен printf\n// 'Привет, %s!'.format('мир') -&gt; \"Привет, мир!\"\n// '%.1s.%.1s. %s'.format('Иван', 'Иванович', 'Иванов') -&gt; \"И.И. Иванов\"\nString.prototype.format = function() {\n    var i = 0, \n        params = arguments;\n\n    return this.replace(/%(?:%|(?:(|[+-]+)(|0|'.+?)([1-9]\\d*)?(?:\\.([1-9]\\d*))?)?(s|d|f))/g, function(match, sign, padding, width, precision, type) {\n        if (match == '%%') { \n            return '%'; \n        }\n\n        var v = params[i++];\n\n        if (type == 'd') { \n            v = Math.round(v); \n        }\n        else if (type == 'f') {\n            v = v.toFixed(precision ? precision : 6);\n        }\n\n        if (/\\+/.test(sign) &amp;&amp; v &gt; 0) {\n            v = '+' + v;\n        }\n\n        v += '';\n\n        if (type != 'f' &amp;&amp; precision) {\n            v = v.substr(0, precision);\n        }\n\n        if (width) {\n            v = v.pad(width, padding == '' ? ' ' : padding[0] == \"'\" ? padding.substr(1) : padding, /-/.test(sign) ? 'right' : 'left'); \n        }\n\n        return v;\n    });\n};\n\n// this.name = 'Вася';\n// console.log( 'Привет, ${name}!'.template(this) );\n// \"Привет, Вася!\"\nString.prototype.template = function(context) {\n    return this.replace(/\\$\\{(.*?)\\}/g, function(match, name) {\n        return context[name];\n    });\n};\n</code></pre>\n"},{"score":-1,"body":"<p>This is an implementation of <a href=\"https://stackoverflow.com/a/4673436/1258486\">https://stackoverflow.com/a/4673436/1258486</a> for CoffeeScript.</p>\n\n<p><a href=\"https://gist.github.com/eces/5669361\" rel=\"nofollow noreferrer\">https://gist.github.com/eces/5669361</a></p>\n\n<pre><code>if String.prototype.format is undefined\n  String.prototype.format = () -&gt;\n    _arguments = arguments\n    this.replace /{(\\d+)}/g, (match, number) -&gt;\n      if typeof _arguments[number] isnt 'undefined' then _arguments[number] else match\n</code></pre>\n"},{"score":1,"body":"<p>I needed a function which could format a price (given in cents) in a way preferred by the user, and the tricky part is that the format is specified by the user -- and I do not expect my users to understand printf-like syntax, or regexps, etc.\nMy solution is somewhat similar to that used in Basic, so the user just marks with # places for digits, for example:</p>\n\n<pre><code>simple_format(1234567,\"$ ###,###,###.##\")\n\"$ 12,345.67\"\nsimple_format(1234567,\"### ### ###,## pln\")\n\"12 345,67 pln\"\n</code></pre>\n\n<p>I believe this is quite easy to understand by user, and quite easy to implement:</p>\n\n<pre><code>function simple_format(integer,format){\n  var text = \"\";\n  for(var i=format.length;i--;){\n    if(format[i]=='#'){\n      text = (integer%10) + text;\n      integer=Math.floor(integer/10);\n      if(integer==0){\n        return format.substr(0,i).replace(/#(.*#)?/,\"\")+text;\n      }\n    }else{\n      text = format[i] + text;\n    }\n  }\n  return text;\n}\n</code></pre>\n"},{"score":512,"body":"<p>It's funny because Stack&nbsp;Overflow actually has their own formatting function for the <code>String</code> prototype called <code>formatUnicorn</code>. Try it! Go into the console and type something like:</p>\n\n<pre><code>\"Hello, {name}, are you feeling {adjective}?\".formatUnicorn({name:\"Gabriel\", adjective: \"OK\"});\n</code></pre>\n\n<p><img src=\"https://i.stack.imgur.com/jYeIc.png\" alt=\"Firebug\"></p>\n\n<p>You get this output:</p>\n\n<p><code>Hello, Gabriel, are you feeling OK?</code></p>\n\n<p>You can use objects, arrays, and strings as arguments! I got its code and reworked it to produce a new version of <code>String.prototype.format</code>:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>String.prototype.formatUnicorn = String.prototype.formatUnicorn ||\nfunction () {\n    \"use strict\";\n    var str = this.toString();\n    if (arguments.length) {\n        var t = typeof arguments[0];\n        var key;\n        var args = (\"string\" === t || \"number\" === t) ?\n            Array.prototype.slice.call(arguments)\n            : arguments[0];\n\n        for (key in args) {\n            str = str.replace(new RegExp(\"\\\\{\" + key + \"\\\\}\", \"gi\"), args[key]);\n        }\n    }\n\n    return str;\n};\n</code></pre>\n\n<p>Note the clever <code>Array.prototype.slice.call(arguments)</code> call -- that means if you throw in arguments that are strings or numbers, not a single JSON-style object, you get C#'s <a href=\"https://msdn.microsoft.com/en-us/library/system.string.format(v=vs.110).aspx#Starting\"><code>String.Format</code></a> behavior almost exactly.</p>\n\n<pre><code>\"a{0}bcd{1}ef\".formatUnicorn(\"foo\", \"bar\"); // yields \"aFOObcdBARef\"\n</code></pre>\n\n<p>That's because <code>Array</code>'s <code>slice</code> will force whatever's in <code>arguments</code> into an <code>Array</code>, whether it was originally or not, and the <code>key</code> will be the index (0, 1, 2...) of each array element coerced into a string (eg, \"0\", so <code>\"\\\\{0\\\\}\"</code> for your first regexp pattern).</p>\n\n<p>Neat.</p>\n"},{"score":9,"body":"<p>I use this one:</p>\n\n<pre><code>String.prototype.format = function() {\n    var newStr = this, i = 0;\n    while (/%s/.test(newStr))\n        newStr = newStr.replace(\"%s\", arguments[i++])\n\n    return newStr;\n}\n</code></pre>\n\n<p>Then I call it:</p>\n\n<pre><code>\"&lt;h1&gt;%s&lt;/h1&gt;&lt;p&gt;%s&lt;/p&gt;\".format(\"Header\", \"Just a test!\");\n</code></pre>\n"},{"score":75,"body":"<p>For <a href=\"http://en.wikipedia.org/wiki/Node.js\" rel=\"noreferrer\">Node.js</a> users there is <a href=\"https://nodejs.org/api/util.html#util_util_format_format_args\" rel=\"noreferrer\"><code>util.format</code></a> which has printf-like functionality:</p>\n\n<pre><code>util.format(\"%s world\", \"Hello\")\n</code></pre>\n"},{"score":9,"body":"<p>I have a solution very close to Peter's, but it deals with number and object case.</p>\n\n<pre><code>if (!String.prototype.format) {\n  String.prototype.format = function() {\n    var args;\n    args = arguments;\n    if (args.length === 1 &amp;&amp; args[0] !== null &amp;&amp; typeof args[0] === 'object') {\n      args = args[0];\n    }\n    return this.replace(/{([^}]*)}/g, function(match, key) {\n      return (typeof args[key] !== \"undefined\" ? args[key] : match);\n    });\n  };\n}\n</code></pre>\n\n<p>Maybe it could be even better to deal with the all deeps cases, but for my needs this is just fine.</p>\n\n<pre><code>\"This is an example from {name}\".format({name:\"Blaine\"});\n\"This is an example from {0}\".format(\"Blaine\");\n</code></pre>\n\n<p>PS: This function is very cool if you are using translations in templates frameworks like <a href=\"http://en.wikipedia.org/wiki/AngularJS\" rel=\"noreferrer\">AngularJS</a>:</p>\n\n<pre><code>&lt;h1&gt; {{('hello-message'|translate).format(user)}} &lt;h1&gt;\n&lt;h1&gt; {{('hello-by-name'|translate).format( user ? user.name : 'You' )}} &lt;h1&gt;\n</code></pre>\n\n<p>Where the en.json is something like</p>\n\n<pre><code>{\n    \"hello-message\": \"Hello {name}, welcome.\",\n    \"hello-by-name\": \"Hello {0}, welcome.\"\n}\n</code></pre>\n"},{"score":2,"body":"<p>I didn't see <a href=\"https://www.npmjs.org/package/pyformat\" rel=\"nofollow\">pyformat</a> in the list so I thought I'd throw it in:</p>\n\n<pre><code>console.log(pyformat( 'The {} {} jumped over the {}'\n                , ['brown' ,'fox' ,'foobar']\n                ))\nconsole.log(pyformat('The {0} {1} jumped over the {1}'\n                , ['brown' ,'fox' ,'foobar']\n                ))\nconsole.log(pyformat('The {color} {animal} jumped over the {thing}'\n                , [] ,{color: 'brown' ,animal: 'fox' ,thing: 'foobaz'}\n                ))\n</code></pre>\n"},{"score":0,"body":"<p>I started porting the <code>Java</code> <code>String.format</code> (actually new Formatter().format()) to javascript. The initial version is available at: </p>\n\n<p><a href=\"https://github.com/RobAu/javascript.string.format\" rel=\"nofollow\">https://github.com/RobAu/javascript.string.format</a></p>\n\n<p>You can simple add the javscript and call <code>StringFormat.format(\"%.2f\", [2.4]);</code> etc.</p>\n\n<p>Please note it is NOT finished yet, but feedback is welcome :) </p>\n"},{"score":5,"body":"<p>Just in case someone needs a function to prevent polluting global scope, here is the function that does the same:</p>\n\n<pre><code>  function _format (str, arr) {\n    return str.replace(/{(\\d+)}/g, function (match, number) {\n      return typeof arr[number] != 'undefined' ? arr[number] : match;\n    });\n  };\n</code></pre>\n"},{"score":5,"body":"<p>For those who like <a href=\"http://nodejs.org\">Node.JS</a> and its <a href=\"http://nodejs.org/api/util.html#util_util_format_format\"><code>util.format</code></a> feature, I've just extracted it out into its vanilla JavaScript form (with only functions that util.format uses):</p>\n\n<pre><code>exports = {};\n\nfunction isString(arg) {\n    return typeof arg === 'string';\n}\nfunction isNull(arg) {\n    return arg === null;\n}\nfunction isObject(arg) {\n    return typeof arg === 'object' &amp;&amp; arg !== null;\n}\nfunction isBoolean(arg) {\n    return typeof arg === 'boolean';\n}\nfunction isUndefined(arg) {\n    return arg === void 0;\n}\nfunction stylizeNoColor(str, styleType) {\n    return str;\n}\nfunction stylizeWithColor(str, styleType) {\n    var style = inspect.styles[styleType];\n\n    if (style) {\n        return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n            '\\u001b[' + inspect.colors[style][3] + 'm';\n    } else {\n        return str;\n    }\n}\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\nfunction isNumber(arg) {\n    return typeof arg === 'number';\n}\nfunction isSymbol(arg) {\n    return typeof arg === 'symbol';\n}\nfunction formatPrimitive(ctx, value) {\n    if (isUndefined(value))\n        return ctx.stylize('undefined', 'undefined');\n    if (isString(value)) {\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                .replace(/'/g, \"\\\\'\")\n                .replace(/\\\\\"/g, '\"') + '\\'';\n        return ctx.stylize(simple, 'string');\n    }\n    if (isNumber(value)) {\n        // Format -0 as '-0'. Strict equality won't distinguish 0 from -0,\n        // so instead we use the fact that 1 / -0 &lt; 0 whereas 1 / 0 &gt; 0 .\n        if (value === 0 &amp;&amp; 1 / value &lt; 0)\n            return ctx.stylize('-0', 'number');\n        return ctx.stylize('' + value, 'number');\n    }\n    if (isBoolean(value))\n        return ctx.stylize('' + value, 'boolean');\n    // For some reason typeof null is \"object\", so special case here.\n    if (isNull(value))\n        return ctx.stylize('null', 'null');\n    // es6 symbol primitive\n    if (isSymbol(value))\n        return ctx.stylize(value.toString(), 'symbol');\n}\nfunction arrayToHash(array) {\n    var hash = {};\n\n    array.forEach(function (val, idx) {\n        hash[val] = true;\n    });\n\n    return hash;\n}\nfunction objectToString(o) {\n    return Object.prototype.toString.call(o);\n}\nfunction isDate(d) {\n    return isObject(d) &amp;&amp; objectToString(d) === '[object Date]';\n}\nfunction isError(e) {\n    return isObject(e) &amp;&amp;\n        (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nfunction isRegExp(re) {\n    return isObject(re) &amp;&amp; objectToString(re) === '[object RegExp]';\n}\nfunction formatError(value) {\n    return '[' + Error.prototype.toString.call(value) + ']';\n}\nfunction formatPrimitiveNoColor(ctx, value) {\n    var stylize = ctx.stylize;\n    ctx.stylize = stylizeNoColor;\n    var str = formatPrimitive(ctx, value);\n    ctx.stylize = stylize;\n    return str;\n}\nfunction isArray(ar) {\n    return Array.isArray(ar);\n}\nfunction hasOwnProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    var name, str, desc;\n    desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};\n    if (desc.get) {\n        if (desc.set) {\n            str = ctx.stylize('[Getter/Setter]', 'special');\n        } else {\n            str = ctx.stylize('[Getter]', 'special');\n        }\n    } else {\n        if (desc.set) {\n            str = ctx.stylize('[Setter]', 'special');\n        }\n    }\n    if (!hasOwnProperty(visibleKeys, key)) {\n        name = '[' + key + ']';\n    }\n    if (!str) {\n        if (ctx.seen.indexOf(desc.value) &lt; 0) {\n            if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, null);\n            } else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n            }\n            if (str.indexOf('\\n') &gt; -1) {\n                if (array) {\n                    str = str.split('\\n').map(function (line) {\n                        return '  ' + line;\n                    }).join('\\n').substr(2);\n                } else {\n                    str = '\\n' + str.split('\\n').map(function (line) {\n                        return '   ' + line;\n                    }).join('\\n');\n                }\n            }\n        } else {\n            str = ctx.stylize('[Circular]', 'special');\n        }\n    }\n    if (isUndefined(name)) {\n        if (array &amp;&amp; key.match(/^\\d+$/)) {\n            return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            name = name.substr(1, name.length - 2);\n            name = ctx.stylize(name, 'name');\n        } else {\n            name = name.replace(/'/g, \"\\\\'\")\n                .replace(/\\\\\"/g, '\"')\n                .replace(/(^\"|\"$)/g, \"'\")\n                .replace(/\\\\\\\\/g, '\\\\');\n            name = ctx.stylize(name, 'string');\n        }\n    }\n\n    return name + ': ' + str;\n}\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    var output = [];\n    for (var i = 0, l = value.length; i &lt; l; ++i) {\n        if (hasOwnProperty(value, String(i))) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                String(i), true));\n        } else {\n            output.push('');\n        }\n    }\n    keys.forEach(function (key) {\n        if (!key.match(/^\\d+$/)) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n                key, true));\n        }\n    });\n    return output;\n}\nfunction reduceToSingleString(output, base, braces) {\n    var length = output.reduce(function (prev, cur) {\n        return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n    }, 0);\n\n    if (length &gt; 60) {\n        return braces[0] +\n            (base === '' ? '' : base + '\\n ') +\n            ' ' +\n            output.join(',\\n  ') +\n            ' ' +\n            braces[1];\n    }\n\n    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\nfunction formatValue(ctx, value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (ctx.customInspect &amp;&amp;\n        value &amp;&amp;\n        isFunction(value.inspect) &amp;&amp;\n            // Filter out the util module, it's inspect function is special\n        value.inspect !== exports.inspect &amp;&amp;\n            // Also filter out any prototype objects using the circular check.\n        !(value.constructor &amp;&amp; value.constructor.prototype === value)) {\n        var ret = value.inspect(recurseTimes, ctx);\n        if (!isString(ret)) {\n            ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n    }\n\n    // Primitive types cannot have properties\n    var primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n        return primitive;\n    }\n\n    // Look up the keys of the object.\n    var keys = Object.keys(value);\n    var visibleKeys = arrayToHash(keys);\n\n    if (ctx.showHidden) {\n        keys = Object.getOwnPropertyNames(value);\n    }\n\n    // This could be a boxed primitive (new String(), etc.), check valueOf()\n    // NOTE: Avoid calling `valueOf` on `Date` instance because it will return\n    // a number which, when object has some additional user-stored `keys`,\n    // will be printed out.\n    var formatted;\n    var raw = value;\n    try {\n        // the .valueOf() call can fail for a multitude of reasons\n        if (!isDate(value))\n            raw = value.valueOf();\n    } catch (e) {\n        // ignore...\n    }\n\n    if (isString(raw)) {\n        // for boxed Strings, we have to remove the 0-n indexed entries,\n        // since they just noisey up the output and are redundant\n        keys = keys.filter(function (key) {\n            return !(key &gt;= 0 &amp;&amp; key &lt; raw.length);\n        });\n    }\n\n    // Some type of object without properties can be shortcutted.\n    if (keys.length === 0) {\n        if (isFunction(value)) {\n            var name = value.name ? ': ' + value.name : '';\n            return ctx.stylize('[Function' + name + ']', 'special');\n        }\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n        }\n        if (isDate(value)) {\n            return ctx.stylize(Date.prototype.toString.call(value), 'date');\n        }\n        if (isError(value)) {\n            return formatError(value);\n        }\n        // now check the `raw` value to handle boxed primitives\n        if (isString(raw)) {\n            formatted = formatPrimitiveNoColor(ctx, raw);\n            return ctx.stylize('[String: ' + formatted + ']', 'string');\n        }\n        if (isNumber(raw)) {\n            formatted = formatPrimitiveNoColor(ctx, raw);\n            return ctx.stylize('[Number: ' + formatted + ']', 'number');\n        }\n        if (isBoolean(raw)) {\n            formatted = formatPrimitiveNoColor(ctx, raw);\n            return ctx.stylize('[Boolean: ' + formatted + ']', 'boolean');\n        }\n    }\n\n    var base = '', array = false, braces = ['{', '}'];\n\n    // Make Array say that they are Array\n    if (isArray(value)) {\n        array = true;\n        braces = ['[', ']'];\n    }\n\n    // Make functions say that they are functions\n    if (isFunction(value)) {\n        var n = value.name ? ': ' + value.name : '';\n        base = ' [Function' + n + ']';\n    }\n\n    // Make RegExps say that they are RegExps\n    if (isRegExp(value)) {\n        base = ' ' + RegExp.prototype.toString.call(value);\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n        base = ' ' + Date.prototype.toUTCString.call(value);\n    }\n\n    // Make error with message first say the error\n    if (isError(value)) {\n        base = ' ' + formatError(value);\n    }\n\n    // Make boxed primitive Strings look like such\n    if (isString(raw)) {\n        formatted = formatPrimitiveNoColor(ctx, raw);\n        base = ' ' + '[String: ' + formatted + ']';\n    }\n\n    // Make boxed primitive Numbers look like such\n    if (isNumber(raw)) {\n        formatted = formatPrimitiveNoColor(ctx, raw);\n        base = ' ' + '[Number: ' + formatted + ']';\n    }\n\n    // Make boxed primitive Booleans look like such\n    if (isBoolean(raw)) {\n        formatted = formatPrimitiveNoColor(ctx, raw);\n        base = ' ' + '[Boolean: ' + formatted + ']';\n    }\n\n    if (keys.length === 0 &amp;&amp; (!array || value.length === 0)) {\n        return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes &lt; 0) {\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n        } else {\n            return ctx.stylize('[Object]', 'special');\n        }\n    }\n\n    ctx.seen.push(value);\n\n    var output;\n    if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    } else {\n        output = keys.map(function (key) {\n            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n    }\n\n    ctx.seen.pop();\n\n    return reduceToSingleString(output, base, braces);\n}\nfunction inspect(obj, opts) {\n    // default options\n    var ctx = {\n        seen: [],\n        stylize: stylizeNoColor\n    };\n    // legacy...\n    if (arguments.length &gt;= 3) ctx.depth = arguments[2];\n    if (arguments.length &gt;= 4) ctx.colors = arguments[3];\n    if (isBoolean(opts)) {\n        // legacy...\n        ctx.showHidden = opts;\n    } else if (opts) {\n        // got an \"options\" object\n        exports._extend(ctx, opts);\n    }\n    // set default options\n    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n    if (isUndefined(ctx.depth)) ctx.depth = 2;\n    if (isUndefined(ctx.colors)) ctx.colors = false;\n    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n    if (ctx.colors) ctx.stylize = stylizeWithColor;\n    return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n    'bold': [1, 22],\n    'italic': [3, 23],\n    'underline': [4, 24],\n    'inverse': [7, 27],\n    'white': [37, 39],\n    'grey': [90, 39],\n    'black': [30, 39],\n    'blue': [34, 39],\n    'cyan': [36, 39],\n    'green': [32, 39],\n    'magenta': [35, 39],\n    'red': [31, 39],\n    'yellow': [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n    'special': 'cyan',\n    'number': 'yellow',\n    'boolean': 'yellow',\n    'undefined': 'grey',\n    'null': 'bold',\n    'string': 'green',\n    'symbol': 'green',\n    'date': 'magenta',\n    // \"name\": intentionally not styling\n    'regexp': 'red'\n};\n\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function (f) {\n    if (!isString(f)) {\n        var objects = [];\n        for (var j = 0; j &lt; arguments.length; j++) {\n            objects.push(inspect(arguments[j]));\n        }\n        return objects.join(' ');\n    }\n\n    var i = 1;\n    var args = arguments;\n    var len = args.length;\n    var str = String(f).replace(formatRegExp, function (x) {\n        if (x === '%%') return '%';\n        if (i &gt;= len) return x;\n        switch (x) {\n            case '%s':\n                return String(args[i++]);\n            case '%d':\n                return Number(args[i++]);\n            case '%j':\n                try {\n                    return JSON.stringify(args[i++]);\n                } catch (_) {\n                    return '[Circular]';\n                }\n            default:\n                return x;\n        }\n    });\n    for (var x = args[i]; i &lt; len; x = args[++i]) {\n        if (isNull(x) || !isObject(x)) {\n            str += ' ' + x;\n        } else {\n            str += ' ' + inspect(x);\n        }\n    }\n    return str;\n};\n</code></pre>\n\n<p>Harvested from: <a href=\"https://github.com/joyent/node/blob/master/lib/util.js\">https://github.com/joyent/node/blob/master/lib/util.js</a></p>\n"},{"score":54,"body":"<p>I'm surprised no one used <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\" rel=\"noreferrer\"><code>reduce</code></a>, this is a native concise and powerful JavaScript function.</p>\n\n<h2>ES6 (EcmaScript2015)</h2>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>String.prototype.format = function() {\r\n  return [...arguments].reduce((p,c) =&gt; p.replace(/%s/,c), this);\r\n};\r\n\r\nconsole.log('Is that a %s or a %s?... No, it\\'s %s!'.format('plane', 'bird', 'SOman'));</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<h2>&lt; ES6</h2>\n\n<pre><code>function interpolate(theString, argumentArray) {\n    var regex = /%s/;\n    var _r=function(p,c){return p.replace(regex,c);}\n    return argumentArray.reduce(_r, theString);\n}\n\ninterpolate(\"%s, %s and %s\", [\"Me\", \"myself\", \"I\"]); // \"Me, myself and I\"\n</code></pre>\n\n<p>How it works:</p>\n\n<blockquote>\n  <p><em>reduce</em> applies a function against an accumulator and each element in the array (from left to right) to reduce it to a single value.</p>\n</blockquote>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var _r= function(p,c){return p.replace(/%s/,c)};\r\n\r\nconsole.log(\r\n  [\"a\", \"b\", \"c\"].reduce(_r, \"[%s], [%s] and [%s]\") + '\\n',\r\n  [1, 2, 3].reduce(_r, \"%s+%s=%s\") + '\\n',\r\n  [\"cool\", 1337, \"stuff\"].reduce(_r, \"%s %s %s\")\r\n);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":254,"body":"<p>From ES6 on you could use <strong>template strings</strong>:</p>\n\n<pre><code>let soMany = 10;\nconsole.log(`This is ${soMany} times easier!`);\n// \"This is 10 times easier!\n</code></pre>\n\n<p>Be aware that template strings are <strong>surrounded by backticks</strong> ` instead of (single) quotes.</p>\n\n<p>For further information:</p>\n\n<p><a href=\"https://developers.google.com/web/updates/2015/01/ES6-Template-Strings\">https://developers.google.com/web/updates/2015/01/ES6-Template-Strings</a></p>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings</a></p>\n\n<p><em>Note:\nCheck the mozilla-site to find a list of supported browsers.</em></p>\n"},{"score":6,"body":"<p>For basic formatting: </p>\n\n<pre><code>var template = jQuery.validator.format(\"{0} is not a valid value\");\nvar result = template(\"abc\");\n</code></pre>\n"},{"score":2,"body":"<pre><code>/**\n * Format string by replacing placeholders with value from element with\n * corresponsing index in `replacementArray`.\n * Replaces are made simultaneously, so that replacement values like\n * '{1}' will not mess up the function.\n *\n * Example 1:\n * ('{2} {1} {0}', ['three', 'two' ,'one']) -&gt; 'one two three'\n *\n * Example 2:\n * ('{0}{1}', ['{1}', '{0}']) -&gt; '{1}{0}'\n */\nfunction stringFormat(formatString, replacementArray) {\n    return formatString.replace(\n        /\\{(\\d+)\\}/g, // Matches placeholders, e.g. '{1}'\n        function formatStringReplacer(match, placeholderIndex) {\n            // Convert String to Number\n            placeholderIndex = Number(placeholderIndex);\n\n            // Make sure that index is within replacement array bounds\n            if (placeholderIndex &lt; 0 ||\n                placeholderIndex &gt; replacementArray.length - 1\n            ) {\n                return placeholderIndex;\n            }\n\n            // Replace placeholder with value from replacement array\n            return replacementArray[placeholderIndex];\n        }\n    );\n}\n</code></pre>\n"},{"score":0,"body":"<p>This is not an exact duplicate of <code>sprintf</code>; however, it is similar and more powerful: <a href=\"https://github.com/anywhichway/stringformatter\" rel=\"nofollow\">https://github.com/anywhichway/stringformatter</a></p>\n\n<p>Format expressions using this library take the form of embedded Javascript objects, e.g.</p>\n\n<pre><code>format(\"I have {number: {currency: \"$\", precision:2}}.\",50.2); \n</code></pre>\n\n<p>will return <code>\"I have $50.20.\"</code>.</p>\n"},{"score":2,"body":"<p>Using <a href=\"https://lodash.com/\" rel=\"nofollow noreferrer\">Lodash</a> you can get template functionality:</p>\n\n<p>Use the ES template literal delimiter as an \"interpolate\" delimiter.\nDisable support by replacing the \"interpolate\" delimiter.</p>\n\n<pre><code>var compiled = _.template('hello ${ user }!');\ncompiled({ 'user': 'pebbles' });\n// =&gt; 'hello pebbles!\n</code></pre>\n"},{"score":1,"body":"<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>String.prototype.format = function(){\r\n    var final = String(this);\r\n    for(let i=0; i&lt;arguments.length;i++){\r\n        final = final.replace(`%s${i+1}`, arguments[i])\r\n    }\r\n    return final || ''\r\n}\r\n\r\nconsole.log((\"hello %s2 how %s3 you %s1\").format('hi', 'hello', 'how'));</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;h1 id=\"text\"&gt;\r\n   \r\n&lt;/h1&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":3,"body":"<p>We can use a simple lightweight <a href=\"https://github.com/sevensc/typescript-string-operations#stringformat\" rel=\"nofollow noreferrer\">String.Format</a> string operation library for Typescript.</p>\n\n<p><strong>String.Format():</strong></p>\n\n<pre><code>var id = image.GetId()\nString.Format(\"image_{0}.jpg\", id)\noutput: \"image_2db5da20-1c5d-4f1a-8fd4-b41e34c8c5b5.jpg\";\n</code></pre>\n\n<p><strong>String Format for specifiers:</strong></p>\n\n<pre><code>var value = String.Format(\"{0:L}\", \"APPLE\"); //output \"apple\"\n\nvalue = String.Format(\"{0:U}\", \"apple\"); // output \"APPLE\"\n\nvalue = String.Format(\"{0:d}\", \"2017-01-23 00:00\"); //output \"23.01.2017\"\n\n\nvalue = String.Format(\"{0:s}\", \"21.03.2017 22:15:01\") //output \"2017-03-21T22:15:01\"\n\nvalue = String.Format(\"{0:n}\", 1000000);\n//output \"1.000.000\"\n\nvalue = String.Format(\"{0:00}\", 1);\n//output \"01\"\n</code></pre>\n\n<p><strong>String Format for Objects including specifiers:</strong></p>\n\n<pre><code>var fruit = new Fruit();\nfruit.type = \"apple\";\nfruit.color = \"RED\";\nfruit.shippingDate = new Date(2018, 1, 1);\nfruit.amount = 10000;\n\nString.Format(\"the {type:U} is {color:L} shipped on {shippingDate:s} with an amount of {amount:n}\", fruit);\n// output: the APPLE is red shipped on 2018-01-01 with an amount of 10.000\n</code></pre>\n"},{"score":0,"body":"<pre><code>export function stringFormate (str: string, ...args: string[]) {\n     return args.reduce((acc, curr, i) =&gt; acc.replace(new RegExp(\"\\\\{\" + i + \"\\\\}\", 'g'), curr), str);\n}\n</code></pre>\n"},{"score":1,"body":"<p>In typescript create a file named <code>format.ts</code> and import it whatever you need to use formatting.</p>\n\n<pre><code>// contents of format.ts\n\ninterface String {\n  format(...args: any[]): string;\n}\n\nif (!String.prototype.format) {\n  String.prototype.format = function() {\n    let a = this;\n    let b: any;\n    // tslint:disable-next-line: forin\n    for (b in arguments) {\n      a = a.replace(/%[a-z]/, arguments[b]);\n    }\n    return a;\n  };\n}\n</code></pre>\n\n<p>To format string use this code:</p>\n\n<pre><code>import './format';\n\nconsole.log('Hello, %s!'.format('World'));\n</code></pre>\n\n<h2>Example</h2>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>String.prototype.format = function() {\r\n  let a = this;\r\n  let b;\r\n  for (b in arguments) {\r\n    a = a.replace(/%[a-z]/, arguments[b]);\r\n  }\r\n  return a;\r\n};\r\n\r\nconsole.log('Hello, %s!'.format('World'));</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":1,"body":"<p><strong>another suggestion is you use the string template:</strong></p>\n\n<pre><code>const getPathDadosCidades = (id: string) =&gt;  `/clientes/${id}`\n\nconst getPathDadosCidades = (id: string, role: string) =&gt;  `/clientes/${id}/roles/${role}`\n</code></pre>\n"},{"score":0,"body":"<p>Not the most recommended function in the world, but it works.</p>\n<p>If you need sprintf, just copy &amp; paste this same function and change <code>return console.log(sb)</code> to just <code>return sb</code>.</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>printf = function(s, /*args...*/) {\n    a = arguments;\n    al = a.length;\n    \n    if (al &lt;= 1) return -2;\n    if (al &gt;= 2 &amp;&amp; s.toLowerCase().search(/%[a-z]/) == -1) return -1;\n\n    sb = s;\n    for (i = 1; i &lt;= al - 1; i++) {\n        sb = sb.replace(/%[a-z]/, a[i]);\n    }\n\n    return console.log(sb);\n}\n\nvar someString = \"Hello %s\\nIt's %s:%s %s now.\\nThe day is %s\\n\";\nprintf(someString, \"StackOverflowUser\", \"5\", \"48\", \"PM\", \"beautiful\");</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":0,"body":"<p>if you just need to format a string with <strong>%s specifier</strong> only</p>\n<pre><code>function _sprintf(message){\n    const regexp = RegExp('%s','g');\n    let match;\n    let index = 1;\n    while((match = regexp.exec(message)) !== null) {\n        let replacement = arguments[index];\n        if (replacement) {\n            let messageToArray = message.split('');\n            messageToArray.splice(match.index, regexp.lastIndex - match.index, replacement);\n            message = messageToArray.join('');\n            index++;\n        } else {\n            break;\n        }\n    }\n\n    return message;\n}\n\n_sprintf(&quot;my name is %s, my age is %s&quot;, &quot;bob&quot;, 50); // my name is bob, my age is 50\n</code></pre>\n"},{"score":0,"body":"<p><strong>sprintf()</strong> function analog in JavaScript as <strong>Vue filter</strong> and <strong>String.prototype.format()</strong> extension:</p>\n<pre><code>/**\n * Returns a formatted string.\n *\n * @param template\n * @param values\n * @return string\n */\nString.format = function (template, ...values) {\n    let i = -1;\n\n    function callback(exp, p0, p1, p2, p3, p4) {\n        if (exp === '%%') return '%';\n        if (values[++i] === undefined) return undefined;\n\n        exp = p2 ? parseInt(p2.substr(1)) : undefined;\n\n        let base = p3 ? parseInt(p3.substr(1)) : undefined;\n        let val;\n\n        switch (p4) {\n            case 's': val = values[i]; break;\n            case 'c': val = values[i][0]; break;\n            case 'f': val = parseFloat(values[i]).toFixed(exp); break;\n            case 'p': val = parseFloat(values[i]).toPrecision(exp); break;\n            case 'e': val = parseFloat(values[i]).toExponential(exp); break;\n            case 'x': val = parseInt(values[i]).toString(base ? base : 16); break;\n            case 'd': val = parseFloat(parseInt(values[i], base ? base : 10).toPrecision(exp)).toFixed(0); break;\n        }\n        val = typeof (val) == 'object' ? JSON.stringify(val) : val.toString(base);\n        let sz = parseInt(p1); /* padding size */\n        let ch = p1 &amp;&amp; p1[0] === '0' ? '0' : ' '; /* isnull? */\n\n        while (val.length &lt; sz) val = p0 !== undefined ? val + ch : ch + val; /* isminus? */\n\n        return val;\n    }\n\n    let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;\n\n    return template.replace(regex, callback);\n}\n\nString.prototype.format = function() {\n    return String.format(this, ...arguments);\n}\n\nconst StringFormat = {\n    install: (Vue, options) =&gt; {\n        Vue.filter('format', function () {\n            return String.format(...arguments);\n        });\n    },\n};\n\nexport default StringFormat;\n</code></pre>\n<p>Original answer: <a href=\"https://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format/13439711#13439711\">JavaScript equivalent to printf/String.Format</a></p>\n"}],"score":2047}