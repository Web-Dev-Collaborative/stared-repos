{"body":"<p>What is the most efficient way to clone a JavaScript object? I've seen <code>obj = eval(uneval(o));</code> being used, but <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/uneval\" rel=\"noreferrer\">that's non-standard and only supported by Firefox</a>.<br/><br/> I've done things like <code>obj = JSON.parse(JSON.stringify(o));</code> but question the efficiency. <br/><br/> I've also seen recursive copying functions with various flaws.\n<br />\nI'm surprised no canonical solution exists.</p>\n","title":"What is the most efficient way to deep clone an object in JavaScript?","answers":[{"score":331,"body":"<p>If there wasn't any builtin one, you could try:</p>\n\n<pre><code>function clone(obj) {\n    if (obj === null || typeof (obj) !== 'object' || 'isActiveClone' in obj)\n        return obj;\n\n    if (obj instanceof Date)\n        var temp = new obj.constructor(); //or new Date(obj);\n    else\n        var temp = obj.constructor();\n\n    for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            obj['isActiveClone'] = null;\n            temp[key] = clone(obj[key]);\n            delete obj['isActiveClone'];\n        }\n    }\n    return temp;\n}\n</code></pre>\n"},{"score":21,"body":"<pre><code>function clone(obj)\n { var clone = {};\n   clone.prototype = obj.prototype;\n   for (property in obj) clone[property] = obj[property];\n   return clone;\n }\n</code></pre>\n"},{"score":4918,"body":"<h1>Native deep cloning</h1>\n\n<p>It's called \"structured cloning\", works experimentally in Node 11 and later, and hopefully will land in browsers. See <a href=\"https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/10916838#10916838\">this answer</a> for more details.</p>\n\n<h1>Fast cloning with data loss - JSON.parse/stringify</h1>\n\n<p>If you do not use <code>Date</code>s, functions, <code>undefined</code>, <code>Infinity</code>, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays or other complex types within your object, a very simple one liner to deep clone an object is:</p>\n\n<p><code>JSON.parse(JSON.stringify(object))</code></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const a = {\r\n  string: 'string',\r\n  number: 123,\r\n  bool: false,\r\n  nul: null,\r\n  date: new Date(),  // stringified\r\n  undef: undefined,  // lost\r\n  inf: Infinity,  // forced to 'null'\r\n  re: /.*/,  // lost\r\n}\r\nconsole.log(a);\r\nconsole.log(typeof a.date);  // Date object\r\nconst clone = JSON.parse(JSON.stringify(a));\r\nconsole.log(clone);\r\nconsole.log(typeof clone.date);  // result of .toISOString()</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>See <a href=\"https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/5344074#5344074\">Corban's answer</a> for benchmarks.</p>\n\n<h1>Reliable cloning using a library</h1>\n\n<p>Since cloning objects is not trivial (complex types, circular references, function etc.), most major libraries provide function to clone objects. <strong>Don't reinvent the wheel</strong> - if you're already using a library, check if it has an object cloning function. For example,</p>\n\n<ul>\n<li>lodash - <a href=\"https://lodash.com/docs#cloneDeep\" rel=\"noreferrer\"><code>cloneDeep</code></a>; can be imported separately via the <a href=\"https://www.npmjs.com/package/lodash.clonedeep\" rel=\"noreferrer\">lodash.clonedeep</a> module and is probably your best choice if you're not already using a library that provides a deep cloning function</li>\n<li>AngularJS - <a href=\"https://docs.angularjs.org/api/ng/function/angular.copy\" rel=\"noreferrer\"><code>angular.copy</code></a></li>\n<li>jQuery - <a href=\"https://api.jquery.com/jquery.extend/#jQuery-extend-deep-target-object1-objectN\" rel=\"noreferrer\"><code>jQuery.extend(true, { }, oldObject)</code></a>; <code>.clone()</code> only clones DOM elements</li>\n</ul>\n\n<h1>ES6</h1>\n\n<p>For completeness, note that ES6 offers two shallow copy mechanisms: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" rel=\"noreferrer\"><code>Object.assign()</code></a> and the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\" rel=\"noreferrer\">spread syntax</a>.\nwhich copies values of all enumerable own properties from one object to another. For example:</p>\n\n<pre><code>var A1 = {a: \"2\"};\nvar A2 = Object.assign({}, A1);\nvar A3 = {...A1};  // Spread Syntax\n</code></pre>\n"},{"score":101,"body":"<p>Code:</p>\n\n<pre><code>// extends 'from' object with members from 'to'. If 'to' is null, a deep clone of 'from' is returned\nfunction extend(from, to)\n{\n    if (from == null || typeof from != \"object\") return from;\n    if (from.constructor != Object &amp;&amp; from.constructor != Array) return from;\n    if (from.constructor == Date || from.constructor == RegExp || from.constructor == Function ||\n        from.constructor == String || from.constructor == Number || from.constructor == Boolean)\n        return new from.constructor(from);\n\n    to = to || new from.constructor();\n\n    for (var name in from)\n    {\n        to[name] = typeof to[name] == \"undefined\" ? extend(from[name], null) : to[name];\n    }\n\n    return to;\n}\n</code></pre>\n\n<p>Test:</p>\n\n<pre><code>var obj =\n{\n    date: new Date(),\n    func: function(q) { return 1 + q; },\n    num: 123,\n    text: \"asdasd\",\n    array: [1, \"asd\"],\n    regex: new RegExp(/aaa/i),\n    subobj:\n    {\n        num: 234,\n        text: \"asdsaD\"\n    }\n}\n\nvar clone = extend(obj);\n</code></pre>\n"},{"score":101,"body":"<p>This is what I'm using:</p>\n\n<pre><code>function cloneObject(obj) {\n    var clone = {};\n    for(var i in obj) {\n        if(typeof(obj[i])==\"object\" &amp;&amp; obj[i] != null)\n            clone[i] = cloneObject(obj[i]);\n        else\n            clone[i] = obj[i];\n    }\n    return clone;\n}\n</code></pre>\n"},{"score":65,"body":"<pre><code>var clone = function() {\n    var newObj = (this instanceof Array) ? [] : {};\n    for (var i in this) {\n        if (this[i] &amp;&amp; typeof this[i] == \"object\") {\n            newObj[i] = this[i].clone();\n        }\n        else\n        {\n            newObj[i] = this[i];\n        }\n    }\n    return newObj;\n}; \n\nObject.defineProperty( Object.prototype, \"clone\", {value: clone, enumerable: false});\n</code></pre>\n"},{"score":12,"body":"<pre><code>// obj target object, vals source object\nvar setVals = function (obj, vals) {\n    if (obj &amp;&amp; vals) {\n        for (var x in vals) {\n            if (vals.hasOwnProperty(x)) {\n                if (obj[x] &amp;&amp; typeof vals[x] === 'object') {\n                    obj[x] = setVals(obj[x], vals[x]);\n                } else {\n                    obj[x] = vals[x];\n                }\n            }\n        }\n    }\n    return obj;\n};\n</code></pre>\n"},{"score":23,"body":"<p>Crockford suggests (and I prefer) using this function:</p>\n\n<pre><code>function object(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nvar newObject = object(oldObject);\n</code></pre>\n\n<p>It's terse, works as expected and you don't need a library.</p>\n\n<hr>\n\n<p><strong>EDIT:</strong></p>\n\n<p>This is a polyfill for <code>Object.create</code>, so you also can use this.</p>\n\n<pre><code>var newObject = Object.create(oldObject);\n</code></pre>\n\n<p><strong>NOTE:</strong>  If you use some of this, you may have problems with some iteration who use <code>hasOwnProperty</code>. Because, <code>create</code> create new empty object who inherits <code>oldObject</code>. But it is still useful and practical for cloning objects.</p>\n\n<p>For exemple if  <code>oldObject.a = 5;</code></p>\n\n<pre><code>newObject.a; // is 5\n</code></pre>\n\n<p>but:</p>\n\n<pre><code>oldObject.hasOwnProperty(a); // is true\nnewObject.hasOwnProperty(a); // is false\n</code></pre>\n"},{"score":17,"body":"<p>There seems to be no ideal deep clone operator yet for array-like objects.  As the code below illustrates, John Resig's jQuery cloner turns arrays with non-numeric properties into objects that are not arrays, and RegDwight's JSON cloner drops the non-numeric properties. The following tests illustrate these points on multiple browsers:</p>\n\n<pre><code>function jQueryClone(obj) {\n   return jQuery.extend(true, {}, obj)\n}\n\nfunction JSONClone(obj) {\n   return JSON.parse(JSON.stringify(obj))\n}\n\nvar arrayLikeObj = [[1, \"a\", \"b\"], [2, \"b\", \"a\"]];\narrayLikeObj.names = [\"m\", \"n\", \"o\"];\nvar JSONCopy = JSONClone(arrayLikeObj);\nvar jQueryCopy = jQueryClone(arrayLikeObj);\n\nalert(\"Is arrayLikeObj an array instance?\" + (arrayLikeObj instanceof Array) +\n      \"\\nIs the jQueryClone an array instance? \" + (jQueryCopy instanceof Array) +\n      \"\\nWhat are the arrayLikeObj names? \" + arrayLikeObj.names +\n      \"\\nAnd what are the JSONClone names? \" + JSONCopy.names)\n</code></pre>\n"},{"score":492,"body":"<p>Assuming that you have only variables and not any functions in your object, you can  just use:</p>\n\n<pre><code>var newObject = JSON.parse(JSON.stringify(oldObject));\n</code></pre>\n"},{"score":2311,"body":"<p>Checkout this benchmark: <a href=\"http://jsben.ch/#/bWfk9\" rel=\"noreferrer\">http://jsben.ch/#/bWfk9</a></p>\n\n<p>In my previous tests where speed was a main concern I found </p>\n\n<pre><code>JSON.parse(JSON.stringify(obj))\n</code></pre>\n\n<p>to be the slowest way to deep clone an object (it is slower than <a href=\"https://api.jquery.com/jQuery.extend/\" rel=\"noreferrer\">jQuery.extend</a> with <code>deep</code> flag set true by 10-20%).</p>\n\n<p>jQuery.extend is pretty fast when the <code>deep</code> flag is set to <code>false</code> (shallow clone). It is a good option, because it includes some extra logic for type validation and doesn't copy over undefined properties, etc., but this will also slow you down a little.</p>\n\n<p>If you know the structure of the objects you are trying to clone or can avoid deep nested arrays you can write a simple <code>for (var i in obj)</code> loop to clone your object while checking hasOwnProperty and it will be much much faster than jQuery.</p>\n\n<p>Lastly if you are attempting to clone a known object structure in a hot loop you can get MUCH MUCH MORE PERFORMANCE by simply in-lining the clone procedure and manually constructing the object.</p>\n\n<p>JavaScript trace engines suck at optimizing <code>for..in</code> loops and checking hasOwnProperty will slow you down as well. Manual clone when speed is an absolute must.</p>\n\n<pre><code>var clonedObject = {\n  knownProp: obj.knownProp,\n  ..\n}\n</code></pre>\n\n<p>Beware using the <code>JSON.parse(JSON.stringify(obj))</code> method on <code>Date</code> objects - <code>JSON.stringify(new Date())</code> returns a string representation of the date in ISO format, which <code>JSON.parse()</code> <strong>doesn't</strong> convert back to a <code>Date</code> object. <a href=\"https://stackoverflow.com/questions/11491938/issues-with-date-when-using-json-stringify-and-json-parse/11491993#11491993\">See this answer for more details</a>.</p>\n\n<p>Additionally, please note that, in Chrome 65 at least, native cloning is not the way to go. According to JSPerf, performing native cloning by creating a new function is nearly <strong>800x</strong> slower than using JSON.stringify which is incredibly fast all the way across the board.</p>\n\n<p><strong><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" rel=\"noreferrer\">Update for ES6</a></strong></p>\n\n<p>If you are using Javascript ES6 try this native method for cloning or shallow copy.</p>\n\n<pre><code>Object.assign({}, obj);\n</code></pre>\n"},{"score":3,"body":"<p>I think that this is the best solution  if you want to generalize your object cloning algorithm.<br>\nIt can be used with or without jQuery, although I recommend leaving jQuery's extend method out if you want you the cloned object to have the same \"class\" as the original one.</p>\n\n<pre><code>function clone(obj){\n    if(typeof(obj) == 'function')//it's a simple function\n        return obj;\n    //of it's not an object (but could be an array...even if in javascript arrays are objects)\n    if(typeof(obj) !=  'object' || obj.constructor.toString().indexOf('Array')!=-1)\n        if(JSON != undefined)//if we have the JSON obj\n            try{\n                return JSON.parse(JSON.stringify(obj));\n            }catch(err){\n                return JSON.parse('\"'+JSON.stringify(obj)+'\"');\n            }\n        else\n            try{\n                return eval(uneval(obj));\n            }catch(err){\n                return eval('\"'+uneval(obj)+'\"');\n            }\n    // I used to rely on jQuery for this, but the \"extend\" function returns\n    //an object similar to the one cloned,\n    //but that was not an instance (instanceof) of the cloned class\n    /*\n    if(jQuery != undefined)//if we use the jQuery plugin\n        return jQuery.extend(true,{},obj);\n    else//we recursivley clone the object\n    */\n    return (function _clone(obj){\n        if(obj == null || typeof(obj) != 'object')\n            return obj;\n        function temp () {};\n        temp.prototype = obj;\n        var F = new temp;\n        for(var key in obj)\n            F[key] = clone(obj[key]);\n        return F;\n    })(obj);            \n}\n</code></pre>\n"},{"score":14,"body":"<p>This isn't generally the most efficient solution, but it does what I need. Simple test cases below...</p>\n\n<pre><code>function clone(obj, clones) {\n    // Makes a deep copy of 'obj'. Handles cyclic structures by\n    // tracking cloned obj's in the 'clones' parameter. Functions \n    // are included, but not cloned. Functions members are cloned.\n    var new_obj,\n        already_cloned,\n        t = typeof obj,\n        i = 0,\n        l,\n        pair; \n\n    clones = clones || [];\n\n    if (obj === null) {\n        return obj;\n    }\n\n    if (t === \"object\" || t === \"function\") {\n\n        // check to see if we've already cloned obj\n        for (i = 0, l = clones.length; i &lt; l; i++) {\n            pair = clones[i];\n            if (pair[0] === obj) {\n                already_cloned = pair[1];\n                break;\n            }\n        }\n\n        if (already_cloned) {\n            return already_cloned; \n        } else {\n            if (t === \"object\") { // create new object\n                new_obj = new obj.constructor();\n            } else { // Just use functions as is\n                new_obj = obj;\n            }\n\n            clones.push([obj, new_obj]); // keep track of objects we've cloned\n\n            for (key in obj) { // clone object members\n                if (obj.hasOwnProperty(key)) {\n                    new_obj[key] = clone(obj[key], clones);\n                }\n            }\n        }\n    }\n    return new_obj || obj;\n}\n</code></pre>\n\n<p>Cyclic array test...</p>\n\n<pre><code>a = []\na.push(\"b\", \"c\", a)\naa = clone(a)\naa === a //=&gt; false\naa[2] === a //=&gt; false\naa[2] === a[2] //=&gt; false\naa[2] === aa //=&gt; true\n</code></pre>\n\n<p>Function test...</p>\n\n<pre><code>f = new Function\nf.a = a\nff = clone(f)\nff === f //=&gt; true\nff.a === a //=&gt; false\n</code></pre>\n"},{"score":4,"body":"<p>This is the fastest method I have created that doesn't use the prototype, so it will maintain hasOwnProperty in the new object.</p>\n\n<p>The solution is to iterate the top level properties of the original object, make two copies, delete each property from the original and then reset the original object and return the new copy. It only has to iterate as many times as top level properties. This saves all the <code>if</code> conditions to check if each property is a function, object, string, etc., and doesn't have to iterate each descendant property.</p>\n\n<p>The only drawback is that the original object must be supplied with its original created namespace, in order to reset it.</p>\n\n<pre><code>copyDeleteAndReset:function(namespace,strObjName){\n    var obj = namespace[strObjName],\n    objNew = {},objOrig = {};\n    for(i in obj){\n        if(obj.hasOwnProperty(i)){\n            objNew[i] = objOrig[i] = obj[i];\n            delete obj[i];\n        }\n    }\n    namespace[strObjName] = objOrig;\n    return objNew;\n}\n\nvar namespace = {};\nnamespace.objOrig = {\n    '0':{\n        innerObj:{a:0,b:1,c:2}\n    }\n}\n\nvar objNew = copyDeleteAndReset(namespace,'objOrig');\nobjNew['0'] = 'NEW VALUE';\n\nconsole.log(objNew['0']) === 'NEW VALUE';\nconsole.log(namespace.objOrig['0']) === innerObj:{a:0,b:1,c:2};\n</code></pre>\n"},{"score":54,"body":"<p>I know this is an old post, but I thought this may be of some help to the next person who stumbles along.</p>\n\n<p>As long as you don't assign an object to anything it maintains no reference in memory.  So to make an object that you want to share among other objects, you'll have to create a factory like so:</p>\n\n<pre><code>var a = function(){\n    return {\n        father:'zacharias'\n    };\n},\nb = a(),\nc = a();\nc.father = 'johndoe';\nalert(b.father);\n</code></pre>\n"},{"score":48,"body":"<p>If you're using it, the <a href=\"http://documentcloud.github.com/underscore/\" rel=\"noreferrer\">Underscore.js</a> library has a <a href=\"http://documentcloud.github.com/underscore/#clone\" rel=\"noreferrer\">clone</a> method.</p>\n\n<pre><code>var newObject = _.clone(oldObject);\n</code></pre>\n"},{"score":427,"body":"<h1>Structured Cloning</h1>\n\n<p>The HTML standard includes <a href=\"https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data\" rel=\"noreferrer\"><strong>an internal structured cloning/serialization algorithm</strong></a> that can create deep clones of objects. It is still limited to certain built-in types, but in addition to the few types supported by JSON it also supports Dates, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays, and probably more in the future. It also preserves references within the cloned data, allowing it to support cyclical and recursive structures that would cause errors for JSON.</p>\n\n<h2>Support in Node.js: Experimental 🙂</h2>\n\n<p>The <code>v8</code> module in Node.js currently (as of Node 11) <a href=\"https://nodejs.org/api/all.html#v8_serialization_api\" rel=\"noreferrer\">exposes the structured serialization API directly</a>, but this functionality is still marked as \"experimental\", and subject to change or removal in future versions. If you're using a compatible version, cloning an object is as simple as:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>const v8 = require('v8');\n\nconst structuredClone = obj =&gt; {\n  return v8.deserialize(v8.serialize(obj));\n};\n</code></pre>\n\n<h2>Direct Support in Browsers: Maybe Eventually? 😐</h2>\n\n<p>Browsers do not currently provide a direct interface for the structured cloning algorithm, but a global <code>structuredClone()</code> function has been discussed in <a href=\"https://github.com/whatwg/html/issues/793\" rel=\"noreferrer\">whatwg/html#793 on GitHub</a>. As currently proposed, using it for most purposes would be as simple as:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>const clone = structuredClone(original);\n</code></pre>\n\n<p>Unless this is shipped, browsers' structured clone implementations are only exposed indirectly.</p>\n\n<h2>Asynchronous Workaround: Usable. 😕</h2>\n\n<p>The lower-overhead way to create a structured clone with existing APIs is to post the data through one port of a <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel\" rel=\"noreferrer\">MessageChannels</a>. The other port will emit a <code>message</code> event with a structured clone of the attached <code>.data</code>. Unfortunately, listening for these events is necessarily asynchronous, and the synchronous alternatives are less practical.</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>class StructuredCloner {\n  constructor() {\n    this.pendingClones_ = new Map();\n    this.nextKey_ = 0;\n\n    const channel = new MessageChannel();\n    this.inPort_ = channel.port1;\n    this.outPort_ = channel.port2;\n\n    this.outPort_.onmessage = ({data: {key, value}}) =&gt; {\n      const resolve = this.pendingClones_.get(key);\n      resolve(value);\n      this.pendingClones_.delete(key);\n    };\n    this.outPort_.start();\n  }\n\n  cloneAsync(value) {\n    return new Promise(resolve =&gt; {\n      const key = this.nextKey_++;\n      this.pendingClones_.set(key, resolve);\n      this.inPort_.postMessage({key, value});\n    });\n  }\n}\n\nconst structuredCloneAsync = window.structuredCloneAsync =\n    StructuredCloner.prototype.cloneAsync.bind(new StructuredCloner);\n</code></pre>\n\n<h3>Example Use:</h3>\n\n<pre class=\"lang-js prettyprint-override\"><code>const main = async () =&gt; {\n  const original = { date: new Date(), number: Math.random() };\n  original.self = original;\n\n  const clone = await structuredCloneAsync(original);\n\n  // They're different objects:\n  console.assert(original !== clone);\n  console.assert(original.date !== clone.date);\n\n  // They're cyclical:\n  console.assert(original.self === original);\n  console.assert(clone.self === clone);\n\n  // They contain equivalent values:\n  console.assert(original.number === clone.number);\n  console.assert(Number(original.date) === Number(clone.date));\n\n  console.log(\"Assertions complete.\");\n};\n\nmain();\n</code></pre>\n\n<h2>Synchronous Workarounds: Awful! 🤢</h2>\n\n<p>There are no good options for creating structured clones synchronously. Here are a couple of impractical hacks instead.</p>\n\n<p><code>history.pushState()</code> and <code>history.replaceState()</code> both create a structured clone of their first argument, and assign that value to <code>history.state</code>. You can use this to create a structured clone of any object like this:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>const structuredClone = obj =&gt; {\n  const oldState = history.state;\n  history.replaceState(obj, null);\n  const clonedObj = history.state;\n  history.replaceState(oldState, null);\n  return clonedObj;\n};\n</code></pre>\n\n<h3>Example Use:</h3>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>'use strict';\r\n\r\nconst main = () =&gt; {\r\n  const original = { date: new Date(), number: Math.random() };\r\n  original.self = original;\r\n\r\n  const clone = structuredClone(original);\r\n  \r\n  // They're different objects:\r\n  console.assert(original !== clone);\r\n  console.assert(original.date !== clone.date);\r\n\r\n  // They're cyclical:\r\n  console.assert(original.self === original);\r\n  console.assert(clone.self === clone);\r\n\r\n  // They contain equivalent values:\r\n  console.assert(original.number === clone.number);\r\n  console.assert(Number(original.date) === Number(clone.date));\r\n  \r\n  console.log(\"Assertions complete.\");\r\n};\r\n\r\nconst structuredClone = obj =&gt; {\r\n  const oldState = history.state;\r\n  history.replaceState(obj, null);\r\n  const clonedObj = history.state;\r\n  history.replaceState(oldState, null);\r\n  return clonedObj;\r\n};\r\n\r\nmain();</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Though synchronous, this can be extremely slow. It incurs all of the overhead associated with manipulating the browser history. Calling this method repeatedly can cause Chrome to become temporarily unresponsive.</p>\n\n<p>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Notification/Notification\" rel=\"noreferrer\"><code>Notification</code> constructor</a> creates a structured clone of its associated data. It also attempts to display a browser notification to the user, but this will silently fail unless you have requested notification permission. In case you have the permission for other purposes, we'll immediately close the notification we've created.</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>const structuredClone = obj =&gt; {\n  const n = new Notification('', {data: obj, silent: true});\n  n.onshow = n.close.bind(n);\n  return n.data;\n};\n</code></pre>\n\n<h3>Example Use:</h3>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>'use strict';\r\n\r\nconst main = () =&gt; {\r\n  const original = { date: new Date(), number: Math.random() };\r\n  original.self = original;\r\n\r\n  const clone = structuredClone(original);\r\n  \r\n  // They're different objects:\r\n  console.assert(original !== clone);\r\n  console.assert(original.date !== clone.date);\r\n\r\n  // They're cyclical:\r\n  console.assert(original.self === original);\r\n  console.assert(clone.self === clone);\r\n\r\n  // They contain equivalent values:\r\n  console.assert(original.number === clone.number);\r\n  console.assert(Number(original.date) === Number(clone.date));\r\n  \r\n  console.log(\"Assertions complete.\");\r\n};\r\n\r\nconst structuredClone = obj =&gt; {\r\n  const n = new Notification('', {data: obj, silent: true});\r\n  n.close();\r\n  return n.data;\r\n};\r\n\r\nmain();</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":21,"body":"<p>Shallow copy one-liner (<a href=\"https://en.wikipedia.org/wiki/ECMAScript#5th_Edition\" rel=\"noreferrer\">ECMAScript 5th edition</a>):</p>\n\n<pre><code>var origin = { foo : {} };\nvar copy = Object.keys(origin).reduce(function(c,k){c[k]=origin[k];return c;},{});\n\nconsole.log(origin, copy);\nconsole.log(origin == copy); // false\nconsole.log(origin.foo == copy.foo); // true\n</code></pre>\n\n<p>And shallow copy one-liner (<a href=\"https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015\" rel=\"noreferrer\">ECMAScript 6th edition</a>, 2015):</p>\n\n<pre><code>var origin = { foo : {} };\nvar copy = Object.assign({}, origin);\n\nconsole.log(origin, copy);\nconsole.log(origin == copy); // false\nconsole.log(origin.foo == copy.foo); // true\n</code></pre>\n"},{"score":11,"body":"<p>Here is a comprehensive clone() method that can clone any JavaScript object. It handles almost all the cases:</p>\n\n<pre><code>function clone(src, deep) {\n\n    var toString = Object.prototype.toString;\n    if (!src &amp;&amp; typeof src != \"object\") {\n        // Any non-object (Boolean, String, Number), null, undefined, NaN\n        return src;\n    }\n\n    // Honor native/custom clone methods\n    if (src.clone &amp;&amp; toString.call(src.clone) == \"[object Function]\") {\n        return src.clone(deep);\n    }\n\n    // DOM elements\n    if (src.nodeType &amp;&amp; toString.call(src.cloneNode) == \"[object Function]\") {\n        return src.cloneNode(deep);\n    }\n\n    // Date\n    if (toString.call(src) == \"[object Date]\") {\n        return new Date(src.getTime());\n    }\n\n    // RegExp\n    if (toString.call(src) == \"[object RegExp]\") {\n        return new RegExp(src);\n    }\n\n    // Function\n    if (toString.call(src) == \"[object Function]\") {\n\n        //Wrap in another method to make sure == is not true;\n        //Note: Huge performance issue due to closures, comment this :)\n        return (function(){\n            src.apply(this, arguments);\n        });\n    }\n\n    var ret, index;\n    //Array\n    if (toString.call(src) == \"[object Array]\") {\n        //[].slice(0) would soft clone\n        ret = src.slice();\n        if (deep) {\n            index = ret.length;\n            while (index--) {\n                ret[index] = clone(ret[index], true);\n            }\n        }\n    }\n    //Object\n    else {\n        ret = src.constructor ? new src.constructor() : {};\n        for (var prop in src) {\n            ret[prop] = deep\n                ? clone(src[prop], true)\n                : src[prop];\n        }\n    }\n    return ret;\n};\n</code></pre>\n"},{"score":60,"body":"<p>There’s a <a href=\"https://github.com/pvorb/node-clone\" rel=\"noreferrer\">library (called “clone”)</a>, that does this quite well. It provides the most complete recursive cloning/copying of arbitrary objects that I know of. It also supports circular references, which is not covered by the other answers, yet.</p>\n\n<p>You can <a href=\"https://npmjs.org/package/clone\" rel=\"noreferrer\">find it on npm</a>, too. It can be used for the browser as well as Node.js.</p>\n\n<p>Here is an example on how to use it:</p>\n\n<p>Install it with</p>\n\n<pre><code>npm install clone\n</code></pre>\n\n<p>or package it with <a href=\"https://github.com/ender-js/Ender\" rel=\"noreferrer\">Ender</a>.</p>\n\n<pre><code>ender build clone [...]\n</code></pre>\n\n<p>You can also download the source code manually.</p>\n\n<p>Then you can use it in your source code.</p>\n\n<pre><code>var clone = require('clone');\n\nvar a = { foo: { bar: 'baz' } };  // inital value of a\nvar b = clone(a);                 // clone a -&gt; b\na.foo.bar = 'foo';                // change a\n\nconsole.log(a);                   // { foo: { bar: 'foo' } }\nconsole.log(b);                   // { foo: { bar: 'baz' } }\n</code></pre>\n\n<p>(Disclaimer: I’m the author of the library.)</p>\n"},{"score":42,"body":"<p>Here's a version of ConroyP's answer above that works even if the constructor has required parameters:</p>\n\n<pre><code>//If Object.create isn't already defined, we just do the simple shim,\n//without the second argument, since that's all we need here\nvar object_create = Object.create;\nif (typeof object_create !== 'function') {\n    object_create = function(o) {\n        function F() {}\n        F.prototype = o;\n        return new F();\n    };\n}\n\nfunction deepCopy(obj) {\n    if(obj == null || typeof(obj) !== 'object'){\n        return obj;\n    }\n    //make sure the returned object has the same prototype as the original\n    var ret = object_create(obj.constructor.prototype);\n    for(var key in obj){\n        ret[key] = deepCopy(obj[key]);\n    }\n    return ret;\n}\n</code></pre>\n\n<p>This function is also available in my <a href=\"https://github.com/mbrowne/simpleoo.js\" rel=\"noreferrer\">simpleoo</a> library.</p>\n\n<p><strong>Edit:</strong></p>\n\n<p>Here's a more robust version (thanks to Justin McCandless this now supports cyclic references as well):</p>\n\n<pre><code>/**\n * Deep copy an object (make copies of all its object properties, sub-properties, etc.)\n * An improved version of http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\n * that doesn't break if the constructor has required parameters\n * \n * It also borrows some code from http://stackoverflow.com/a/11621004/560114\n */ \nfunction deepCopy(src, /* INTERNAL */ _visited, _copiesVisited) {\n    if(src === null || typeof(src) !== 'object'){\n        return src;\n    }\n\n    //Honor native/custom clone methods\n    if(typeof src.clone == 'function'){\n        return src.clone(true);\n    }\n\n    //Special cases:\n    //Date\n    if(src instanceof Date){\n        return new Date(src.getTime());\n    }\n    //RegExp\n    if(src instanceof RegExp){\n        return new RegExp(src);\n    }\n    //DOM Element\n    if(src.nodeType &amp;&amp; typeof src.cloneNode == 'function'){\n        return src.cloneNode(true);\n    }\n\n    // Initialize the visited objects arrays if needed.\n    // This is used to detect cyclic references.\n    if (_visited === undefined){\n        _visited = [];\n        _copiesVisited = [];\n    }\n\n    // Check if this object has already been visited\n    var i, len = _visited.length;\n    for (i = 0; i &lt; len; i++) {\n        // If so, get the copy we already made\n        if (src === _visited[i]) {\n            return _copiesVisited[i];\n        }\n    }\n\n    //Array\n    if (Object.prototype.toString.call(src) == '[object Array]') {\n        //[].slice() by itself would soft clone\n        var ret = src.slice();\n\n        //add it to the visited array\n        _visited.push(src);\n        _copiesVisited.push(ret);\n\n        var i = ret.length;\n        while (i--) {\n            ret[i] = deepCopy(ret[i], _visited, _copiesVisited);\n        }\n        return ret;\n    }\n\n    //If we've reached here, we have a regular object\n\n    //make sure the returned object has the same prototype as the original\n    var proto = (Object.getPrototypeOf ? Object.getPrototypeOf(src): src.__proto__);\n    if (!proto) {\n        proto = src.constructor.prototype; //this line would probably only be reached by very old browsers \n    }\n    var dest = object_create(proto);\n\n    //add this object to the visited array\n    _visited.push(src);\n    _copiesVisited.push(dest);\n\n    for (var key in src) {\n        //Note: this does NOT preserve ES5 property attributes like 'writable', 'enumerable', etc.\n        //For an example of how this could be modified to do so, see the singleMixin() function\n        dest[key] = deepCopy(src[key], _visited, _copiesVisited);\n    }\n    return dest;\n}\n\n//If Object.create isn't already defined, we just do the simple shim,\n//without the second argument, since that's all we need here\nvar object_create = Object.create;\nif (typeof object_create !== 'function') {\n    object_create = function(o) {\n        function F() {}\n        F.prototype = o;\n        return new F();\n    };\n}\n</code></pre>\n"},{"score":15,"body":"<p>I have two good answers depending on whether your objective is to clone a \"plain old JavaScript object\" or not.</p>\n\n<p>Let's also assume that your intention is to create a complete clone with no prototype references back to the source object. If you're not interested in a complete clone, then you can use many of the Object.clone() routines provided in some of the other answers (Crockford's pattern).</p>\n\n<p>For plain old JavaScript objects, a tried and true good way to clone an object in modern runtimes is quite simply:</p>\n\n<pre><code>var clone = JSON.parse(JSON.stringify(obj));\n</code></pre>\n\n<p>Note that the source object must be a pure JSON object. This is to say, all of its nested properties must be scalars (like boolean, string, array, object, etc). Any functions or special objects like RegExp or Date will not be cloned.</p>\n\n<p>Is it efficient? Heck yes. We've tried all kinds of cloning methods and this works best. I'm sure some ninja could conjure up a faster method. But I suspect we're talking about marginal gains.</p>\n\n<p>This approach is just simple and easy to implement. Wrap it into a convenience function and if you really need to squeeze out some gain, go for at a later time.</p>\n\n<p>Now, for non-plain JavaScript objects, there isn't a really simple answer.  In fact, there can't be because of the dynamic nature of JavaScript functions and inner object state. Deep cloning a JSON structure with functions inside requires you recreate those functions and their inner context. And JavaScript simply doesn't have a standardized way of doing that.</p>\n\n<p>The correct way to do this, once again, is via a convenience method that you declare and reuse within your code. The convenience method can be endowed with some understanding of your own objects so you can make sure to properly recreate the graph within the new object.</p>\n\n<p>We're written our own, but the best general approach I've seen is covered here:</p>\n\n<p><a href=\"http://davidwalsh.name/javascript-clone\" rel=\"noreferrer\">http://davidwalsh.name/javascript-clone</a></p>\n\n<p>This is the right idea. The author (David Walsh) has commented out the cloning of generalized functions. This is something you might choose to do, depending on your use case.</p>\n\n<p>The main idea is that you need to special handle the instantiation of your functions (or prototypal classes, so to speak) on a per-type basis. Here, he's provided a few examples for RegExp and Date.</p>\n\n<p>Not only is this code brief, but it's also very readable. It's pretty easy to extend.</p>\n\n<p>Is this efficient? Heck yes. Given that the goal is to produce a true deep-copy clone, then you're going to have to walk the members of the source object graph. With this approach, you can tweak exactly which child members to treat and how to manually handle custom types.</p>\n\n<p>So there you go. Two approaches. Both are efficient in my view.</p>\n"},{"score":23,"body":"<p>Lodash has a nice <a href=\"http://lodash.com/docs#cloneDeep\" rel=\"noreferrer\">_.cloneDeep(value)</a> method:</p>\n\n<pre><code>var objects = [{ 'a': 1 }, { 'b': 2 }];\n\nvar deep = _.cloneDeep(objects);\nconsole.log(deep[0] === objects[0]);\n// =&gt; false\n</code></pre>\n"},{"score":4,"body":"<p>There are a lot of answers, but none of them gave the desired effect I needed.  I wanted to utilize the power of jQuery's deep copy... However, when it runs into an array, it simply copies the reference to the array and deep copies the items in it.  To get around this, I made a nice little recursive function that will create a new array automatically.  </p>\n\n<p>(It even checks for kendo.data.ObservableArray if you want it to!  Though, make sure you make sure you call kendo.observable(newItem) if you want the Arrays to be observable again.) </p>\n\n<p>So, to fully copy an existing item, you just do this:</p>\n\n<pre><code>var newItem = jQuery.extend(true, {}, oldItem);\ncreateNewArrays(newItem);\n\n\nfunction createNewArrays(obj) {\n    for (var prop in obj) {\n        if ((kendo != null &amp;&amp; obj[prop] instanceof kendo.data.ObservableArray) || obj[prop] instanceof Array) {\n            var copy = [];\n            $.each(obj[prop], function (i, item) {\n                var newChild = $.extend(true, {}, item);\n                createNewArrays(newChild);\n                copy.push(newChild);\n            });\n            obj[prop] = copy;\n        }\n    }\n}\n</code></pre>\n"},{"score":5,"body":"<p>I usually use <code>var newObj = JSON.parse( JSON.stringify(oldObje) );</code> but, here's a more proper way:</p>\n\n<pre><code>var o = {};\n\nvar oo = Object.create(o);\n\n(o === oo); // =&gt; false\n</code></pre>\n\n<p>Watch legacy browsers!</p>\n"},{"score":3,"body":"<p>This is my version of object cloner. This is a stand-alone version of the jQuery method, with only few tweaks and adjustments. Check out the <a href=\"http://jsfiddle.net/eyYJB/\" rel=\"nofollow\">fiddle</a>. I've used a lot of jQuery until the day I realized that I'd use only this function most of the time x_x.</p>\n\n<p>The usage is the same as described into the jQuery API:</p>\n\n<ul>\n<li>Non-deep clone: <code>extend(object_dest, object_source);</code></li>\n<li>Deep clone: <code>extend(true, object_dest, object_source);</code></li>\n</ul>\n\n<p>One extra function is used to define if object is proper to be cloned.</p>\n\n<pre><code>/**\n * This is a quasi clone of jQuery's extend() function.\n * by Romain WEEGER for wJs library - www.wexample.com\n * @returns {*|{}}\n */\nfunction extend() {\n    // Make a copy of arguments to avoid JavaScript inspector hints.\n    var to_add, name, copy_is_array, clone,\n\n    // The target object who receive parameters\n    // form other objects.\n    target = arguments[0] || {},\n\n    // Index of first argument to mix to target.\n    i = 1,\n\n    // Mix target with all function arguments.\n    length = arguments.length,\n\n    // Define if we merge object recursively.\n    deep = false;\n\n    // Handle a deep copy situation.\n    if (typeof target === 'boolean') {\n        deep = target;\n\n        // Skip the boolean and the target.\n        target = arguments[ i ] || {};\n\n        // Use next object as first added.\n        i++;\n    }\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if (typeof target !== 'object' &amp;&amp; typeof target !== 'function') {\n        target = {};\n    }\n\n    // Loop trough arguments.\n    for (false; i &lt; length; i += 1) {\n\n        // Only deal with non-null/undefined values\n        if ((to_add = arguments[ i ]) !== null) {\n\n            // Extend the base object.\n            for (name in to_add) {\n\n                // We do not wrap for loop into hasOwnProperty,\n                // to access to all values of object.\n                // Prevent never-ending loop.\n                if (target === to_add[name]) {\n                    continue;\n                }\n\n                // Recurse if we're merging plain objects or arrays.\n                if (deep &amp;&amp; to_add[name] &amp;&amp; (is_plain_object(to_add[name]) || (copy_is_array = Array.isArray(to_add[name])))) {\n                    if (copy_is_array) {\n                        copy_is_array = false;\n                        clone = target[name] &amp;&amp; Array.isArray(target[name]) ? target[name] : [];\n                    }\n                    else {\n                        clone = target[name] &amp;&amp; is_plain_object(target[name]) ? target[name] : {};\n                    }\n\n                    // Never move original objects, clone them.\n                    target[name] = extend(deep, clone, to_add[name]);\n                }\n\n                // Don't bring in undefined values.\n                else if (to_add[name] !== undefined) {\n                    target[name] = to_add[name];\n                }\n            }\n        }\n    }\n    return target;\n}\n\n/**\n * Check to see if an object is a plain object\n * (created using \"{}\" or \"new Object\").\n * Forked from jQuery.\n * @param obj\n * @returns {boolean}\n */\nfunction is_plain_object(obj) {\n    // Not plain objects:\n    // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n    // - DOM nodes\n    // - window\n    if (obj === null || typeof obj !== \"object\" || obj.nodeType || (obj !== null &amp;&amp; obj === obj.window)) {\n        return false;\n    }\n    // Support: Firefox &lt;20\n    // The try/catch suppresses exceptions thrown when attempting to access\n    // the \"constructor\" property of certain host objects, i.e. |window.location|\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622\n    try {\n        if (obj.constructor &amp;&amp; !this.hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n            return false;\n        }\n    }\n    catch (e) {\n        return false;\n    }\n\n    // If the function hasn't returned already, we're confident that\n    // |obj| is a plain object, created by {} or constructed with new Object\n    return true;\n}\n</code></pre>\n"},{"score":4,"body":"<p>For future reference, the current draft of <a href=\"https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015\" rel=\"nofollow\">ECMAScript 6</a> introduces <a href=\"http://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign\" rel=\"nofollow\">Object.assign</a> as a way of cloning objects. Example code would be:</p>\n\n<pre><code>var obj1 = { a: true, b: 1 };\nvar obj2 = Object.assign(obj1);\nconsole.log(obj2); // { a: true, b: 1 }\n</code></pre>\n\n<p>At the time of writing <a href=\"http://kangax.github.io/compat-table/es6/#Object.assign\" rel=\"nofollow\">support is limited to Firefox 34 in browsers</a> so it’s not usable in production code just yet (unless you’re writing a Firefox extension of course).</p>\n"},{"score":81,"body":"<p><strong>Deep copy by performance:</strong>\nRanked from best to worst</p>\n\n<ul>\n<li>Reassignment \"=\" (string arrays, number arrays - only)</li>\n<li>Slice (string arrays, number arrays - only)</li>\n<li>Concatenation (string arrays, number arrays - only)</li>\n<li>Custom function: for-loop or recursive copy</li>\n<li>jQuery's $.extend</li>\n<li>JSON.parse (string arrays, number arrays, object arrays - only)</li>\n<li><a href=\"https://en.wikipedia.org/wiki/Underscore.js\" rel=\"noreferrer\">Underscore.js</a>'s _.clone (string arrays, number arrays - only)</li>\n<li>Lo-Dash's _.cloneDeep</li>\n</ul>\n\n<p><strong>Deep copy an array of strings or numbers (one level - no reference pointers):</strong></p>\n\n<p>When an array contains numbers and strings - functions like .slice(), .concat(), .splice(), the assignment operator \"=\", and Underscore.js's clone function; will make a deep copy of the array's elements.</p>\n\n<p>Where reassignment has the fastest performance:</p>\n\n<pre><code>var arr1 = ['a', 'b', 'c'];\nvar arr2 = arr1;\narr1 = ['a', 'b', 'c'];\n</code></pre>\n\n<p>And .slice() has better performance than .concat(),\n<a href=\"http://jsperf.com/duplicate-array-slice-vs-concat/3\" rel=\"noreferrer\">http://jsperf.com/duplicate-array-slice-vs-concat/3</a></p>\n\n<pre><code>var arr1 = ['a', 'b', 'c'];  // Becomes arr1 = ['a', 'b', 'c']\nvar arr2a = arr1.slice(0);   // Becomes arr2a = ['a', 'b', 'c'] - deep copy\nvar arr2b = arr1.concat();   // Becomes arr2b = ['a', 'b', 'c'] - deep copy\n</code></pre>\n\n<p><strong>Deep copy an array of objects (two or more levels - reference pointers):</strong></p>\n\n<pre><code>var arr1 = [{object:'a'}, {object:'b'}];\n</code></pre>\n\n<p>Write a custom function (has faster performance than $.extend() or JSON.parse):</p>\n\n<pre><code>function copy(o) {\n   var out, v, key;\n   out = Array.isArray(o) ? [] : {};\n   for (key in o) {\n       v = o[key];\n       out[key] = (typeof v === \"object\" &amp;&amp; v !== null) ? copy(v) : v;\n   }\n   return out;\n}\n\ncopy(arr1);\n</code></pre>\n\n<p>Use third-party utility functions:</p>\n\n<pre><code>$.extend(true, [], arr1); // Jquery Extend\nJSON.parse(arr1);\n_.cloneDeep(arr1); // Lo-dash\n</code></pre>\n\n<p>Where jQuery's $.extend has better performance:</p>\n\n<ul>\n<li><a href=\"http://jsperf.com/js-deep-copy/2\" rel=\"noreferrer\">http://jsperf.com/js-deep-copy/2</a></li>\n<li><a href=\"http://jsperf.com/jquery-extend-vs-json-parse/2\" rel=\"noreferrer\">http://jsperf.com/jquery-extend-vs-json-parse/2</a></li>\n</ul>\n"},{"score":3,"body":"<p>Use <code>Object.create()</code> to get the <code>prototype</code> and support for <code>instanceof</code>, and use a <code>for()</code> loop to get enumerable keys:</p>\n\n<pre><code>function cloneObject(source) {\n    var key,value;\n    var clone = Object.create(source);\n\n    for (key in source) {\n        if (source.hasOwnProperty(key) === true) {\n            value = source[key];\n\n            if (value!==null &amp;&amp; typeof value===\"object\") {\n                clone[key] = cloneObject(value);\n            } else {\n                clone[key] = value;\n            }\n        }\n    }\n\n    return clone;\n}\n</code></pre>\n"},{"score":2,"body":"<p>Requires new-ish browsers, but...</p>\n\n<p>Let's extend the native Object and get a <strong>real</strong> <code>.extend()</code>;</p>\n\n<pre><code>Object.defineProperty(Object.prototype, 'extend', {\n    enumerable: false,\n    value: function(){\n        var that = this;\n\n        Array.prototype.slice.call(arguments).map(function(source){\n            var props = Object.getOwnPropertyNames(source),\n                i = 0, l = props.length,\n                prop;\n\n            for(; i &lt; l; ++i){\n                prop = props[i];\n\n                if(that.hasOwnProperty(prop) &amp;&amp; typeof(that[prop]) === 'object'){\n                    that[prop] = that[prop].extend(source[prop]);\n                }else{\n                    Object.defineProperty(that, prop, Object.getOwnPropertyDescriptor(source, prop));\n                }\n            }\n        });\n\n        return this;\n    }\n});\n</code></pre>\n\n<p>Just pop that in prior to any code that uses .extend() on an object.</p>\n\n<p>Example:</p>\n\n<pre><code>var obj1 = {\n    node1: '1',\n    node2: '2',\n    node3: 3\n};\n\nvar obj2 = {\n    node1: '4',\n    node2: 5,\n    node3: '6'\n};\n\nvar obj3 = ({}).extend(obj1, obj2);\n\nconsole.log(obj3);\n// Object {node1: \"4\", node2: 5, node3: \"6\"}\n</code></pre>\n"},{"score":30,"body":"<p>The following creates two instances of the same object. I found it and am using it currently. It's simple and easy to use.</p>\n\n<pre><code>var objToCreate = JSON.parse(JSON.stringify(cloneThis));\n</code></pre>\n"},{"score":11,"body":"<p>Only when you can use <a href=\"https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015\" rel=\"noreferrer\">ECMAScript 6</a> or <a href=\"https://en.wikipedia.org/wiki/Source-to-source_compiler\" rel=\"noreferrer\">transpilers</a>.</p>\n\n<p>Features:</p>\n\n<ul>\n<li>Won't trigger getter/setter while copying.</li>\n<li>Preserves getter/setter.</li>\n<li>Preserves prototype informations.</li>\n<li>Works with both <strong>object-literal</strong> and <strong>functional</strong> <a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\" rel=\"noreferrer\">OO</a> writing styles.</li>\n</ul>\n\n<p>Code:</p>\n\n<pre><code>function clone(target, source){\n\n    for(let key in source){\n\n        // Use getOwnPropertyDescriptor instead of source[key] to prevent from trigering setter/getter.\n        let descriptor = Object.getOwnPropertyDescriptor(source, key);\n        if(descriptor.value instanceof String){\n            target[key] = new String(descriptor.value);\n        }\n        else if(descriptor.value instanceof Array){\n            target[key] = clone([], descriptor.value);\n        }\n        else if(descriptor.value instanceof Object){\n            let prototype = Reflect.getPrototypeOf(descriptor.value);\n            let cloneObject = clone({}, descriptor.value);\n            Reflect.setPrototypeOf(cloneObject, prototype);\n            target[key] = cloneObject;\n        }\n        else {\n            Object.defineProperty(target, key, descriptor);\n        }\n    }\n    let prototype = Reflect.getPrototypeOf(source);\n    Reflect.setPrototypeOf(target, prototype);\n    return target;\n}\n</code></pre>\n"},{"score":10,"body":"<p>For the people who want to use the <code>JSON.parse(JSON.stringify(obj))</code> version, but without losing the Date objects, you can use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Using_the_reviver_parameter\" rel=\"nofollow noreferrer\">second argument of <code>parse</code> method</a> to convert the strings back to Date:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function clone(obj) {\n  var regExp = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{3}Z$/;\n  return JSON.parse(JSON.stringify(obj), function(k, v) {\n    if (typeof v === 'string' &amp;&amp; regExp.test(v))\n      return new Date(v)\n    return v;\n  })\n}\n\n// usage:\nvar original = {\n a: [1, null, undefined, 0, {a:null}, new Date()],\n b: {\n   c(){ return 0 }\n }\n}\n\nvar cloned = clone(original)\n\nconsole.log(cloned)</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":155,"body":"<h1>The efficient way to clone(not deep-clone) an object in one line of code</h1>\n<p>An <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" rel=\"noreferrer\"><code>Object.assign</code></a> method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.</p>\n<pre><code>var clone = Object.assign({}, obj);\n</code></pre>\n<blockquote>\n<p>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.</p>\n</blockquote>\n<p><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" rel=\"noreferrer\">Read more...</a></p>\n<p>The <strong>polyfill</strong> to support older browsers:</p>\n<pre><code>if (!Object.assign) {\n  Object.defineProperty(Object, 'assign', {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function(target) {\n      'use strict';\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert first argument to object');\n      }\n\n      var to = Object(target);\n      for (var i = 1; i &lt; arguments.length; i++) {\n        var nextSource = arguments[i];\n        if (nextSource === undefined || nextSource === null) {\n          continue;\n        }\n        nextSource = Object(nextSource);\n\n        var keysArray = Object.keys(nextSource);\n        for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) {\n          var nextKey = keysArray[nextIndex];\n          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n          if (desc !== undefined &amp;&amp; desc.enumerable) {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n      return to;\n    }\n  });\n}\n</code></pre>\n"},{"score":3,"body":"<p>As recursion is just too expensive for JavaScript, and most answers I have found are using recursion, while JSON approach will skip the non-JSON-convertible parts (Function, etc.). So I did a little research and found this trampoline technique to avoid it. Here's the code:</p>\n\n<pre><code>/*\n * Trampoline to avoid recursion in JavaScript, see:\n *     http://www.integralist.co.uk/posts/js-recursion.html\n */\nfunction trampoline() {\n    var func = arguments[0];\n    var args = [];\n    for (var i = 1; i &lt; arguments.length; i++) {\n        args[i - 1] = arguments[i];\n    }\n\n    var currentBatch = func.apply(this, args);\n    var nextBatch = [];\n\n    while (currentBatch &amp;&amp; currentBatch.length &gt; 0) {\n        currentBatch.forEach(function(eachFunc) {\n            var ret = eachFunc();\n            if (ret &amp;&amp; ret.length &gt; 0) {\n                nextBatch = nextBatch.concat(ret);\n            }\n        });\n\n        currentBatch = nextBatch;\n        nextBatch = [];\n    }\n};\n\n/*\n *  Deep clone an object using the trampoline technique.\n *\n *  @param target {Object} Object to clone\n *  @return {Object} Cloned object.\n */\nfunction clone(target) {\n    if (typeof target !== 'object') {\n        return target;\n    }\n    if (target == null || Object.keys(target).length == 0) {\n        return target;\n    }\n\n    function _clone(b, a) {\n        var nextBatch = [];\n        for (var key in b) {\n            if (typeof b[key] === 'object' &amp;&amp; b[key] !== null) {\n                if (b[key] instanceof Array) {\n                    a[key] = [];\n                }\n                else {\n                    a[key] = {};\n                }\n                nextBatch.push(_clone.bind(null, b[key], a[key]));\n            }\n            else {\n                a[key] = b[key];\n            }\n        }\n        return nextBatch;\n    };\n\n    var ret = target instanceof Array ? [] : {};\n    (trampoline.bind(null, _clone))(target, ret);\n    return ret;\n};\n</code></pre>\n\n<p>Also see this gist:\n   <a href=\"https://gist.github.com/SeanOceanHu/7594cafbfab682f790eb\" rel=\"nofollow\">https://gist.github.com/SeanOceanHu/7594cafbfab682f790eb</a></p>\n"},{"score":3,"body":"<p><strong>Cloning an object using today's JavaScript: <a href=\"https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015\" rel=\"nofollow noreferrer\">ECMAScript 2015</a></strong> (formerly known as ECMAScript&nbsp;6)</p>\n\n<pre><code>var original = {a: 1};\n\n// Method 1: New object with original assigned.\nvar copy1 = Object.assign({}, original);\n\n// Method 2: New object with spread operator assignment.\nvar copy2 = {...original};\n</code></pre>\n\n<p>Old browsers may not support ECMAScript 2015. A common solution is to use a JavaScript-to-JavaScript compiler like Babel to output an <a href=\"https://en.wikipedia.org/wiki/ECMAScript#5th_Edition\" rel=\"nofollow noreferrer\">ECMAScript 5</a> version of your JavaScript code.</p>\n\n<p>As <a href=\"https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-clone-an-object-in-javascript?page=2&amp;tab=oldest#comment60081951_36177142\">pointed out by @jim-hall</a>, <strong>this is only a shallow copy</strong>. Properties of properties are copied as a reference: changing one would change the value in the other object/instance.</p>\n"},{"score":17,"body":"<p>Just because I didn't see <a href=\"http://en.wikipedia.org/wiki/AngularJS\" rel=\"noreferrer\">AngularJS</a> mentioned and thought that people might want to know...</p>\n\n<p><a href=\"https://docs.angularjs.org/api/ng/function/angular.copy\" rel=\"noreferrer\"><code>angular.copy</code></a> also provides a method of deep copying objects and arrays.</p>\n"},{"score":5,"body":"<p>Single-line ECMAScript 6 solution (special object types like Date/Regex not handled):</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const clone = (o) =&gt;\r\n  typeof o === 'object' &amp;&amp; o !== null ?      // only clone objects\r\n  (Array.isArray(o) ?                        // if cloning an array\r\n    o.map(e =&gt; clone(e)) :                   // clone each of its elements\r\n    Object.keys(o).reduce(                   // otherwise reduce every key in the object\r\n      (r, k) =&gt; (r[k] = clone(o[k]), r), {}  // and save its cloned value into a new object\r\n    )\r\n  ) :\r\n  o;                                         // return non-objects as is\r\n\r\nvar x = {\r\n  nested: {\r\n    name: 'test'\r\n  }\r\n};\r\n\r\nvar y = clone(x);\r\n\r\nconsole.log(x.nested !== y.nested);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":6,"body":"<p>I use the npm clone library.  Apparently it also works in the browser.</p>\n\n<p><a href=\"https://www.npmjs.com/package/clone\" rel=\"noreferrer\">https://www.npmjs.com/package/clone</a></p>\n\n<pre><code>let a = clone(b)\n</code></pre>\n"},{"score":11,"body":"<h2>AngularJS</h2>\n\n<p>Well if you're using angular you could do this too</p>\n\n<pre><code>var newObject = angular.copy(oldObject);\n</code></pre>\n"},{"score":1,"body":"<p>This is a solution with recursion:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>obj = {\r\n  a: { b: { c: { d: ['1', '2'] } } },\r\n  e: 'Saeid'\r\n}\r\nconst Clone = function (obj) {\r\n  \r\n  const container = Array.isArray(obj) ? [] : {}\r\n  const keys  = Object.keys(obj)\r\n   \r\n  for (let i = 0; i &lt; keys.length; i++) {\r\n    const key = keys[i]\r\n    if(typeof obj[key] == 'object') {\r\n      container[key] = Clone(obj[key])\r\n    }\r\n    else\r\n      container[key] = obj[key].slice()\r\n  }\r\n  \r\n  return container\r\n}\r\n console.log(Clone(obj))</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":2,"body":"<p>For future reference, one can use this code</p>\n\n<p>ES6:</p>\n\n<pre><code>_clone: function(obj){\n    let newObj = {};\n    for(let i in obj){\n        if(typeof(obj[i]) === 'object' &amp;&amp; Object.keys(obj[i]).length){\n            newObj[i] = clone(obj[i]);\n        } else{\n            newObj[i] = obj[i];\n        }\n    }\n    return Object.assign({},newObj);\n}\n</code></pre>\n\n<p>ES5:</p>\n\n<pre><code>function clone(obj){\nlet newObj = {};\nfor(let i in obj){\n    if(typeof(obj[i]) === 'object' &amp;&amp; Object.keys(obj[i]).length){\n        newObj[i] = clone(obj[i]);\n    } else{\n        newObj[i] = obj[i];\n    }\n}\nreturn Object.assign({},newObj);\n</code></pre>\n\n<p>}</p>\n\n<p>E.g </p>\n\n<pre><code>var obj ={a:{b:1,c:3},d:4,e:{f:6}}\nvar xc = clone(obj);\nconsole.log(obj); //{a:{b:1,c:3},d:4,e:{f:6}}\nconsole.log(xc); //{a:{b:1,c:3},d:4,e:{f:6}}\n\nxc.a.b = 90;\nconsole.log(obj); //{a:{b:1,c:3},d:4,e:{f:6}}\nconsole.log(xc); //{a:{b:90,c:3},d:4,e:{f:6}}\n</code></pre>\n"},{"score":2,"body":"<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>class Handler {\r\n  static deepCopy (obj) {\r\n    if (Object.prototype.toString.call(obj) === '[object Array]') {\r\n      const result = [];\r\n      \r\n      for (let i = 0, len = obj.length; i &lt; len; i++) {\r\n        result[i] = Handler.deepCopy(obj[i]);\r\n      }\r\n      return result;\r\n    } else if (Object.prototype.toString.call(obj) === '[object Object]') {\r\n      const result = {};\r\n      for (let prop in obj) {\r\n        result[prop] = Handler.deepCopy(obj[prop]);\r\n      }\r\n      return result;\r\n    }\r\n    return obj;\r\n  }\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":57,"body":"<p><code>Cloning</code> an Object was always a concern in JS, but it was all about before ES6, I list different ways of copying an object in JavaScript below, imagine you have the Object below and would like to have a deep copy of that:</p>\n\n<pre><code>var obj = {a:1, b:2, c:3, d:4};\n</code></pre>\n\n<p>There are few ways to copy this object, without changing the origin:</p>\n\n<p>1) ES5+, Using a simple function to do the copy for you:</p>\n\n<pre><code>function deepCopyObj(obj) {\n    if (null == obj || \"object\" != typeof obj) return obj;\n    if (obj instanceof Date) {\n        var copy = new Date();\n        copy.setTime(obj.getTime());\n        return copy;\n    }\n    if (obj instanceof Array) {\n        var copy = [];\n        for (var i = 0, len = obj.length; i &lt; len; i++) {\n            copy[i] = cloneSO(obj[i]);\n        }\n        return copy;\n    }\n    if (obj instanceof Object) {\n        var copy = {};\n        for (var attr in obj) {\n            if (obj.hasOwnProperty(attr)) copy[attr] = cloneSO(obj[attr]);\n        }\n        return copy;\n    }\n    throw new Error(\"Unable to copy obj this object.\");\n}\n</code></pre>\n\n<p>2) ES5+, using JSON.parse and JSON.stringify.</p>\n\n<pre><code>var  deepCopyObj = JSON.parse(JSON.stringify(obj));\n</code></pre>\n\n<p>3) AngularJs: </p>\n\n<pre><code>var  deepCopyObj = angular.copy(obj);\n</code></pre>\n\n<p>4) jQuery: </p>\n\n<pre><code>var deepCopyObj = jQuery.extend(true, {}, obj);\n</code></pre>\n\n<p>5) UnderscoreJs &amp; Loadash: </p>\n\n<pre><code>var deepCopyObj = _.cloneDeep(obj); //latest version UndescoreJs makes shallow copy\n</code></pre>\n\n<p>Hope these help... </p>\n"},{"score":2,"body":"<p>Without touching the prototypical inheritance you may deep lone objects and arrays as follows;</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function objectClone(o){\r\n  var ot = Array.isArray(o);\r\n  return o !== null &amp;&amp; typeof o === \"object\" ? Object.keys(o)\r\n                                                     .reduce((r,k) =&gt; o[k] !== null &amp;&amp; typeof o[k] === \"object\" ? (r[k] = objectClone(o[k]),r)\r\n                                                                                                                : (r[k] = o[k],r), ot ? [] : {})\r\n                                             : o;\r\n}\r\nvar obj = {a: 1, b: {c: 2, d: {e: 3, f: {g: 4, h: null}}}},\r\n    arr = [1,2,[3,4,[5,6,[7]]]],\r\n    nil = null,\r\n  clobj = objectClone(obj),\r\n  clarr = objectClone(arr),\r\n  clnil = objectClone(nil);\r\nconsole.log(clobj, obj === clobj);\r\nconsole.log(clarr, arr === clarr);\r\nconsole.log(clnil, nil === clnil);\r\nclarr[2][2][2] = \"seven\";\r\nconsole.log(arr, clarr);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":5,"body":"<p>Lodash has a function that handles that for you like so.</p>\n\n<pre><code>var foo = {a: 'a', b: {c:'d', e: {f: 'g'}}};\n\nvar bar = _.cloneDeep(foo);\n// bar = {a: 'a', b: {c:'d', e: {f: 'g'}}} \n</code></pre>\n\n<p>Read the docs <a href=\"https://lodash.com/docs/#cloneDeep\" rel=\"noreferrer\">here</a>.</p>\n"},{"score":12,"body":"<p>I disagree with the answer with the greatest votes <a href=\"https://stackoverflow.com/a/5344074/1110941\">here</a>. A <strong>Recursive Deep Clone</strong> is <strong>much faster</strong> than the <em>JSON.parse(JSON.stringify(obj))</em> approach mentioned. </p>\n\n<ul>\n<li><strong>Jsperf</strong> ranks it number one here: <a href=\"https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5\" rel=\"noreferrer\">https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5</a></li>\n<li><strong>Jsben</strong> from the answer above updated to show that a recursive deep clone beats all the others mentioned: <a href=\"http://jsben.ch/13YKQ\" rel=\"noreferrer\">http://jsben.ch/13YKQ</a></li>\n</ul>\n\n<p>And here's the function for quick reference:</p>\n\n<pre><code>function cloneDeep (o) {\n  let newO\n  let i\n\n  if (typeof o !== 'object') return o\n\n  if (!o) return o\n\n  if (Object.prototype.toString.apply(o) === '[object Array]') {\n    newO = []\n    for (i = 0; i &lt; o.length; i += 1) {\n      newO[i] = cloneDeep(o[i])\n    }\n    return newO\n  }\n\n  newO = {}\n  for (i in o) {\n    if (o.hasOwnProperty(i)) {\n      newO[i] = cloneDeep(o[i])\n    }\n  }\n  return newO\n}\n</code></pre>\n"},{"score":1,"body":"<p>As this question is having lot of attention and answers with reference to inbuilt features such as Object.assign or custom code to deep clone, i would like to share some libraries to deep clone, </p>\n\n<p><strong>1. esclone</strong></p>\n\n<p>npm install --savedev esclone <a href=\"https://www.npmjs.com/package/esclone\" rel=\"nofollow noreferrer\">https://www.npmjs.com/package/esclone</a></p>\n\n<p>Example use in ES6:</p>\n\n<pre><code>import esclone from \"esclone\";\n\nconst rockysGrandFather = {\n  name: \"Rockys grand father\",\n  father: \"Don't know :(\"\n};\nconst rockysFather = {\n  name: \"Rockys Father\",\n  father: rockysGrandFather\n};\n\nconst rocky = {\n  name: \"Rocky\",\n  father: rockysFather\n};\n\nconst rockyClone = esclone(rocky);\n</code></pre>\n\n<p>Example use in ES5:</p>\n\n<pre><code>var esclone = require(\"esclone\")\nvar foo = new String(\"abcd\")\nvar fooClone = esclone.default(foo)\nconsole.log(fooClone)\nconsole.log(foo === fooClone)\n</code></pre>\n\n<p><strong>2. deep copy</strong></p>\n\n<p>npm install deep-copy\n<a href=\"https://www.npmjs.com/package/deep-copy\" rel=\"nofollow noreferrer\">https://www.npmjs.com/package/deep-copy</a></p>\n\n<p>Example:</p>\n\n<pre><code>var dcopy = require('deep-copy')\n\n// deep copy object \nvar copy = dcopy({a: {b: [{c: 5}]}})\n\n// deep copy array \nvar copy = dcopy([1, 2, {a: {b: 5}}])\n</code></pre>\n\n<p><strong>3. clone-deep</strong></p>\n\n<p>$ npm install --save clone-deep\n<a href=\"https://www.npmjs.com/package/clone-deep\" rel=\"nofollow noreferrer\">https://www.npmjs.com/package/clone-deep</a></p>\n\n<p>Example:</p>\n\n<pre><code>var cloneDeep = require('clone-deep');\n\nvar obj = {a: 'b'};\nvar arr = [obj];\n\nvar copy = cloneDeep(arr);\nobj.c = 'd';\n\nconsole.log(copy);\n//=&gt; [{a: 'b'}] \n\nconsole.log(arr);\n</code></pre>\n"},{"score":5,"body":"<p>There are so many ways to achieve this, but if you want to do this without any library, you can use the following:</p>\n\n<pre><code>const cloneObject = (oldObject) =&gt; {\n  let newObject = oldObject;\n  if (oldObject &amp;&amp; typeof oldObject === 'object') {\n    if(Array.isArray(oldObject)) {\n      newObject = [];\n    } else if (Object.prototype.toString.call(oldObject) === '[object Date]' &amp;&amp; !isNaN(oldObject)) {\n      newObject = new Date(oldObject.getTime());\n    } else {\n      newObject = {};\n      for (let i in oldObject) {\n        newObject[i] = cloneObject(oldObject[i]);\n      }\n    }\n\n  }\n  return newObject;\n}\n</code></pre>\n\n<p>Let me know what you think.</p>\n"},{"score":7,"body":"<p>I am late to answer this question, but I have an another way of cloning the object:</p>\n\n<pre><code>   function cloneObject(obj) {\n        if (obj === null || typeof(obj) !== 'object')\n            return obj;\n        var temp = obj.constructor(); // changed\n        for (var key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                obj['isActiveClone'] = null;\n                temp[key] = cloneObject(obj[key]);\n                delete obj['isActiveClone'];\n            }\n        }\n        return temp;\n    }\n\n\n\nvar b = cloneObject({\"a\":1,\"b\":2});   // calling\n</code></pre>\n\n<p>which is much better and faster then:</p>\n\n<pre><code>var a = {\"a\":1,\"b\":2};\nvar b = JSON.parse(JSON.stringify(a));  \n</code></pre>\n\n<p>and</p>\n\n<pre><code>var a = {\"a\":1,\"b\":2};\n\n// Deep copy\nvar newObject = jQuery.extend(true, {}, a);\n</code></pre>\n\n<p>I have bench-marked the code and you can test the results <a href=\"http://jsben.ch/vyEky\" rel=\"noreferrer\">here</a>:</p>\n\n<p>and sharing the results:\n<a href=\"https://i.stack.imgur.com/K8ztO.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/K8ztO.png\" alt=\"enter image description here\"></a>\nReferences: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty\" rel=\"noreferrer\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty</a></p>\n"},{"score":4,"body":"<p>Here is my way of deep cloning a object with <code>ES2015</code> default value and spread operator</p>\n\n<pre><code> const makeDeepCopy = (obj, copy = {}) =&gt; {\n  for (let item in obj) {\n    if (typeof obj[item] === 'object') {\n      makeDeepCopy(obj[item], copy)\n    }\n    if (obj.hasOwnProperty(item)) {\n      copy = {\n        ...obj\n      }\n    }\n  }\n  return copy\n}\n</code></pre>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"true\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const testObj = {\r\n  \"type\": \"object\",\r\n  \"properties\": {\r\n    \"userId\": {\r\n      \"type\": \"string\",\r\n      \"chance\": \"guid\"\r\n    },\r\n    \"emailAddr\": {\r\n      \"type\": \"string\",\r\n      \"chance\": {\r\n        \"email\": {\r\n          \"domain\": \"fake.com\"\r\n        }\r\n      },\r\n      \"pattern\": \".+@fake.com\"\r\n    }\r\n  },\r\n  \"required\": [\r\n    \"userId\",\r\n    \"emailAddr\"\r\n  ]\r\n}\r\n\r\nconst makeDeepCopy = (obj, copy = {}) =&gt; {\r\n  for (let item in obj) {\r\n    if (typeof obj[item] === 'object') {\r\n      makeDeepCopy(obj[item], copy)\r\n    }\r\n    if (obj.hasOwnProperty(item)) {\r\n      copy = {\r\n        ...obj\r\n      }\r\n    }\r\n  }\r\n  return copy\r\n}\r\n\r\nconsole.log(makeDeepCopy(testObj))</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":3,"body":"<p>What about asynchronous object cloning done by a <code>Promise</code>?</p>\n\n<pre><code>async function clone(thingy /**/)\n{\n    if(thingy instanceof Promise)\n    {\n        throw Error(\"This function cannot clone Promises.\");\n    }\n    return thingy;\n}\n</code></pre>\n"},{"score":3,"body":"<p>Looking through this long list of answers nearly all the solutions have been covered except one that I am aware of. This is the list of VANILLA JS ways of deep cloning an object.</p>\n\n<ol>\n<li><p>JSON.parse(JSON.stringify( obj ) );</p></li>\n<li><p>Through history.state with pushState or replaceState</p></li>\n<li><p>Web Notifications API but this has the downside of asking the user for permissions.</p></li>\n<li><p>Doing your own recursive loop through the object to copy each level.</p></li>\n<li><p>The answer I didn't see -> Using ServiceWorkers. The messages (objects) passed back and forth between the page and the ServiceWorker script will be deep clones of any object.</p></li>\n</ol>\n"},{"score":6,"body":"<p>ES 2017 example:</p>\n\n<pre><code>let objectToCopy = someObj;\nlet copyOfObject = {};\nObject.defineProperties(copyOfObject, Object.getOwnPropertyDescriptors(objectToCopy));\n// copyOfObject will now be the same as objectToCopy\n</code></pre>\n"},{"score":5,"body":"<p>In my experience, a recursive version vastly outperforms <code>JSON.parse(JSON.stringify(obj))</code>. Here is a modernized recursive deep object copy function which can fit on a single line:</p>\n\n<pre><code>function deepCopy(obj) {\n  return Object.keys(obj).reduce((v, d) =&gt; Object.assign(v, {\n    [d]: (obj[d].constructor === Object) ? deepCopy(obj[d]) : obj[d]\n  }), {});\n}\n</code></pre>\n\n<p>This is performing around <a href=\"https://www.measurethat.net/Benchmarks/ShowResult/25487\" rel=\"noreferrer\">40 times faster</a> than the <code>JSON.parse...</code> method.</p>\n"},{"score":3,"body":"<p>For a shallow copy there is a great, simple method introduced in ECMAScript2018 standard. It involves the use of <em>Spread Operator</em> :</p>\n\n<pre><code>let obj = {a : \"foo\", b:\"bar\" , c:10 , d:true , e:[1,2,3] };\n\nlet objClone = { ...obj };\n</code></pre>\n\n<p>I have tested it in Chrome browser, both objects are stored in different locations, so changing immediate child values in either will not change the other.  Though (in the example) changing a value in <code>e</code> will effect both copies.</p>\n\n<p>This technique is very simple and straight forward. I consider this a true Best Practice for this question once and for all. </p>\n"},{"score":4,"body":"<p>Hope this helps.</p>\n\n<pre><code>function deepClone(obj) {\n    /*\n     * Duplicates an object \n     */\n\n    var ret = null;\n    if (obj !== Object(obj)) { // primitive types\n        return obj;\n    }\n    if (obj instanceof String || obj instanceof Number || obj instanceof Boolean) { // string objecs\n        ret = obj; // for ex: obj = new String(\"Spidergap\")\n    } else if (obj instanceof Date) { // date\n        ret = new obj.constructor();\n    } else\n        ret = Object.create(obj.constructor.prototype);\n\n    var prop = null;\n    var allProps = Object.getOwnPropertyNames(obj); //gets non enumerables also\n\n\n    var props = {};\n    for (var i in allProps) {\n        prop = allProps[i];\n        props[prop] = false;\n    }\n\n    for (i in obj) {\n        props[i] = i;\n    }\n\n    //now props contain both enums and non enums \n    var propDescriptor = null;\n    var newPropVal = null; // value of the property in new object\n    for (i in props) {\n        prop = obj[i];\n        propDescriptor = Object.getOwnPropertyDescriptor(obj, i);\n\n        if (Array.isArray(prop)) { //not backward compatible\n            prop = prop.slice(); // to copy the array\n        } else\n        if (prop instanceof Date == true) {\n            prop = new prop.constructor();\n        } else\n        if (prop instanceof Object == true) {\n            if (prop instanceof Function == true) { // function\n                if (!Function.prototype.clone) {\n                    Function.prototype.clone = function() {\n                        var that = this;\n                        var temp = function tmp() {\n                            return that.apply(this, arguments);\n                        };\n                        for (var ky in this) {\n                            temp[ky] = this[ky];\n                        }\n                        return temp;\n                    }\n                }\n                prop = prop.clone();\n\n            } else // normal object \n            {\n                prop = deepClone(prop);\n            }\n\n        }\n\n        newPropVal = {\n            value: prop\n        };\n        if (propDescriptor) {\n            /*\n             * If property descriptors are there, they must be copied\n             */\n            newPropVal.enumerable = propDescriptor.enumerable;\n            newPropVal.writable = propDescriptor.writable;\n\n        }\n        if (!ret.hasOwnProperty(i)) // when String or other predefined objects\n            Object.defineProperty(ret, i, newPropVal); // non enumerable\n\n    }\n    return ret;\n}\n</code></pre>\n\n<p><a href=\"https://github.com/jinujd/Javascript-Deep-Clone\" rel=\"nofollow noreferrer\">https://github.com/jinujd/Javascript-Deep-Clone</a></p>\n"},{"score":73,"body":"<p><strong>Deep copying objects in JavaScript (I think the best and the simplest)</strong></p>\n\n<p><strong>1. Using JSON.parse(JSON.stringify(object));</strong></p>\n\n<pre><code>var obj = { \n  a: 1,\n  b: { \n    c: 2\n  }\n}\nvar newObj = JSON.parse(JSON.stringify(obj));\nobj.b.c = 20;\nconsole.log(obj); // { a: 1, b: { c: 20 } }\nconsole.log(newObj); // { a: 1, b: { c: 2 } } \n</code></pre>\n\n<p><strong>2.Using created method</strong></p>\n\n<pre><code>function cloneObject(obj) {\n    var clone = {};\n    for(var i in obj) {\n        if(obj[i] != null &amp;&amp;  typeof(obj[i])==\"object\")\n            clone[i] = cloneObject(obj[i]);\n        else\n            clone[i] = obj[i];\n    }\n    return clone;\n}\n\nvar obj = { \n  a: 1,\n  b: { \n    c: 2\n  }\n}\nvar newObj = cloneObject(obj);\nobj.b.c = 20;\n\nconsole.log(obj); // { a: 1, b: { c: 20 } }\nconsole.log(newObj); // { a: 1, b: { c: 2 } } \n</code></pre>\n\n<p><strong>3. Using Lo-Dash's _.cloneDeep</strong> link <a href=\"https://lodash.com/docs/4.17.10#cloneDeep\" rel=\"noreferrer\">lodash</a></p>\n\n<pre><code>var obj = { \n  a: 1,\n  b: { \n    c: 2\n  }\n}\n\nvar newObj = _.cloneDeep(obj);\nobj.b.c = 20;\nconsole.log(obj); // { a: 1, b: { c: 20 } }\nconsole.log(newObj); // { a: 1, b: { c: 2 } } \n</code></pre>\n\n<p><strong>4. Using Object.assign() method</strong></p>\n\n<pre><code>var obj = { \n  a: 1,\n  b: 2\n}\n\nvar newObj = _.clone(obj);\nobj.b = 20;\nconsole.log(obj); // { a: 1, b: 20 }\nconsole.log(newObj); // { a: 1, b: 2 }  \n</code></pre>\n\n<p><strong>BUT WRONG WHEN</strong></p>\n\n<pre><code>var obj = { \n  a: 1,\n  b: { \n    c: 2\n  }\n}\n\nvar newObj = Object.assign({}, obj);\nobj.b.c = 20;\nconsole.log(obj); // { a: 1, b: { c: 20 } }\nconsole.log(newObj); // { a: 1, b: { c: 20 } } --&gt; WRONG\n// Note: Properties on the prototype chain and non-enumerable properties cannot be copied.\n</code></pre>\n\n<p><strong>5.Using Underscore.js _.clone</strong> link <a href=\"https://underscorejs.org/#clone\" rel=\"noreferrer\">Underscore.js</a></p>\n\n<pre><code>var obj = { \n  a: 1,\n  b: 2\n}\n\nvar newObj = _.clone(obj);\nobj.b = 20;\nconsole.log(obj); // { a: 1, b: 20 }\nconsole.log(newObj); // { a: 1, b: 2 }  \n</code></pre>\n\n<p><strong>BUT WRONG WHEN</strong></p>\n\n<pre><code>var obj = { \n  a: 1,\n  b: { \n    c: 2\n  }\n}\n\nvar newObj = _.cloneDeep(obj);\nobj.b.c = 20;\nconsole.log(obj); // { a: 1, b: { c: 20 } }\nconsole.log(newObj); // { a: 1, b: { c: 20 } } --&gt; WRONG\n// (Create a shallow-copied clone of the provided plain object. Any nested objects or arrays will be copied by reference, not duplicated.)\n</code></pre>\n\n<p><strong>JSBEN.CH Performance Benchmarking Playground 1~3 <a href=\"http://jsben.ch/KVQLd\" rel=\"noreferrer\">http://jsben.ch/KVQLd</a></strong>\n<a href=\"https://i.stack.imgur.com/Assgk.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/Assgk.png\" alt=\"Performance Deep copying objects in JavaScript\"></a></p>\n"},{"score":2,"body":"<p>When your object is nested and it contains data object, other structured object or some property object, etc then using <code>JSON.parse(JSON.stringify(object))</code> or <code>Object.assign({}, obj)</code> or <code>$.extend(true, {}, obj)</code> will not work. In that case use lodash. It is simple and easy..</p>\n\n<pre><code>var obj = {a: 25, b: {a: 1, b: 2}, c: new Date(), d: anotherNestedObject };\nvar A = _.cloneDeep(obj);\n</code></pre>\n\n<p>Now A will be your new cloned of obj without any references.. </p>\n"},{"score":2,"body":"<p>if you find yourself doing this type of thing regular ( eg- creating undo redo functionality ) it might be worth looking into <a href=\"https://facebook.github.io/immutable-js/\" rel=\"nofollow noreferrer\">Immutable.js</a></p>\n\n<pre><code>const map1 = Immutable.fromJS( { a: 1, b: 2, c: { d: 3 } } );\nconst map2 = map1.setIn( [ 'c', 'd' ], 50 );\n\nconsole.log( `${ map1.getIn( [ 'c', 'd' ] ) } vs ${ map2.getIn( [ 'c', 'd' ] ) }` ); // \"3 vs 50\"\n</code></pre>\n\n<p><a href=\"https://codepen.io/anon/pen/OBpqNE?editors=1111\" rel=\"nofollow noreferrer\">https://codepen.io/anon/pen/OBpqNE?editors=1111</a></p>\n"},{"score":6,"body":"<blockquote>\n  <p>In JavaScript, you can write your <code>deepCopy</code> method like </p>\n</blockquote>\n\n<pre><code>function deepCopy(src) {\n  let target = Array.isArray(src) ? [] : {};\n  for (let prop in src) {\n    let value = src[prop];\n    if(value &amp;&amp; typeof value === 'object') {\n      target[prop] = deepCopy(value);\n  } else {\n      target[prop] = value;\n  }\n }\n    return target;\n}\n</code></pre>\n"},{"score":-1,"body":"<p>How about merging the <i>keys</i> of the object with its <i>values</i>?</p>\n\n<pre><code>function deepClone(o) {\n    var keys = Object.keys(o);\n    var values = Object.values(o);\n\n    var clone = {};\n\n    keys.forEach(function(key, i) {\n        clone[key] = typeof values[i] == 'object' ? Object.create(values[i]) : values[i];\n    });\n\n    return clone;\n}\n</code></pre>\n\n<p><strong>Note:</strong> <em>This method doesn't necessarily make shallow copies</em>, but it only copies with the depth of one inner-object, meaning that when you are given something like <code>{a: {b: {c: null}}}</code>, it will only clone the objects that are directly inside of them, so  <code>deepClone(a.b).c</code> is technically a reference to <code>a.b.c</code>, while <code>deepClone(a).b</code> is a clone, <em>not a reference</em>.</p>\n"},{"score":0,"body":"<pre><code>function clone(obj) {\n    var copy;\n\n    // Handle the 3 simple types, and null or undefined\n    if (null == obj || \"object\" != typeof obj) return obj;\n\n    // Handle Date\n    if (obj instanceof Date) {\n        copy = new Date();\n        copy.setTime(obj.getTime());\n        return copy;\n    }\n\n    // Handle Array\n    if (obj instanceof Array) {\n        copy = [];\n        for (var i = 0, len = obj.length; i &lt; len; i++) {\n            copy[i] = clone(obj[i]);\n        }\n        return copy;\n    }\n\n    // Handle Object\n    if (obj instanceof Object) {\n        copy = {};\n        for (var attr in obj) {\n            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr]);\n        }\n        return copy;\n    }\n\n    throw new Error(\"Unable to copy obj! Its type isn't supported.\");\n}\n</code></pre>\n\n<p>use the following method instead of <code>JSON.parse(JSON.stringify(obj))</code>  because \nit is slower than the following method </p>\n\n<p><a href=\"https://stackoverflow.com/questions/728360/how-do-i-correctly-clone-a-javascript-object\">How do I correctly clone a JavaScript object?</a></p>\n"},{"score":1,"body":"<p>With the proposal of the new method <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries\" rel=\"nofollow noreferrer\">Object.fromEntries()</a> that is supported on newer versions of some browsers (<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries#Browser_compatibility\" rel=\"nofollow noreferrer\">reference</a>). I want to contribute with the next recursive approach:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const obj = {\r\n  key1: {key11: \"key11\", key12: \"key12\", key13: {key131: 22}},\r\n  key2: {key21: \"key21\", key22: \"key22\"},\r\n  key3: \"key3\",\r\n  key4: [1,2,3, {key: \"value\"}]\r\n}\r\n\r\nconst cloneObj = (obj) =&gt;\r\n{\r\n    if (Object(obj) !== obj)\r\n       return obj;\r\n    else if (Array.isArray(obj))\r\n       return obj.map(cloneObj);\r\n\r\n    return Object.fromEntries(Object.entries(obj).map(\r\n        ([k,v]) =&gt; ([k, cloneObj(v)])\r\n    ));\r\n}\r\n\r\n// Clone the original object.\r\nlet newObj = cloneObj(obj);\r\n\r\n// Make changes on the original object.\r\nobj.key1.key11 = \"TEST\";\r\nobj.key3 = \"TEST\";\r\nobj.key1.key13.key131 = \"TEST\";\r\nobj.key4[1] = \"TEST\";\r\nobj.key4[3].key = \"TEST\";\r\n\r\n// Display both objects on the console.\r\nconsole.log(\"Original object: \", obj);\r\nconsole.log(\"Cloned object: \", newObj);</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>.as-console {background-color:black !important; color:lime;}\r\n.as-console-wrapper {max-height:100% !important; top:0;}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":3,"body":"<p>My scenario was a bit different. I had an object with nested objects as well as functions. Therefore, <code>Object.assign()</code> and <code>JSON.stringify()</code> were not solutions to my problem. Using third-party libraries was not an option for me neither.</p>\n\n<p>Hence, I decided to make a simple function to use built-in methods to copy an object with its literal properties, its nested objects, and functions.</p>\n\n<pre><code>let deepCopy = (target, source) =&gt; {\n    Object.assign(target, source);\n    // check if there's any nested objects\n    Object.keys(source).forEach((prop) =&gt; {\n        /**\n          * assign function copies functions and\n          * literals (int, strings, etc...)\n          * except for objects and arrays, so:\n          */\n        if (typeof(source[prop]) === 'object') {\n            // check if the item is, in fact, an array\n            if (Array.isArray(source[prop])) {\n                // clear the copied referenece of nested array\n                target[prop] = Array();\n                // iterate array's item and copy over\n                source[prop].forEach((item, index) =&gt; {\n                    // array's items could be objects too!\n                    if (typeof(item) === 'object') {\n                        // clear the copied referenece of nested objects\n                        target[prop][index] = Object();\n                        // and re do the process for nested objects\n                        deepCopy(target[prop][index], item);\n                    } else {\n                        target[prop].push(item);\n                    }\n                });\n            // otherwise, treat it as an object\n            } else {\n                // clear the copied referenece of nested objects\n                target[prop] = Object();\n                // and re do the process for nested objects\n                deepCopy(target[prop], source[prop]);\n            }\n        }\n    });\n};\n</code></pre>\n\n<p>Here's a test code:</p>\n\n<pre><code>let a = {\n    name: 'Human', \n    func: () =&gt; {\n        console.log('Hi!');\n    }, \n    prop: {\n        age: 21, \n        info: {\n            hasShirt: true, \n            hasHat: false\n        }\n    },\n    mark: [89, 92, { exam: [1, 2, 3] }]\n};\n\nlet b = Object();\n\ndeepCopy(b, a);\n\na.name = 'Alien';\na.func = () =&gt; { console.log('Wassup!'); };\na.prop.age = 1024;\na.prop.info.hasShirt = false;\na.mark[0] = 87;\na.mark[1] = 91;\na.mark[2].exam = [4, 5, 6];\n\nconsole.log(a); // updated props\nconsole.log(b);\n</code></pre>\n\n<p>For efficiency-related concerns, I believe this is the simplest and most efficient solution to the problem I had. I would appreciate any comments on this algorithm that could make it more efficient.</p>\n"},{"score":3,"body":"<p><code>Object.assign({},sourceObj)</code> only clones the object if their property is not having reference type key.\nex </p>\n\n<pre><code>obj={a:\"lol\",b:[\"yes\",\"no\",\"maybe\"]}\nclonedObj = Object.assign({},obj);\n\nclonedObj.b.push(\"skip\")// changes will reflected to the actual obj as well because of its reference type.\nobj.b //will also console =&gt; yes,no,maybe,skip\n</code></pre>\n\n<p>So for the deep cloning is not possible to achieve in this way.</p>\n\n<p>The best solution that works is</p>\n\n<pre><code>var obj = Json.stringify(yourSourceObj)\nvar cloned = Json.parse(obj);\n</code></pre>\n"},{"score":2,"body":"<p>This is my solution without using any library or native javascript function.</p>\n\n<pre><code>function deepClone(obj) {\n  if (typeof obj !== \"object\") {\n    return obj;\n  } else {\n    let newObj =\n      typeof obj === \"object\" &amp;&amp; obj.length !== undefined ? [] : {};\n    for (let key in obj) {\n      if (key) {\n        newObj[key] = deepClone(obj[key]);\n      }\n    }\n    return newObj;\n  }\n}\n</code></pre>\n"}],"score":5177}