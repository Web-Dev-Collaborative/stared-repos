{"body":"<p>I have this string:</p>\n\n<pre><code>\"Test abc test test abc test test test abc test test abc\"\n</code></pre>\n\n<p>Doing:</p>\n\n<pre><code>str = str.replace('abc', '');\n</code></pre>\n\n<p>seems to only remove the first occurrence of <code>abc</code> in the string above.</p>\n\n<p>How can I replace <strong>all</strong> occurrences of it?</p>\n","title":"How to replace all occurrences of a string?","answers":[{"score":719,"body":"<p>Using a regular expression with the <code>g</code> flag set will replace all:</p>\n\n<pre><code>someString = 'the cat looks like a cat';\nanotherString = someString.replace(/cat/g, 'dog');\n// anotherString now contains \"the dog looks like a dog\"\n</code></pre>\n\n<h3><a href=\"http://www.tizag.com/javascriptT/javascript-string-replace.php\" rel=\"noreferrer\">See here also</a></h3>\n"},{"score":72,"body":"<p>Match against a global regular expression:</p>\n\n<pre><code>anotherString = someString.replace(/cat/g, 'dog');\n</code></pre>\n"},{"score":4567,"body":"<p><strong>As of August 2020</strong>, greenfield browsers have support for the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\" rel=\"noreferrer\"><code>String.replaceAll()</code> method</a> defined by the ECMAScript 2021 language specification. For older/legacy browser support, the below still applies.</p>\n<hr />\n<pre class=\"lang-js prettyprint-override\"><code>str = str.replace(/abc/g, '');\n</code></pre>\n<p>In response to comment:</p>\n<pre class=\"lang-js prettyprint-override\"><code>var find = 'abc';\nvar re = new RegExp(find, 'g');\n\nstr = str.replace(re, '');\n</code></pre>\n<p>In response to <a href=\"https://stackoverflow.com/users/49153/click-upvote\">Click Upvote</a>'s comment, you could simplify it even more:</p>\n<pre class=\"lang-js prettyprint-override\"><code>function replaceAll(str, find, replace) {\n  return str.replace(new RegExp(find, 'g'), replace);\n}\n</code></pre>\n<p><strong>Note:</strong> Regular expressions contain special (meta) characters, and as such it is dangerous to blindly pass an argument in the <code>find</code> function above without pre-processing it to escape those characters.  This is covered in the <a href=\"https://developer.mozilla.org/en-US/\" rel=\"noreferrer\">Mozilla Developer Network</a>'s <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\" rel=\"noreferrer\">JavaScript Guide on Regular Expressions</a>, where they present the following utility function (which has changed at least twice since this answer was originally written, so make sure to check the MDN site for potential updates):</p>\n<pre class=\"lang-js prettyprint-override\"><code>function escapeRegExp(string) {\n  return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&amp;'); // $&amp; means the whole matched string\n}\n</code></pre>\n<p>So in order to make the <code>replaceAll()</code> function above safer, it could be modified to the following if you also include <code>escapeRegExp</code>:</p>\n<pre class=\"lang-js prettyprint-override\"><code>function replaceAll(str, find, replace) {\n  return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n</code></pre>\n"},{"score":45,"body":"<pre><code>str = str.replace(/abc/g, '');\n</code></pre>\n\n<p>Or try the replaceAll function from here:</p>\n\n<p><a href=\"https://stackoverflow.com/questions/1137436/useful-javascript-methods-that-extends-built-in-objects/1137579#1137579\">What are useful JavaScript methods that extends built-in objects?</a></p>\n\n<pre><code>str = str.replaceAll('abc', ''); OR\n\nvar search = 'abc';\nstr = str.replaceAll(search, '');\n</code></pre>\n\n<p><strong>EDIT:</strong> Clarification about replaceAll availability</p>\n\n<p>The 'replaceAll' method is added to String's prototype. This means it will be available for all string objects/literals.</p>\n\n<p>E.g.</p>\n\n<pre><code>var output = \"test this\".replaceAll('this', 'that');  //output is 'test that'.\noutput = output.replaceAll('that', 'this'); //output is 'test this'\n</code></pre>\n"},{"score":37,"body":"<p>Use a regular expression:</p>\n\n<pre><code>str.replace(/abc/g, '');\n</code></pre>\n"},{"score":1887,"body":"<p><strong>Update:</strong> As of August 2020, you can use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\" rel=\"noreferrer\"><code>replaceAll</code></a>\nas shown here:</p>\n<pre class=\"lang-js prettyprint-override\"><code>let result = &quot;1 abc 2 abc 3&quot;.replaceAll(&quot;abc&quot;, &quot;xyz&quot;);\n// `result` is &quot;1 xyz 2 xyz 3&quot;\n</code></pre>\n<hr />\n<p>For older browsers:</p>\n<p><strong>Note: Don't use the following solution in performance critical code.</strong></p>\n<p>As an alternative to regular expressions for a simple literal string, you could use</p>\n<pre><code>str = &quot;Test abc test test abc test...&quot;.split(&quot;abc&quot;).join(&quot;&quot;);\n</code></pre>\n<p>The general pattern is</p>\n<pre><code>str.split(search).join(replacement)\n</code></pre>\n<p>This used to be faster in some cases than using <code>replaceAll</code> and a regular expression, but that doesn't seem to be the case anymore in modern browsers.</p>\n<p>Benchmark: <a href=\"https://jsperf.com/replace-all-vs-split-join\" rel=\"noreferrer\">https://jsperf.com/replace-all-vs-split-join</a></p>\n<p>Conclusion: If you have a performance critical use case (e.g processing hundreds of strings), use the Regexp method. But for most typical use cases, this is well worth not having to worry about special characters.</p>\n"},{"score":5,"body":"<p>My implementation, very self explanatory</p>\n\n<pre><code>function replaceAll(string, token, newtoken) {\n    if(token!=newtoken)\n    while(string.indexOf(token) &gt; -1) {\n        string = string.replace(token, newtoken);\n    }\n    return string;\n}\n</code></pre>\n"},{"score":88,"body":"<p><em><strong>Update:</strong></em></p>\n\n<p>It's somewhat late for an update, but since I just stumbled on this question, and noticed that my previous answer is not one I'm happy with. Since the question involved replaceing a single word, it's incredible nobody thought of using word boundaries (<code>\\b</code>)</p>\n\n<pre><code>'a cat is not a caterpillar'.replace(/\\bcat\\b/gi,'dog');\n//\"a dog is not a caterpillar\"\n</code></pre>\n\n<p>This is a simple regex that avoids replacing parts of words in most cases. However, a dash <code>-</code> is still considered a word boundary. So conditionals can be used in this case to avoid replacing strings like <code>cool-cat</code>:</p>\n\n<pre><code>'a cat is not a cool-cat'.replace(/\\bcat\\b/gi,'dog');//wrong\n//\"a dog is not a cool-dog\" -- nips\n'a cat is not a cool-cat'.replace(/(?:\\b([^-]))cat(?:\\b([^-]))/gi,'$1dog$2');\n//\"a dog is not a cool-cat\"\n</code></pre>\n\n<hr>\n\n<p>basically, this question is the same as the question here:\n<a href=\"https://stackoverflow.com/questions/9499075/javascript-replace-with/9499926\">Javascript replace &quot; &#39; &quot; with &quot; &#39;&#39; &quot;</a></p>\n\n<p>@Mike, check the answer I gave there... regexp isn't the only way to replace multiple occurrences of a subsrting, far from it. Think flexible, think split!</p>\n\n<pre><code>var newText = \"the cat looks like a cat\".split('cat').join('dog');\n</code></pre>\n\n<p>Alternatively, to prevent replacing word parts -which the approved answer will do, too! You can get around this issue using regular expressions that are, I admit, somewhat more complex and as an upshot of that, a tad slower, too:</p>\n\n<pre><code>var regText = \"the cat looks like a cat\".replace(/(?:(^|[^a-z]))(([^a-z]*)(?=cat)cat)(?![a-z])/gi,\"$1dog\");\n</code></pre>\n\n<p>The output is the same as the accepted answer, however, using the /cat/g expression on this string:</p>\n\n<pre><code>var oops = 'the cat looks like a cat, not a caterpillar or coolcat'.replace(/cat/g,'dog');\n//returns \"the dog looks like a dog, not a dogerpillar or cooldog\" ?? \n</code></pre>\n\n<p>Oops indeed, this probably isn't what you want. What is, then? IMHO, a regex that only replaces 'cat' conditionally. (ie not part of a word), like so:</p>\n\n<pre><code>var caterpillar = 'the cat looks like a cat, not a caterpillar or coolcat'.replace(/(?:(^|[^a-z]))(([^a-z]*)(?=cat)cat)(?![a-z])/gi,\"$1dog\");\n//return \"the dog looks like a dog, not a caterpillar or coolcat\"\n</code></pre>\n\n<p>My guess is, this meets your needs. It's not fullproof, of course, but it should be enough to get you started. I'd recommend reading some more on these pages. This'll prove useful in perfecting this expression to meet your specific needs.</p>\n\n<p><a href=\"http://www.javascriptkit.com/jsref/regexp.shtml\" rel=\"noreferrer\">http://www.javascriptkit.com/jsref/regexp.shtml</a></p>\n\n<p><a href=\"http://www.regular-expressions.info\" rel=\"noreferrer\">http://www.regular-expressions.info</a></p>\n\n<hr>\n\n<p><strong>Final addition:</strong></p>\n\n<p>Given that this question still gets a lot of views, I thought I might add an example of <code>.replace</code> used with a callback function. In this case, it dramatically simplifies the expression <em>and</em> provides even more flexibility, like replacing with correct capitalisation or replacing both <code>cat</code> and <code>cats</code> in one go:</p>\n\n<pre><code>'Two cats are not 1 Cat! They\\'re just cool-cats, you caterpillar'\n   .replace(/(^|.\\b)(cat)(s?\\b.|$)/gi,function(all,char1,cat,char2)\n    {\n       //check 1st, capitalize if required\n       var replacement = (cat.charAt(0) === 'C' ? 'D' : 'd') + 'og';\n       if (char1 === ' ' &amp;&amp; char2 === 's')\n       {//replace plurals, too\n           cat = replacement + 's';\n       }\n       else\n       {//do not replace if dashes are matched\n           cat = char1 === '-' || char2 === '-' ? cat : replacement;\n       }\n       return char1 + cat + char2;//return replacement string\n    });\n//returns:\n//Two dogs are not 1 Dog! They're just cool-cats, you caterpillar\n</code></pre>\n"},{"score":115,"body":"<p>Here's a string prototype function based on the accepted answer:</p>\n\n<pre><code>String.prototype.replaceAll = function (find, replace) {\n    var str = this;\n    return str.replace(new RegExp(find, 'g'), replace);\n};\n</code></pre>\n\n<p><strong>EDIT</strong> </p>\n\n<p>If your <code>find</code> will contain special characters then you need to escape them:</p>\n\n<pre><code>String.prototype.replaceAll = function (find, replace) {\n    var str = this;\n    return str.replace(new RegExp(find.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&amp;'), 'g'), replace);\n};\n</code></pre>\n\n<p>Fiddle: <a href=\"http://jsfiddle.net/cdbzL/\">http://jsfiddle.net/cdbzL/</a></p>\n"},{"score":16,"body":"<p>I like this method (it looks a little cleaner):</p>\n\n<pre><code>text = text.replace(new RegExp(\"cat\",\"g\"), \"dog\"); \n</code></pre>\n"},{"score":26,"body":"<p>//loop it until number occurrences comes to 0. OR simply copy/paste</p>\n\n<pre><code>    function replaceAll(find, replace, str) \n    {\n      while( str.indexOf(find) &gt; -1)\n      {\n        str = str.replace(find, replace);\n      }\n      return str;\n    }\n</code></pre>\n"},{"score":21,"body":"<p>If what you want to find is already in a string, and you don't have a regex escaper handy, you can use join/split:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>    function replaceMulti(haystack, needle, replacement)\r\n    {\r\n        return haystack.split(needle).join(replacement);\r\n    }\r\n\r\n    someString = 'the cat looks like a cat';\r\n    console.log(replaceMulti(someString, 'cat', 'dog'));</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":2452,"body":"<p>For the sake of completeness, I got to thinking about which method I should use to do this. There are basically two ways to do this as suggested by the other answers on this page.</p>\n\n<p><strong>Note:</strong> In general, extending the built-in prototypes in JavaScript is generally not recommended. I am providing as extensions on the String prototype simply for purposes of illustration, showing different implementations of a hypothetical standard method on the <code>String</code> built-in prototype.</p>\n\n<hr>\n\n<h3>Regular Expression Based Implementation</h3>\n\n<pre><code>String.prototype.replaceAll = function(search, replacement) {\n    var target = this;\n    return target.replace(new RegExp(search, 'g'), replacement);\n};\n</code></pre>\n\n<h3>Split and Join (Functional) Implementation</h3>\n\n<pre><code>String.prototype.replaceAll = function(search, replacement) {\n    var target = this;\n    return target.split(search).join(replacement);\n};\n</code></pre>\n\n<hr>\n\n<p>Not knowing too much about how regular expressions work behind the scenes in terms of efficiency, I tended to lean toward the split and join implementation in the past without thinking about performance. When I did wonder which was more efficient, and by what margin, I used it as an excuse to find out.</p>\n\n<p>On my Chrome Windows&nbsp;8 machine, <strong>the regular expression based implementation is the fastest</strong>, with the <strong>split and join implementation being 53% slower</strong>. Meaning the regular expressions are twice as fast for the lorem ipsum input I used.</p>\n\n<p>Check out this <a href=\"http://jsben.ch/#/LFfWA\" rel=\"noreferrer\"><strong>benchmark</strong></a> running these two implementations against each other.</p>\n\n<hr>\n\n<p>As noted in the comment below by @ThomasLeduc and others, there could be an issue with the regular expression-based implementation if <code>search</code> contains certain characters which are reserved as <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters\" rel=\"noreferrer\">special characters in regular expressions</a>. The implementation assumes that the caller will escape the string beforehand or will only pass strings that are without the characters in the table in <em><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters\" rel=\"noreferrer\">Regular Expressions</a></em> (MDN).</p>\n\n<p>MDN also provides an implementation to escape our strings. It would be nice if this was also standardized as <code>RegExp.escape(str)</code>, but alas, it does not exist:</p>\n\n<pre><code>function escapeRegExp(str) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&amp;\"); // $&amp; means the whole matched string\n}\n</code></pre>\n\n<p>We could call <code>escapeRegExp</code> within our <code>String.prototype.replaceAll</code> implementation, however, I'm not sure how much this will affect the performance (potentially even for strings for which the escape is not needed, like all alphanumeric strings).</p>\n"},{"score":13,"body":"<pre><code>var str = \"ff ff f f a de def\";\nstr = str.replace(/f/g,'');\nalert(str);\n</code></pre>\n\n<p><a href=\"http://jsfiddle.net/ANHR9/\">http://jsfiddle.net/ANHR9/</a></p>\n"},{"score":5,"body":"<p>For replacing all kind of characters, try this code:</p>\n\n<pre><code>Suppose we have need to send \" and \\ in my string, then we will convert it \" to \\\" and \\ to \\\\\n</code></pre>\n\n<p>So this method will solve this issue.</p>\n\n<pre><code>String.prototype.replaceAll = function (find, replace) {\n     var str = this;\n     return str.replace(new RegExp(find.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&amp;'), 'g'), replace);\n };\n\nvar message = $('#message').val();\n             message = message.replaceAll('\\\\', '\\\\\\\\'); /*it will replace \\ to \\\\ */\n             message = message.replaceAll('\"', '\\\\\"');   /*it will replace \" to \\\\\"*/\n</code></pre>\n\n<p>I was using Ajax, and I had the need to send parameters in JSON format. Then my method is looking like this:</p>\n\n<pre><code> function sendMessage(source, messageID, toProfileID, userProfileID) {\n\n     if (validateTextBox()) {\n         var message = $('#message').val();\n         message = message.replaceAll('\\\\', '\\\\\\\\');\n         message = message.replaceAll('\"', '\\\\\"');\n         $.ajax({\n             type: \"POST\",\n             async: \"false\",\n             contentType: \"application/json; charset=utf-8\",\n             url: \"services/WebService1.asmx/SendMessage\",\n             data: '{\"source\":\"' + source + '\",\"messageID\":\"' + messageID + '\",\"toProfileID\":\"' + toProfileID + '\",\"userProfileID\":\"' + userProfileID + '\",\"message\":\"' + message + '\"}',\n             dataType: \"json\",\n             success: function (data) {\n                 loadMessageAfterSend(toProfileID, userProfileID);\n                 $(\"#&lt;%=PanelMessageDelete.ClientID%&gt;\").hide();\n                 $(\"#message\").val(\"\");\n                 $(\"#delMessageContainer\").show();\n                 $(\"#msgPanel\").show();\n             },\n             error: function (result) {\n                 alert(\"message sending failed\");\n             }\n         });\n     }\n     else {\n         alert(\"Please type message in message box.\");\n         $(\"#message\").focus();\n\n     }\n }\n\n String.prototype.replaceAll = function (find, replace) {\n     var str = this;\n     return str.replace(new RegExp(find.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&amp;'), 'g'), replace);\n };\n</code></pre>\n"},{"score":1,"body":"<p>Try this:</p>\n\n<pre><code>String.prototype.replaceAll = function (sfind, sreplace) {\n    var str = this;\n\n    while (str.indexOf(sfind) &gt; -1) {\n        str = str.replace(sfind, sreplace);\n    }\n\n    return str;\n};\n</code></pre>\n"},{"score":25,"body":"<p>This is the <strong>fastest</strong> version that <em>doesn't use regular expressions</em>.</p>\n\n<p><a href=\"http://jsperf.com/replace-all-vs-split-join/10\" rel=\"noreferrer\">Revised jsperf</a></p>\n\n<pre><code>replaceAll = function(string, omit, place, prevstring) {\n  if (prevstring &amp;&amp; string === prevstring)\n    return string;\n  prevstring = string.replace(omit, place);\n  return replaceAll(prevstring, omit, place, string)\n}\n</code></pre>\n\n<p>It is almost <strong>twice</strong> as fast as the split and join method.</p>\n\n<p>As pointed out in a comment here, this will not work if your <code>omit</code> variable contains <code>place</code>, as in: <code>replaceAll(\"string\", \"s\", \"ss\")</code>, because it will always be able to replace another occurrence of the word.</p>\n\n<p>There is another jsperf with variants on my recursive replace that go even faster (<a href=\"http://jsperf.com/replace-all-vs-split-join/12\" rel=\"noreferrer\">http://jsperf.com/replace-all-vs-split-join/12</a>)!</p>\n\n<ul>\n<li>Update July 27th 2017: It looks like RegExp now has the fastest performance in the recently released Chrome 59.</li>\n</ul>\n"},{"score":13,"body":"<pre><code>while (str.indexOf('abc') !== -1)\n{\n    str = str.replace('abc', '');\n}\n</code></pre>\n"},{"score":3,"body":"<p>If using a library is an option for you then you will get the benefits of the testing and community support that goes with a library function. For example, the <a href=\"http://stringjs.com/\" rel=\"nofollow\">string.js</a> library has a replaceAll() function that does what you're looking for:</p>\n\n<pre><code>// Include a reference to the string.js library and call it (for example) S.\nstr = S(str).replaceAll('abc', '').s;\n</code></pre>\n"},{"score":10,"body":"<p>If you are trying to ensure that the string you are looking for won't exist even after the replacement, you need to use a loop.</p>\n\n<p>For example:</p>\n\n<pre><code>var str = 'test aabcbc';\nstr = str.replace(/abc/g, '');\n</code></pre>\n\n<p>When complete, you will still have 'test abc'!</p>\n\n<p>The simplest loop to solve this would be:</p>\n\n<pre><code>var str = 'test aabcbc';\nwhile (str != str.replace(/abc/g, '')){\n   str.replace(/abc/g, '');\n}\n</code></pre>\n\n<p>But that runs the replacement twice for each cycle. Perhaps (at risk of being voted down) that can be combined for a slightly more efficient but less readable form:</p>\n\n<pre><code>var str = 'test aabcbc';\nwhile (str != (str = str.replace(/abc/g, ''))){}\n// alert(str); alerts 'test '!\n</code></pre>\n\n<p>This can be particularly useful when looking for duplicate strings.<br>\nFor example, if we have 'a,,,b' and we wish to remove all duplicate commas.<br>\n[In that case, one could do .replace(/,+/g,','), but at some point the regex gets complex and slow enough to loop instead.]</p>\n"},{"score":19,"body":"<pre><code>function replaceAll(str, find, replace) {\n  var i = str.indexOf(find);\n  if (i &gt; -1){\n    str = str.replace(find, replace); \n    i = i + replace.length;\n    var st2 = str.substring(i);\n    if(st2.indexOf(find) &gt; -1){\n      str = str.substring(0,i) + replaceAll(st2, find, replace);\n    }       \n  }\n  return str;\n}\n</code></pre>\n"},{"score":8,"body":"<p>Just add <code>/g</code> <br/></p>\n\n<pre><code>document.body.innerHTML = document.body.innerHTML.replace('hello', 'hi');\n</code></pre>\n\n<p>to</p>\n\n<pre><code>// Replace 'hello' string with /hello/g regular expression.\ndocument.body.innerHTML = document.body.innerHTML.replace(/hello/g, 'hi');\n</code></pre>\n\n<p><code>/g</code> means global</p>\n"},{"score":32,"body":"<p>Replacing single quotes:</p>\n\n<pre><code>function JavaScriptEncode(text){\n    text = text.replace(/'/g,'&amp;apos;')\n    // More encode here if required\n\n    return text;\n}\n</code></pre>\n"},{"score":6,"body":"<p>I use <strong>p</strong> to store the result from the previous recursion replacement:</p>\n\n<pre><code>function replaceAll(s, m, r, p) {\n    return s === p || r.contains(m) ? s : replaceAll(s.replace(m, r), m, r, s);\n}\n</code></pre>\n\n<p>It will replace all occurrences in the string <strong>s</strong> until it is possible:</p>\n\n<pre><code>replaceAll('abbbbb', 'ab', 'a') → 'abbbb' → 'abbb' → 'abb' → 'ab' → 'a'\n</code></pre>\n\n<p>To avoid infinite loop I check if the replacement <strong>r</strong> contains a match <strong>m</strong>:</p>\n\n<pre><code>replaceAll('abbbbb', 'a', 'ab') → 'abbbbb'\n</code></pre>\n"},{"score":7,"body":"<p>You can simply use below method</p>\n\n<pre><code>/**\n * Replace all the occerencess of $find by $replace in $originalString\n * @param  {originalString} input - Raw string.\n * @param  {find} input - Target key word or regex that need to be replaced.\n * @param  {replace} input - Replacement key word\n * @return {String}       Output string\n */\nfunction replaceAll(originalString, find, replace) {\n  return originalString.replace(new RegExp(find, 'g'), replace);\n};\n</code></pre>\n"},{"score":7,"body":"<p>The following function works for me:</p>\n\n<pre><code>String.prototype.replaceAllOccurence = function(str1, str2, ignore)\n{\n    return this.replace(new RegExp(str1.replace(/([\\/\\,\\!\\\\\\^\\$\\{\\}\\[\\]\\(\\)\\.\\*\\+\\?\\|\\&lt;\\&gt;\\-\\&amp;])/g,\"\\\\$&amp;\"),(ignore?\"gi\":\"g\")),(typeof(str2)==\"string\")?str2.replace(/\\$/g,\"$$$$\"):str2);\n} ;\n</code></pre>\n\n<p>Now call the functions like this:</p>\n\n<pre><code>\"you could be a Project Manager someday, if you work like this.\".replaceAllOccurence (\"you\", \"I\");\n</code></pre>\n\n<p>Simply copy and paste this code in your browser console to TEST.</p>\n"},{"score":4,"body":"<p>Here is the working code with prototype:</p>\n\n<pre><code>String.prototype.replaceAll = function(find, replace) {\n    var str = this;\n    return str.replace(new RegExp(find.replace(/([.*+?^=!:${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\"), 'g'), replace);\n};\n</code></pre>\n"},{"score":4,"body":"<pre><code>function replaceAll(str, find, replace) {\n    var $r=\"\";\n    while($r!=str){ \n        $r = str;\n        str = str.replace(find, replace);\n    }\n    return str;\n}\n</code></pre>\n"},{"score":10,"body":"<p>Although people have mentioned the use of regex but there's a better approach if you want to replace the text irrespective of the case of the text. Like uppercase or lowercase. Use below syntax</p>\n\n<pre><code>//Consider below example\noriginalString.replace(/stringToBeReplaced/gi, '');\n\n//Output will be all the occurrences removed irrespective of casing.\n</code></pre>\n\n<p>You can refer the detailed example <a href=\"http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html\" rel=\"noreferrer\">here</a>.</p>\n"},{"score":41,"body":"<p>Say you want to replace all the 'abc' with 'x':</p>\n\n<pre><code>let some_str = 'abc def def lom abc abc def'.split('abc').join('x')\nconsole.log(some_str) //x def def lom x x def\n</code></pre>\n\n<p>I was trying to think about something more simple than modifying the string prototype.</p>\n"},{"score":2,"body":"<p>This can be solved using regular expressions and the flag <code>g</code>, which means to not stop after finding the first match. Really, regular expressions are life savers!</p>\n\n<pre><code>function replaceAll(string, pattern, replacement) {\n    return string.replace(new RegExp(pattern, \"g\"), replacement);\n}\n\n// or if you want myString.replaceAll(\"abc\", \"\");\n\nString.prototype.replaceAll = function(pattern, replacement) {\n    return this.replace(new RegExp(pattern, \"g\"), replacement);\n};\n</code></pre>\n"},{"score":5,"body":"<p>Most people are likely doing this to encode a URL. To encode a URL, you shouldn't only consider spaces, but convert the entire string properly with <code>encodeURI</code>.</p>\n\n<pre><code>encodeURI(\"http://www.google.com/a file with spaces.html\")\n</code></pre>\n\n<p>to get:</p>\n\n<pre><code>http://www.google.com/a%20file%20with%20spaces.html\n</code></pre>\n"},{"score":41,"body":"<p>Using <code>RegExp</code> in <strong>JavaScript</strong> could do the job for you, just simply do something like below code, don't forget the <code>/g</code> after which standout for <strong>global</strong>:</p>\n\n<pre><code>var str =\"Test abc test test abc test test test abc test test abc\";\nstr = str.replace(/abc/g, '');\n</code></pre>\n\n<p>If you think of reuse, create a function to do that for you, but it's not recommended as it's only one line function, but again if you heavily use this, you can write something like this:</p>\n\n<pre><code>String.prototype.replaceAll = String.prototype.replaceAll || function(string, replaced) {\n  return this.replace(new RegExp(string, 'g'), replaced);\n};\n</code></pre>\n\n<p>and simply use it in your code over and over like below:</p>\n\n<pre><code>var str =\"Test abc test test abc test test test abc test test abc\";\nstr = str.replaceAll('abc', '');\n</code></pre>\n\n<p>But as I mention earlier, it won't make a huge difference in terms of lines to be written or performance, only caching the function may effect some faster performance on long strings and also a good practice of DRY code if you want to reuse.</p>\n"},{"score":5,"body":"<p>In my apps, I use a custom function that is the most powerful for this purpose, and even wrapping the <code>split/join</code> solution in the simpler case, it is a little bit faster in <code>Chrome 60</code>and <code>Firefox 54</code>  (<a href=\"http://jsben.ch/kdv27\" rel=\"nofollow noreferrer\"><code>JSBEN.CH</code></a>) than other solutions. My computer runs <code>Windows 7 64 bits</code>.</p>\n\n<p>The advantage is that this custom function can handle many substitutions at the same time using strings or characters, which can be a shortcut for some applications.</p>\n\n<p>Like a <code>split/join</code> above solution, the solution below has no problem with escape characters, differently than regular expression approach.</p>\n\n<pre><code>  function replaceAll(s,find,repl,caseOff,byChar){\n  if (arguments.length&lt;2)  return false; \n  var destDel = ! repl;       // if destDel delete all keys from target\n  var isString = !! byChar;   // if byChar, replace set of characters \n  if (typeof find !==typeof repl &amp;&amp; ! destDel)  return false; \n  if (isString  &amp;&amp;  (typeof find!==\"string\"))   return false; \n\n  if (! isString &amp;&amp;  (typeof find===\"string\"))  {\n    return s.split(find).join(destDel?\"\":repl);\n  }\n\n  if ((! isString)  &amp;&amp;  ( ! Array.isArray(find) ||\n          ( ! Array.isArray(repl) &amp;&amp; ! destDel)   ))  return false;\n\n     // if destOne replace all strings/characters by just one element\n  var destOne = destDel ? false : (repl.length===1);   \n\n     // Generally source and destination should have the same size\n  if (! destOne &amp;&amp; ! destDel &amp;&amp; find.length!==repl.length)  return false    \n\n  var prox,sUp,findUp,i,done;   \n  if (caseOff)  {    // case insensitive    \n       // Working with uppercase keys and target \n    sUp = s.toUpperCase();   \n    if (isString)\n       findUp = find.toUpperCase()   \n    else\n       findUp = find.map(function(el){  return el.toUpperCase();});    \n\n  } else  {         // case sensitive\n     sUp = s;\n     findUp =find.slice();  // clone array/string\n  }  \n\n  done = new Array(find.length);  // size: number of keys\n  done.fill(null);              \n\n  var pos = 0;       // initial position in target s\n  var r = \"\";   // initial result\n  var aux, winner;\n  while (pos &lt; s.length)  {       // Scanning the target\n     prox  = Number.MAX_SAFE_INTEGER;\n     winner = -1;  // no winner at start\n     for (i=0;i&lt;findUp.length;i++)   // find next occurence for each string\n       if (done[i]!==-1) {    // key still alive\n             // Never search for the word/char or is over?\n         if (done[i]===null || done[i]&lt;pos)  { \n           aux = sUp.indexOf(findUp[i],pos);\n           done[i]=aux;  // Save the next occurrence\n         } else\n           aux = done[i]   // restore the position of last search\n         if (aux&lt;prox &amp;&amp; aux!==-1) {   // if next occurrence is minimum\n           winner = i;     // save it  \n           prox = aux;\n         }  \n       }  // not done\n\n      if (winner===-1) {   // No matches forward\n         r += s.slice(pos);   \n         break;\n      } // no winner\n\n      // found the character or string key in the target\n\n      i = winner;  // restore the winner\n      r += s.slice(pos,prox);   // update piece before the match\n\n            // Append the replacement in target \n      if (! destDel) r += repl[ destOne?0:i ];  \n      pos = prox + ( isString?1:findUp[i].length );       // go after match\n\n  }  // loop\n  return r;  // return the resulting string\n}\n</code></pre>\n\n<p>The documentation is below</p>\n\n<blockquote>\n<pre><code>           replaceAll    \n Syntax    \n ======     \n      replaceAll(s,find,[ repl ,caseOff, byChar)     \n\n Parameters    \n ==========    \n\n   \"s\" is a string target of replacement.    \n   \"find\" can be a string or array of strings.     \n   \"repl\" should be the same type than \"find\" or empty     \n\n  if \"find\" is a string, it is a simple replacement for      \n    all \"find\" occurrences in \"s\" by string \"repl\"    \n\n  if \"find\" is an array, it will replaced each string in \"find\"    \n    that occurs in \"s\" for corresponding string in \"repl\" array.\n  The replace specs are independent: A replacement part cannot    \n    be replaced again. \n\n\n  if \"repl\" is empty all \"find\" occurrences in \"s\" will be deleted.   \n  if \"repl\" has only one character or element,    \n      all occurrences in \"s\" will be replaced for that one.   \n\n  \"caseOff\" is true if replacement is case insensitive     \n       (default is FALSE)\n\n  \"byChar\" is true when replacement is based on set of characters.    \n  Default is false   \n\n  if \"byChar\", it will be replaced in \"s\" all characters in \"find\"   \n  set of characters for corresponding character in  \"repl\"\n  set of characters   \n\n Return   \n ======   \n  the function returns the new string after the replacement.  \n</code></pre>\n</blockquote>\n\n<p>To be fair, I ran the <a href=\"http://jsben.ch/kdv27\" rel=\"nofollow noreferrer\">benchmark</a> with no parameter test. </p>\n\n<p>Here is my test set, using <code>Node.js</code></p>\n\n<pre><code>function l() { return console.log.apply(null, arguments); }\n\nvar k=0;\nl(++k,replaceAll(\"banana is a ripe fruit harvested near the river\",\n      [\"ri\",\"nea\"],[\"do\",\"fa\"]));  //1\nl(++k,replaceAll(\"banana is a ripe fruit harvested near the river\",\n      [\"ri\",\"nea\"],[\"do\"]));  //2\nl(++k,replaceAll(\"banana is a ripe fruit harvested near the river\",\n      [\"ri\",\"nea\"]));  //3\nl(++k,replaceAll(\"banana is a ripe fruit harvested near the river\",\n     \"aeiou\",\"\",\"\",true));  //4\nl(++k,replaceAll(\"banana is a ripe fruit harvested near the river\",\n      \"aeiou\",\"a\",\"\",true));  //5\nl(++k,replaceAll(\"banana is a ripe fruit harvested near the river\",\n      \"aeiou\",\"uoiea\",\"\",true));  //6\nl(++k,replaceAll(\"banana is a ripe fruit harvested near the river\",\n      \"aeiou\",\"uoi\",\"\",true));  //7\nl(++k,replaceAll(\"banana is a ripe fruit harvested near the river\",\n      [\"ri\",\"nea\"],[\"do\",\"fa\",\"leg\"]));  //8\nl(++k,replaceAll(\"BANANA IS A RIPE FRUIT HARVESTED NEAR THE RIVER\",\n      [\"ri\",\"nea\"],[\"do\",\"fa\"]));  //9\nl(++k,replaceAll(\"BANANA IS A RIPE FRUIT HARVESTED NEAR THE RIVER\",\n      [\"ri\",\"nea\"],[\"do\",\"fa\"],true)); //10\nreturn;\n</code></pre>\n\n<p>And the results:</p>\n\n<blockquote>\n  <p>1 'banana is a dope fruit harvested far the dover'<br>\n  2 'banana is a dope fruit harvested dor the dover'<br>\n  3 'banana is a pe fruit harvested r the ver'<br>\n  4 'bnn s  rp frt hrvstd nr th rvr'<br>\n  5 'banana as a rapa fraat harvastad naar tha ravar'<br>\n  6 'bununu is u ripo frait hurvostod nour tho rivor'<br>\n  7 false<br>\n  8 false<br>\n  9 'BANANA IS A RIPE FRUIT HARVESTED NEAR THE RIVER'<br>\n  10 'BANANA IS A doPE FRUIT HARVESTED faR THE doVER'      </p>\n</blockquote>\n"},{"score":13,"body":"<p>If the string contain similar pattern like <code>abccc</code>, you can use this:</p>\n\n<pre><code>str.replace(/abc(\\s|$)/g, \"\")\n</code></pre>\n"},{"score":3,"body":"<p><strong>In string first element search and replace</strong> </p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var str = '[{\"id\":1,\"name\":\"karthikeyan.a\",\"type\":\"developer\"}]'\r\nvar i = str.replace('\"[','[').replace(']\"',']');\r\nconsole.log(i,'//first element search and replace')</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong>In string global search and replace</strong> </p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var str = '[{\"id\":1,\"name\":\"karthikeyan.a\",\"type\":\"developer\"}]'\r\nvar j = str.replace(/\\\"\\[/g,'[').replace(/\\]\\\"/g,']');\r\nconsole.log(j,'//global search and replace')</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":26,"body":"<pre><code>str = str.replace(new RegExp(\"abc\", 'g'), \"\");\n</code></pre>\n\n<p>worked better for me than the above answers. so <code>new RegExp(\"abc\", 'g')</code> creates a RegExp what matches all occurence (<code>'g'</code> flag) of the text (<code>\"abc\"</code>). The second part is what gets replaced to, in your case empty string (<code>\"\"</code>).\n<code>str</code> is the string, and we have to override it, as <code>replace(...)</code> just returns result, but not overrides. In some cases you might want to use that.</p>\n"},{"score":2,"body":"<p>I just want to share my solution, based on some of the functional features of last versions of JavaScript:</p>\n\n<pre><code>   var str = \"Test abc test test abc test test test abc test test abc\";\n\n   var result = str.split(' ').reduce((a, b) =&gt; {\n      return b == 'abc' ? a : a + ' ' + b;   })\n\n  console.warn(result)\n</code></pre>\n"},{"score":3,"body":"<p>For <strong>unique</strong> replaceable values</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>String.prototype.replaceAll = function(search_array, replacement_array) {\r\n  //\r\n  var target = this;\r\n  //\r\n  search_array.forEach(function(substr, index) {\r\n    if (typeof replacement_array[index] != \"undefined\") {\r\n      target = target.replace(new RegExp(substr, 'g'), replacement_array[index])\r\n    }\r\n  });\r\n  //\r\n  return target;\r\n};\r\n\r\n//  Use:\r\nvar replacedString = \"This topic commented on :year. Talking :question.\".replaceAll([':year', ':question'], ['2018', 'How to replace all occurrences of a string in JavaScript']);\r\n//\r\nconsole.log(replacedString);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":5,"body":"<p>In terms of performance related to the main answers <a href=\"http://jsben.ch/BVIHC\" rel=\"noreferrer\">these are some online tests</a>.</p>\n\n<p>While the following are some performance tests using <code>console.time()</code> (they work best in your own console, the time is very short to be seen in the snippet)</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>console.time('split and join');\r\n\"javascript-test-find-and-replace-all\".split('-').join(' ');\r\nconsole.timeEnd('split and join')\r\n\r\nconsole.time('regular expression');\r\n\"javascript-test-find-and-replace-all\".replace(new RegExp('-', 'g'), ' ');\r\nconsole.timeEnd('regular expression');\r\n\r\nconsole.time('while');\r\nlet str1 = \"javascript-test-find-and-replace-all\";\r\nwhile (str1.indexOf('-') !== -1) {\r\n    str1 = str1.replace('-', ' ');\r\n}\r\nconsole.timeEnd('while');</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>The interesting thing to notice is that if you run them multiple time the results are always different even though the <code>RegExp</code> solution seems the fastest on average and the <code>while</code> loop solution the slowest.</p>\n"},{"score":12,"body":"<p>The previous answers are way too complicated. Just use the replace function like this:</p>\n\n<pre><code>str.replace(/your_regex_pattern/g, replacement_string);\n</code></pre>\n\n<p>Example:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var str = \"Test abc test test abc test test test abc test test abc\";\r\n\r\nvar res = str.replace(/[abc]+/g, \"\");\r\n\r\nconsole.log(res);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":0,"body":"<p>You can try like this:</p>\n\n<p>Example data:</p>\n\n<pre><code>var text = \"heloo,hai,hei\"\n\ntext = text.replace(/[,]+/g, '')\n</code></pre>\n\n<p>or</p>\n\n<pre><code>text.forEach(function(value){\n  hasil = hasil.replace(',', '')\n})```\n\n\n</code></pre>\n"},{"score":6,"body":"<p><strong>Method 1</strong></p>\n\n<p>Try to implement a regular expression:</p>\n\n<p>\"Test abc test test abc test test test abc test test abc\".replace(/\\abc/g, ' ');</p>\n\n<p><strong>Method 2</strong></p>\n\n<p>Split and join. Split with abc and join with empty space.</p>\n\n<p>\"Test abc test test abc test test test abc test test abc\".split(\"abc\").join(\" \")</p>\n"},{"score":2,"body":"<p>The best solution, in order to replace any character we use the <code>indexOf()</code>, <code>includes()</code>, and <code>substring()</code> functions to replace the matched string with the provided string in the current string.</p>\n\n<ul>\n<li>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf\" rel=\"nofollow noreferrer\"><code>String.indexOf()</code></a> function is to find the <code>n</code><sup>th</sup> match index position.</li>\n<li>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\" rel=\"nofollow noreferrer\"><code>String.includes()</code></a> method determines whether one string may be found within another string, returning true or false as appropriate.</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring\" rel=\"nofollow noreferrer\"><code>String.substring()</code></a> function is to get the parts of String(<code>preceding</code>,<code>exceding</code>). Add the replace String in-between these parts to generate final return String.</li>\n</ul>\n\n<p>The following function allows to use any character.\n<br />where as <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\" rel=\"nofollow noreferrer\"><code>RegExp</code></a> will not allow some special character like <code>**</code> and some characters need to be escaped, like <code>$</code>.</p>\n\n<pre class=\"lang-javascript prettyprint-override\"><code>String.prototype.replaceAllMatches = function(obj) { // Obj format: { 'matchkey' : 'replaceStr' }\n    var retStr = this;\n    for (var x in obj) {\n        //var matchArray = retStr.match(new RegExp(x, 'ig'));\n        //for (var i = 0; i &lt; matchArray.length; i++) {\n        var prevIndex = retStr.indexOf(x); // matchkey = '*', replaceStr = '$*' While loop never ends.\n        while (retStr.includes(x)) {\n            retStr = retStr.replaceMatch(x, obj[x], 0);\n            var replaceIndex = retStr.indexOf(x);\n            if( replaceIndex &lt;  prevIndex + (obj[x]).length) {\n                break;\n            } else {\n                prevIndex = replaceIndex;\n            }\n        }\n    }\n    return retStr;\n};\nString.prototype.replaceMatch = function(matchkey, replaceStr, matchIndex) {\n    var retStr = this, repeatedIndex = 0;\n    //var matchArray = retStr.match(new RegExp(matchkey, 'ig'));\n    //for (var x = 0; x &lt; matchArray.length; x++) {\n    for (var x = 0; (matchkey != null) &amp;&amp; (retStr.indexOf(matchkey) &gt; -1); x++) {\n        if (repeatedIndex == 0 &amp;&amp; x == 0) {\n            repeatedIndex = retStr.indexOf(matchkey);\n        } else { // matchIndex &gt; 0\n            repeatedIndex = retStr.indexOf(matchkey, repeatedIndex + 1);\n        }\n        if (x == matchIndex) {\n            retStr = retStr.substring(0, repeatedIndex) + replaceStr + retStr.substring(repeatedIndex + (matchkey.length));\n            matchkey = null; // To break the loop.\n        }\n    }\n    return retStr;\n};\n</code></pre>\n\n<hr>\n\n<p>We can also use the regular expression object for matching text with a pattern. The following are functions which will use the regular expression object.</p>\n\n<p>You will get SyntaxError when you are using an <em>invalid</em> regular expression pattern like <code>'**'</code>.</p>\n\n<ul>\n<li>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace\" rel=\"nofollow noreferrer\"><code>String.replace()</code></a> function is used to replace the specified String with the given String.</li>\n<li>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match\" rel=\"nofollow noreferrer\"><code>String.match()</code></a> function is to find how many time the string is repeated.</li>\n<li>The <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test\" rel=\"nofollow noreferrer\"><code>RegExp.prototype.test</code></a> method executes a search for a match between a regular expression and a specified string. Returns true or false.</li>\n</ul>\n\n<pre class=\"lang-javascript prettyprint-override\"><code>String.prototype.replaceAllRegexMatches = function(obj) { // Obj format: { 'matchkey' : 'replaceStr' }\n    var retStr = this;\n    for (var x in obj) {\n        retStr = retStr.replace(new RegExp(x, 'ig'), obj[x]);\n    }\n    return retStr;\n};\n</code></pre>\n\n<blockquote>\n  <p>Note that regular expressions are written without quotes.</p>\n</blockquote>\n\n<hr>\n\n<p>Examples to use the above functions:</p>\n\n<pre class=\"lang-javascript prettyprint-override\"><code>var str = \"yash yas $dfdas.**\";\nconsole.log('String: ', str);\n\n// No need to escape any special character\nconsole.log('Index matched replace: ', str.replaceMatch('as', '*', 2));\nconsole.log('Index Matched replace: ', str.replaceMatch('y', '~', 1));\nconsole.log('All Matched replace: ', str.replaceAllMatches({'as': '**', 'y':'Y', '$':'-'}));\nconsole.log('All Matched replace : ', str.replaceAllMatches({'**': '~~', '$':'&amp;$&amp;', '&amp;':'%', '~':'&gt;'}));\n\n// You need to escape some special Characters\nconsole.log('REGEX all matched replace: ', str.replaceAllRegexMatches({'as' : '**', 'y':'Y', '\\\\$':'-'}));\n</code></pre>\n\n<p>Result:</p>\n\n<pre class=\"lang-none prettyprint-override\"><code>String:  yash yas $dfdas.**\nIndex Matched replace:  yash yas $dfd*.**\nIndex Matched replace:  yash ~as $dfdas.**\n\nAll Matched replace:  Y**h Y** -dfd**.**\nAll Matched replace:  yash yas %$%dfdas.&gt;&gt;\n\nREGEX All Matched replace:  Y**h Y** -dfd**.**\n</code></pre>\n\n<hr>\n"},{"score":1,"body":"<p>The simplest solution -</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>let str = \"Test abc test test abc test test test abc test test abc\";\r\n\r\nstr = str.split(\" \");\r\nstr = str.filter((ele, key)=&gt; ele!==\"abc\")\r\nstr = str.join(\" \")</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Or simply -</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>str = str.split(\" \").filter((ele, key) =&gt; ele != \"abc\").join(\" \")</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":6,"body":"<p>This can be achieved using regular expressions. A few combinations that might help someone:</p>\n\n<pre><code>var word = \"this,\\\\ .is*a*test,    '.and? / only /     'a \\ test?\";\nvar stri = \"This      is    a test         and only a        test\";\n</code></pre>\n\n<p><strong>To replace all non alpha characters,</strong></p>\n\n<pre><code>console.log(word.replace(/([^a-z])/g,' ').replace(/ +/g, ' ')); \nResult: [this is a test and only a test]\n</code></pre>\n\n<p><strong>To replace multiple continuous spaces with one space,</strong></p>\n\n<pre><code>console.log(stri.replace(/  +/g,' ')); \nResult: [This is a test and only a test]\n</code></pre>\n\n<p><strong>To replace all * characters,</strong></p>\n\n<pre><code>console.log(word.replace(/\\*/g,'')); \nResult: [this,\\ .isatest,    '.and? / only /     'a  test?]\n</code></pre>\n\n<p><strong>To replace question marks (?)</strong></p>\n\n<pre><code>console.log(word.replace(/\\?/g,'#')); \nResult: [this,\\ .is*a*test,    '.and# / only /     'a  test#]\n</code></pre>\n\n<p><strong>To replace quotation marks,</strong></p>\n\n<pre><code>console.log(word.replace(/'/g,'#'));  \nResult: [this,\\ .is*a*test,    #.and? / only /     #a  test?]\n</code></pre>\n\n<p><strong>To replace all ' characters,</strong></p>\n\n<pre><code>console.log(word.replace(/,/g,'')); \nResult: [this\\ .is*a*test    '.and? / only /     'a  test?]\n</code></pre>\n\n<p><strong>To replace a specific word,</strong></p>\n\n<pre><code>console.log(word.replace(/test/g,'')); \nResult: [this,\\ .is*a*,    '.and? / only /     'a  ?]\n</code></pre>\n\n<p><strong>To replace back-slash,</strong></p>\n\n<pre><code>console.log(word.replace(/\\\\/g,''));  \nResult: [this, .is*a*test,    '.and? / only /     'a  test?]\n</code></pre>\n\n<p><strong>To replace forward slash,</strong></p>\n\n<pre><code>console.log(word.replace(/\\//g,''));  \nResult: [this,\\ .is*a*test,    '.and?  only      'a  test?]\n</code></pre>\n\n<p><strong>To replace all spaces,</strong></p>\n\n<pre><code>console.log(word.replace(/ /g,'#'));  \nResult: [this,\\#.is*a*test,####'.and?#/#only#/#####'a##test?]\n</code></pre>\n\n<p><strong>To replace dots,</strong></p>\n\n<pre><code>console.log(word.replace(/\\./g,'#')); \nResult: [this,\\ #is*a*test,    '#and? / only /     'a  test?]\n</code></pre>\n"},{"score":1,"body":"<pre><code> var myName = 'r//i//n//o//l////d';\n  var myValidName = myName.replace(new RegExp('\\//', 'g'), ''); &gt; // rinold\n  console.log(myValidName);\n\nvar myPetName = 'manidog';\nvar renameManiToJack = myPetName.replace(new RegExp('mani', 'g'), 'jack'); &gt; // jackdog\n</code></pre>\n"},{"score":60,"body":"<p>These are the most common and readable methods.</p>\n\n<pre><code>var str = \"Test abc test test abc test test test abc test test abc\"\n</code></pre>\n\n<p><strong>Method 1:</strong></p>\n\n<pre><code>str = str.replace(/abc/g, \"replaced text\");\n</code></pre>\n\n<p><strong>Method 2:</strong></p>\n\n<pre><code>str = str.split(\"abc\").join(\"replaced text\");\n</code></pre>\n\n<p><strong>Method 3:</strong></p>\n\n<pre><code>str = str.replace(new RegExp(\"abc\", \"g\"), \"replaced text\");\n</code></pre>\n\n<p><strong>Method 4:</strong></p>\n\n<pre><code>while(str.includes(\"abc\")){\n    str = str.replace(\"abc\", \"replaced text\");\n}\n</code></pre>\n\n<p>Output:</p>\n\n<pre><code>console.log(str);\n// Test replaced text test test replaced text test test test replaced text test test replaced text\n</code></pre>\n"},{"score":5,"body":"<p>I use split and join or this funcion</p>\n\n<pre><code>function replaceAll( text, busca, reemplaza ){\n  while (text.toString().indexOf(busca) != -1)\n      text = text.toString().replace(busca,reemplaza);\n  return text;\n}\n</code></pre>\n"},{"score":2,"body":"<p>This should work.</p>\n\n<pre><code>String.prototype.replaceAll = function (search, replacement) {\n    var str1 = this.replace(search, replacement);\n    var str2 = this;\n    while(str1 != str2) {\n        str2 = str1;\n        str1 = str1.replace(search, replacement);\n    }\n    return str1;\n}\n</code></pre>\n\n<p>Example:</p>\n\n<pre><code>Console.log(\"Steve is the best character in Minecraft\".replaceAll(\"Steve\", \"Alex\"));\n</code></pre>\n"},{"score":15,"body":"<p>The simplest way to this without using any regex is split and join like the code here:</p>\n\n<pre><code>var str = \"Test abc test test abc test test test abc test test abc\";\nstr.split('abc').join('')\n</code></pre>\n"},{"score":0,"body":"<p>All the answers are accepted, you can do this by many ways. One of the trick to do this is this.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code> const str = \"Test abc test test abc test test test abc test test abc\";\r\n    \r\n    const compare = \"abc\";\r\n    arrayStr = str.split(\" \");\r\n    arrayStr.forEach((element, index) =&gt; {\r\n      if (element == compare) {\r\n        arrayStr.splice(index, 1);\r\n      }\r\n    });\r\n    const newString = arrayStr.join(\" \");\r\n    console.log(newString);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":64,"body":"<p>For replacing a single time use:</p>\n\n<pre><code>var res = str.replace('abc', \"\");\n</code></pre>\n\n<p>For replacing multiple times use:</p>\n\n<pre><code>var res = str.replace(/abc/g, \"\");\n</code></pre>\n"},{"score":6,"body":"<p>Check this answer may it will help and I used in my project.</p>\n\n<pre><code>function replaceAll(searchString, replaceString, str) {\n   return str.split(searchString).join(replaceString);\n}\nreplaceAll('abc', '',\"Test abc test test abc test test test abc test test abc\" ); // \"Test  test test  test test test  test test \"\n</code></pre>\n"},{"score":1,"body":"<p>You can do it without Regex, but you need to be careful if the replacement text contains the search text. </p>\n\n<p>e.g. </p>\n\n<pre><code>replaceAll(\"nihIaohi\", \"hI\", \"hIcIaO\", true)\n</code></pre>\n\n<p>So here is a proper variant of replaceAll, including string-prototype:</p>\n\n<pre><code>function replaceAll(str, find, newToken, ignoreCase)\n{\n    let i = -1;\n\n    if (!str)\n    {\n        // Instead of throwing, act as COALESCE if find == null/empty and str == null\n        if ((str == null) &amp;&amp; (find == null))\n            return newToken;\n\n        return str;\n    }\n\n    if (!find) // sanity check \n        return str;\n\n    ignoreCase = ignoreCase || false;\n    find = ignoreCase ? find.toLowerCase() : find;\n\n    while ((\n        i = (ignoreCase ? str.toLowerCase() : str).indexOf(\n            find, i &gt;= 0 ? i + newToken.length : 0\n        )) !== -1\n    )\n    {\n        str = str.substring(0, i) +\n            newToken +\n            str.substring(i + find.length);\n    } // Whend \n\n    return str;\n}\n</code></pre>\n\n<p>Or, if you want to have a string-prototype function: </p>\n\n<pre><code>String.prototype.replaceAll = function (find, replace) {\n    let str = this;\n\n    let i = -1;\n\n    if (!str)\n    {\n        // Instead of throwing, act as COALESCE if find == null/empty and str == null\n        if ((str == null) &amp;&amp; (find == null))\n            return newToken;\n\n        return str;\n    }\n\n    if (!find) // sanity check \n        return str;\n\n    ignoreCase = ignoreCase || false;\n    find = ignoreCase ? find.toLowerCase() : find;\n\n    while ((\n        i = (ignoreCase ? str.toLowerCase() : str).indexOf(\n            find, i &gt;= 0 ? i + newToken.length : 0\n        )) !== -1\n    )\n    {\n        str = str.substring(0, i) +\n            newToken +\n            str.substring(i + find.length);\n    } // Whend \n\n    return str;\n};\n</code></pre>\n"},{"score":3,"body":"<pre><code>str = \"Test abc test test abc test test test abc test test abc\"\n\nstr.split(' ').join().replace(/abc/g,'').replace(/,/g, ' ')\n</code></pre>\n"},{"score":4,"body":"<p>There is now a <a href=\"https://github.com/tc39/proposal-string-replaceall\" rel=\"nofollow noreferrer\">finished proposal</a> for integrating <code>String.prototype.replaceAll</code> into the official specification. Eventually, developers will not have to come up with their own implementations for <code>replaceAll</code> - instead, modern Javascript engines will support it natively.</p>\n<p>The proposal is at stage 4, which <a href=\"https://tc39.es/process-document/\" rel=\"nofollow noreferrer\">means</a> that everything is complete, and all that's left is for browsers to start implementing it.</p>\n<p>It <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll#Browser_compatibility\" rel=\"nofollow noreferrer\">has shipped</a> in the latest versions of Chrome, Firefox, and Safari.</p>\n<p>Here are the implementation details:</p>\n<blockquote>\n<p>Per the current TC39 consensus, <code>String.prototype.replaceAll</code> behaves identically to <code>String.prototype.replace</code> in all cases, <strong>except</strong> for the following two cases:</p>\n<ol>\n<li>If <code>searchValue</code> is a string, <code>String.prototype.replace</code> only replaces a single occurrence of the <code>searchValue</code>, whereas <code>String.prototype.replaceAll</code> replaces <em>all</em> occurrences of the <code>searchValue</code> (as if <code>.split(searchValue).join(replaceValue)</code> or a global &amp; properly-escaped regular expression had been used).</li>\n<li>If <code>searchValue</code> is a non-global regular expression, <code>String.prototype.replace</code> replaces a single match, whereas <code>String.prototype.replaceAll</code> throws an exception. This is done to avoid the inherent confusion between the lack of a global flag (which implies &quot;do NOT replace all&quot;) and the name of the method being called (which strongly suggests &quot;replace all&quot;).</li>\n</ol>\n<p>Notably, <code>String.prototype.replaceAll</code> behaves just like <code>String.prototype.replace</code> if <code>searchValue</code> is a global regular expression.</p>\n</blockquote>\n<p>You can see a spec-compliant polyfill <a href=\"https://github.com/zloirock/core-js#stringreplaceall\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>In supported environments, the following snippet will log <code>foo-bar-baz</code>, without throwing an error:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const str = 'foo bar baz';\nconsole.log(\n  str.replaceAll(' ', '-')\n);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":12,"body":"<p>As of August 2020 there is a <a href=\"https://tc39.es/proposal-string-replaceall/\" rel=\"nofollow noreferrer\">Stage 4 proposal</a> to ECMAScript that adds the <a href=\"https://github.com/tc39/proposal-string-replaceall\" rel=\"nofollow noreferrer\"><code>replaceAll</code></a> method to <code>String</code>.</p>\n<p>It's now supported in <strong>Chrome 85+, Edge 85+, Firefox 77+, Safari 13.1+</strong>.</p>\n<p>The usage is the same as the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace\" rel=\"nofollow noreferrer\"><code>replace</code></a> method:</p>\n<pre><code>String.prototype.replaceAll(searchValue, replaceValue)\n</code></pre>\n<p>Here's an example usage:</p>\n<pre><code>'Test abc test test abc test.'.replaceAll('abc', 'foo'); // -&gt; 'Test foo test test foo test.'\n</code></pre>\n<hr />\n<p>It's supported in <a href=\"https://caniuse.com/#search=replaceAll\" rel=\"nofollow noreferrer\">most modern browsers</a>, but there exist polyfills:</p>\n<ul>\n<li><a href=\"https://github.com/zloirock/core-js#stringreplaceall\" rel=\"nofollow noreferrer\">core-js</a></li>\n<li><a href=\"https://github.com/es-shims/String.prototype.replaceAll\" rel=\"nofollow noreferrer\">es-shims</a></li>\n</ul>\n<p>It is supported in the <a href=\"https://v8.dev/\" rel=\"nofollow noreferrer\">V8</a> engine behind an experimental flag <code>--harmony-string-replaceall</code>.\nRead more on the <a href=\"https://v8.dev/features/string-replaceall\" rel=\"nofollow noreferrer\">V8 website</a>.</p>\n"},{"score":0,"body":"<p>Check this. I'm sure it will help you:</p>\n\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n&lt;p&gt;Click the button to do a global search and replace for \"is\" in a string.&lt;/p&gt;\n&lt;button onclick=\"myFunction()\"&gt;Try it&lt;/button&gt;\n&lt;p id=\"demo\"&gt;&lt;/p&gt;\n&lt;script&gt;\nfunction myFunction() {\n  var str = 'Is this \"3\" dris \"3\"?';\n  var allvar= '\"3\"';\n  var patt1 = new RegExp( allvar, 'g' );\n  document.getElementById(\"demo\").innerHTML = str.replace(patt1,'\"5\"');\n}\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n\n<p>Here is the <a href=\"https://jsfiddle.net/Wsmemon/23ykfjh8/41/\" rel=\"nofollow noreferrer\">JSFiddle link</a>.</p>\n"},{"score":3,"body":"<p>In November 2019 a new feature is added to the JavaScript <code>string.prototype.replaceAll()</code>.</p>\n\n<p>Currently it's only supported with babel.JS, but maybe in the future it can be implemented in all the browsers. For more information, <a href=\"https://v8.dev/features/string-replaceall\" rel=\"nofollow noreferrer\">read here</a>.</p>\n"},{"score":29,"body":"<h2>Performance</h2>\n<p>Today 27.12.2019 I perform tests on <a href=\"https://en.wikipedia.org/wiki/MacOS_High_Sierra\" rel=\"noreferrer\">macOS v10.13.6</a> (High Sierra) for the chosen solutions.</p>\n<p><strong>Conclusions</strong></p>\n<ul>\n<li>The <code>str.replace(/abc/g, '');</code> (<strong>C</strong>) is a good cross-browser fast solution for all strings.</li>\n<li>Solutions based on <code>split-join</code> (<strong>A,B</strong>) or <code>replace</code> (<strong>C,D</strong>) are fast</li>\n<li>Solutions based on <code>while</code> (<strong>E,F,G,H</strong>) are slow - usually ~4 times slower for small strings and about ~3000 times (!) slower for long strings</li>\n<li>The recurrence solutions (<strong>RA,RB</strong>) are slow and do not work for long strings</li>\n</ul>\n<p>I also create my own solution. It looks like currently it is the shortest one which does the question job:</p>\n<pre><code>str.split`abc`.join``\n</code></pre>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>str = \"Test abc test test abc test test test abc test test abc\";\nstr = str.split`abc`.join``\n\nconsole.log(str);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<h2>Details</h2>\n<p>The tests were performed on Chrome 79.0, Safari 13.0.4 and Firefox 71.0 (64 bit). The tests <code>RA</code> and <code>RB</code> use recursion. Results</p>\n<p><a href=\"https://i.stack.imgur.com/si5UK.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/si5UK.png\" alt=\"Enter image description here\" /></a></p>\n<h2>Short string - 55 characters</h2>\n<p>You can run tests on your machine <a href=\"https://jsperf.com/remove-substring-small/1\" rel=\"noreferrer\">HERE</a>. Results for Chrome:</p>\n<p><a href=\"https://i.stack.imgur.com/Ctf18.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/Ctf18.png\" alt=\"Enter image description here\" /></a></p>\n<h2>Long string: 275 000 characters</h2>\n<p>The recursive solutions <strong>RA</strong> and <strong>RB</strong> gives</p>\n<blockquote>\n<p>RangeError: Maximum call stack size exceeded</p>\n</blockquote>\n<p>For 1M characters they even break Chrome</p>\n<p><a href=\"https://i.stack.imgur.com/dNkYp.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/dNkYp.png\" alt=\"enter image description here\" /></a></p>\n<p>I try to perform tests for 1M characters for other solutions, but <strong>E,F,G,H</strong> takes so much time that browser ask me to break script so I shrink test string to 275K characters. You can run tests on your machine <a href=\"https://jsperf.com/remove-substring-big/1\" rel=\"noreferrer\">HERE</a>. Results for Chrome</p>\n<p><a href=\"https://i.stack.imgur.com/0uEgk.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/0uEgk.png\" alt=\"enter image description here\" /></a></p>\n<p>Code used in tests</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var t=\"Test abc test test abc test test test abc test test abc\"; // .repeat(5000)\nvar log = (version,result) =&gt; console.log(`${version}: ${result}`);\n\n\nfunction A(str) {\n  return str.split('abc').join('');\n}\n\nfunction B(str) {\n  return str.split`abc`.join``; // my proposition\n}\n\n\nfunction C(str) {\n  return str.replace(/abc/g, '');\n}\n\nfunction D(str) {\n  return str.replace(new RegExp(\"abc\", \"g\"), '');\n}\n\nfunction E(str) {\n  while (str.indexOf('abc') !== -1) { str = str.replace('abc', ''); }\n  return str;\n}\n\nfunction F(str) {\n  while (str.indexOf('abc') !== -1) { str = str.replace(/abc/, ''); }\n  return str;\n}\n\nfunction G(str) {\n  while(str.includes(\"abc\")) { str = str.replace('abc', ''); }\n  return str;\n}\n\n// src: https://stackoverflow.com/a/56989553/860099\nfunction H(str)\n{\n    let i = -1\n    let find = 'abc';\n    let newToken = '';\n\n    if (!str)\n    {\n        if ((str == null) &amp;&amp; (find == null)) return newToken;\n        return str;\n    }\n\n    while ((\n        i = str.indexOf(\n            find, i &gt;= 0 ? i + newToken.length : 0\n        )) !== -1\n    )\n    {\n        str = str.substring(0, i) +\n            newToken +\n            str.substring(i + find.length);\n    }\n    return str;\n}\n\n// src: https://stackoverflow.com/a/22870785/860099\nfunction RA(string, prevstring) {\n  var omit = 'abc';\n  var place = '';\n  if (prevstring &amp;&amp; string === prevstring)\n    return string;\n  prevstring = string.replace(omit, place);\n  return RA(prevstring, string)\n}\n\n// src: https://stackoverflow.com/a/26107132/860099\nfunction RB(str) {\n  var find = 'abc';\n  var replace = '';\n  var i = str.indexOf(find);\n  if (i &gt; -1){\n    str = str.replace(find, replace);\n    i = i + replace.length;\n    var st2 = str.substring(i);\n    if(st2.indexOf(find) &gt; -1){\n      str = str.substring(0,i) + RB(st2, find, replace);\n    }\n  }\n  return str;\n}\n\n\n\n\nlog('A ', A(t));\nlog('B ', B(t));\nlog('C ', C(t));\nlog('D ', D(t));\nlog('E ', E(t));\nlog('F ', F(t));\nlog('G ', G(t));\nlog('H ', H(t));\nlog('RA', RA(t)); // use reccurence\nlog('RB', RB(t)); // use reccurence</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;p style=\"color:red\"&gt;This snippet only presents codes used in tests. It not perform test itself!&lt;p&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":1,"body":"<p>We can use the <code>replace</code> method in JavaScript:</p>\n\n<pre><code>var result = yourString.replace('regexPattern', \"replaceString\");\n</code></pre>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var str = \"Test abc test test abc test test test abc test test abc\";\r\n\r\nvar expectedString = str.replace(/abc(\\s|$)/g, \"\");\r\n\r\nconsole.log(expectedString);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":1,"body":"<p>I know this isnt the best way to do this, but you can try this:</p>\n\n<pre><code>var annoyingString = \"Test abc test test abc test test test abc test test abc\";\n\nwhile (annoyingString.includes(\"abc\")) {\n    annoyingString = annoyingString.replace(\"abc\", \"\")\n}\n</code></pre>\n"},{"score":0,"body":"<p>I added the function below to this perf test page in the \"library\" section:</p>\n\n<p><a href=\"https://jsben.ch/LFfWA\" rel=\"nofollow noreferrer\">https://jsben.ch/LFfWA</a></p>\n\n<pre><code>function _replace(t, s, r){\n    var i = t.indexOf(s);\n    if (i == -1) return t;\n    return t.slice(0, i) + r + _replace(t.slice(i + s.length, t.length), s,r);\n}\n</code></pre>\n\n<p>..and put this in as the test:</p>\n\n<pre><code>var replaced = _replace(testString, 'abc','123');\n</code></pre>\n\n<p>.. and that function performs about 34% faster for me than split or regex. The idea / hope was to end up pasting smaller and smaller pieces of the string onto the stack and then building the entire result by unrolling the stack, thereby minimizing extra string copies and extra searches through the same string data and hopefully optimizing use of the CPU cache.</p>\n\n<p>Part of the thought was that if the string isn't too big, it may end up in the CPU cache; passing it and pasting pieces of it puts those bits into the cache, and then the searching can operate entirely using CPU cached data. Now whether or not that's actually what ends up happening I'm sure is entirely js implementation dependant.</p>\n\n<p>This isn't as fast as possible, but it's as fast as I could manage without mutable strings. Arrays in JavaScript probably have a pointer for each element, so, a solution involving a lot of array elements is not likely to be as CPU cache friendly as this.</p>\n"},{"score":0,"body":"<p>Starting from v85, chrome now supports <code>String.prototype.replaceAll</code> natively. Note this outperform all other proposed solutions and should be used once majorly supported.</p>\n\n<p>Feature status:\n<a href=\"https://chromestatus.com/feature/6040389083463680\" rel=\"nofollow noreferrer\">https://chromestatus.com/feature/6040389083463680</a></p>\n\n<pre><code>str s = \"hello hello world\";\ns = s.replaceAll(\"hello\", \"\"); // s is now \"world\"\n</code></pre>\n"},{"score":4,"body":"<p>Here's very simple solution.\nYou can assign a new method to String object</p>\n<pre><code>String.prototype.replaceAll = function(search, replace){\n   return this.replace(new RegExp(search, 'g'), replace)\n}\n\nvar str = &quot;Test abc test test abc test test test abc test test abc&quot;;\nstr = str.replaceAll('abc', '');\n\nconsole.log(str) // -&gt; Test  test test  test test test  test test\n</code></pre>\n"},{"score":1,"body":"<p>Use Split and Join</p>\n<pre><code>var str  = &quot;Test abc test test abc test test test abc test test abc&quot;;\nvar replaced_str = str.split('abc').join('');\n</code></pre>\n"},{"score":0,"body":"<p>I would suggest adding a global method for string class by appending it to prototype chain.</p>\n<pre><code>String.prototype.replaceAll = function(fromReplace, toReplace, {ignoreCasing} = {}) { return this.replace(new RegExp(fromReplace, ignoreCasing ? 'ig': 'g'), toReplace);}\n</code></pre>\n<p>and it can be used like</p>\n<pre><code>'stringwithpattern'.replaceAll('pattern','new-pattern')\n</code></pre>\n"},{"score":1,"body":"<p><strong>In August 2020</strong></p>\n<blockquote>\n<p>No more regular expression stuff</p>\n</blockquote>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const str = \"Test abc test test abc test test test abc test test abc\";\nconst modifiedStr = str.replaceAll('abc', '');\nconsole.log(modifiedStr);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\" rel=\"nofollow noreferrer\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll</a></p>\n"},{"score":1,"body":"<p>This solution combines some previous answers and conforms somewhat better to the proposed August 2020 standard solution. This solution is still viable for me in September 2020, as <code>String.replaceAll</code> is not available in the <code>node</code> binary I am using.</p>\n<hr />\n<p><code>RegExp.escape</code> is a separate issue to deal with, but is important here because the official proposed solution will automatically escape <code>string</code>-based <code>find</code> input. This <code>String.replaceAll</code> polyfill would not without the <code>RegExp.escape</code> logic.</p>\n<p>I have added an answer which doesn't polyfill <code>RegExp.Escape</code>, in the case that you don't want that.</p>\n<hr />\n<p>If you pass a <code>RegExp</code> to <code>find</code>, you <em>MUST</em> include <code>g</code> as a flag. This polyfill won't provide a nice TypeError for you and will cause you a major bad time.</p>\n<p>If you need exact standards conformance, for an application which is rigorously relying on the standard implementation, then I suggest using <code>babel</code> or some other tool to get you the 'right answer' every time instead of SO dot com. That way you won't have any surprises.</p>\n<hr />\n<p>Code:</p>\n<pre><code>if (!Object.prototype.hasOwnProperty.call(RegExp, 'escape')) {\n  RegExp.escape = function(string) {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\n    // https://github.com/benjamingr/RegExp.escape/issues/37\n    return string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&amp;'); // $&amp; means the whole matched string\n  };\n}\n\nif (!Object.prototype.hasOwnProperty.call(String, 'replaceAll')) {\n  String.prototype.replaceAll = function(find, replace) {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\n    // If you pass a RegExp to 'find', you _MUST_ include 'g' as a flag.\n    // TypeError: &quot;replaceAll must be called with a global RegExp&quot; not included, will silently cause significant errors. _MUST_ include 'g' as a flag for RegExp.\n    // String parameters to 'find' do not require special handling.\n    // Does not conform to &quot;special replacement patterns&quot; when &quot;Specifying a string as a parameter&quot; for replace\n    // Does not conform to &quot;Specifying a function as a parameter&quot; for replace\n    return this.replace(\n          Object.prototype.toString.call(find) == '[object RegExp]' ?\n            find :\n            new RegExp(RegExp.escape(find), 'g'),\n          replace\n        );\n  }\n}\n</code></pre>\n<p>Code, Minified:</p>\n<pre><code>Object.prototype.hasOwnProperty.call(RegExp,&quot;escape&quot;)||(RegExp.escape=function(e){return e.replace(/[.*+\\-?^${}()|[\\]\\\\]/g,&quot;\\\\$&amp;&quot;)}),Object.prototype.hasOwnProperty.call(String,&quot;replaceAll&quot;)||(String.prototype.replaceAll=function(e,t){return this.replace(&quot;[object RegExp]&quot;==Object.prototype.toString.call(e)?e:new RegExp(RegExp.escape(e),&quot;g&quot;),t)});\n</code></pre>\n<hr />\n<p>Example:</p>\n<pre><code>console.log(\n  't*.STVAL'\n    .replaceAll(\n      new RegExp(RegExp.escape('T*.ST'), 'ig'),\n      'TEST'\n    )\n);\n\nconsole.log(\n  't*.STVAL'\n    .replaceAll(\n      't*.ST',\n      'TEST'\n    );\n);\n</code></pre>\n<hr />\n<p>Code without <code>RegExp.Escape</code>:</p>\n<pre><code>if (!Object.prototype.hasOwnProperty.call(String, 'replaceAll')) {\n  String.prototype.replaceAll = function(find, replace) {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replaceAll\n    // If you pass a RegExp to 'find', you _MUST_ include 'g' as a flag.\n    // TypeError: &quot;replaceAll must be called with a global RegExp&quot; not included, will silently cause significant errors. _MUST_ include 'g' as a flag for RegExp.\n    // String parameters to 'find' do not require special handling.\n    // Does not conform to &quot;special replacement patterns&quot; when &quot;Specifying a string as a parameter&quot; for replace\n    // Does not conform to &quot;Specifying a function as a parameter&quot; for replace\n    return this.replace(\n          Object.prototype.toString.call(find) == '[object RegExp]' ?\n            find :\n            new RegExp(find.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&amp;'), 'g'),\n          replace\n        );\n  }\n}\n</code></pre>\n<p>Code without <code>RegExp.Escape</code>, Minified:</p>\n<pre><code>Object.prototype.hasOwnProperty.call(String,&quot;replaceAll&quot;)||(String.prototype.replaceAll=function(e,t){return this.replace(&quot;[object RegExp]&quot;==Object.prototype.toString.call(e)?e:new RegExp(e.replace(/[.*+\\-?^${}()|[\\]\\\\]/g,&quot;\\\\$&amp;&quot;),&quot;g&quot;),t)});\n</code></pre>\n<hr />\n"}],"score":4636}