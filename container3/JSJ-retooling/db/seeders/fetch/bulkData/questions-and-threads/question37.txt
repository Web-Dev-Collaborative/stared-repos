{"body":"<p>I have a JavaScript object like the following:</p>\n\n<pre><code>var p = {\n    \"p1\": \"value1\",\n    \"p2\": \"value2\",\n    \"p3\": \"value3\"\n};\n</code></pre>\n\n<p>Now I want to loop through all <code>p</code> elements (<code>p1</code>, <code>p2</code>, <code>p3</code>...) And get their keys and values. How can I do that?</p>\n\n<p>I can modify the JavaScript object if necessary. My ultimate goal is to loop through some key value pairs and if possible I want to avoid using <code>eval</code>.</p>\n","title":"How do I loop through or enumerate a JavaScript object?","answers":[{"score":26,"body":"<pre><code>for(key in p) {\n  alert( p[key] );\n}\n</code></pre>\n\n<p>Note: you can do this over arrays, but you'll iterate over the <code>length</code> and other properties, too.</p>\n"},{"score":53,"body":"<p>You can just iterate over it like:</p>\n\n<pre><code>for (var key in p) {\n  alert(p[key]);\n}\n</code></pre>\n\n<p>Note that <code>key</code> will not take on the value of the property, it's just an index value.</p>\n"},{"score":4558,"body":"<p>You can use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in\" rel=\"noreferrer\"><code>for-in</code></a> loop as shown by others. However, you also have to make sure that the key you get is an actual property of an object, and doesn't come from the prototype.</p>\n\n<p><strong>Here is the snippet:</strong>\n<div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var p = {\r\n    \"p1\": \"value1\",\r\n    \"p2\": \"value2\",\r\n    \"p3\": \"value3\"\r\n};\r\n\r\nfor (var key in p) {\r\n    if (p.hasOwnProperty(key)) {\r\n        console.log(key + \" -&gt; \" + p[key]);\r\n    }\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong>For-of with Object.keys() alternative:</strong></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var p = {\r\n    0: \"value1\",\r\n    \"b\": \"value2\",\r\n    key: \"value3\"\r\n};\r\n\r\nfor (var key of Object.keys(p)) {\r\n    console.log(key + \" -&gt; \" + p[key])\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Notice the use of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of\" rel=\"noreferrer\"><code>for-of</code></a> instead of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in\" rel=\"noreferrer\"><code>for-in</code></a>, if not used it will return undefined on named properties, and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" rel=\"noreferrer\"><code>Object.keys()</code></a> ensures the use of only the object's own properties without the whole prototype-chain properties</p>\n\n<p><strong>Using the new <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\" rel=\"noreferrer\"><code>Object.entries()</code></a> method:</strong></p>\n\n<p><strong>Note:</strong> This method is not supported natively by Internet Explorer. You may consider using a Polyfill for older browsers.</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>const p = {\n    \"p1\": \"value1\",\n    \"p2\": \"value2\",\n    \"p3\": \"value3\"\n};\n\nfor (let [key, value] of Object.entries(p)) {\n  console.log(`${key}: ${value}`);\n}\n</code></pre>\n"},{"score":350,"body":"<p>You have to use the <strong>for-in loop</strong></p>\n\n<p>But be very careful when using this kind of loop, because this will <strong>loop all the properties along the prototype chain</strong>.</p>\n\n<p>Therefore, when using for-in loops, always make use of the <code>hasOwnProperty</code> method to determine if the current property in iteration is really a property of the object you're checking on:</p>\n\n<pre><code>for (var prop in p) {\n    if (!p.hasOwnProperty(prop)) {\n        //The current property is not a direct property of p\n        continue;\n    }\n    //Do your logic with the property here\n}\n</code></pre>\n"},{"score":1160,"body":"<p>Under ECMAScript 5, you can combine <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" rel=\"noreferrer\"><code>Object.keys()</code></a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\" rel=\"noreferrer\"><code>Array.prototype.forEach()</code></a>:</p>\n\n<pre><code>var obj = { first: \"John\", last: \"Doe\" };\n\nObject.keys(obj).forEach(function(key) {\n    console.log(key, obj[key]);\n});\n</code></pre>\n\n<p>ECMAScript 6 adds <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of\" rel=\"noreferrer\"><code>for...of</code></a>:</p>\n\n<pre><code>for (const key of Object.keys(obj)) {\n    console.log(key, obj[key]);\n}\n</code></pre>\n\n<p>ECMAScript 8 adds <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\" rel=\"noreferrer\"><code>Object.entries()</code></a> which avoids having to look up each value in the original object:</p>\n\n<pre><code>Object.entries(obj).forEach(\n    ([key, value]) =&gt; console.log(key, value)\n);\n</code></pre>\n\n<p>You can combine <code>for...of</code>, destructuring, and <code>Object.entries</code>:</p>\n\n<pre><code>for (const [key, value] of Object.entries(obj)) {\n    console.log(key, value);\n}\n</code></pre>\n\n<p>Both <code>Object.keys()</code> and <code>Object.entries()</code> iterate properties in the same order as a <code>for...in</code> loop <em>but ignore the prototype chain</em>. Only the object's own enumerable properties are iterated.</p>\n"},{"score":21,"body":"<p>After looking through all the answers in here, hasOwnProperty isn't required for my own usage because my json object is clean; there's really no sense in adding any additional javascript processing. This is all I'm using:</p>\n\n<pre><code>for (var key in p) {\n    console.log(key + ' =&gt; ' + p[key]);\n    // key is key\n    // value is p[key]\n}\n</code></pre>\n"},{"score":14,"body":"<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var p = {\r\n    \"p1\": \"value1\",\r\n    \"p2\": \"value2\",\r\n    \"p3\": \"value3\"\r\n};\r\n\r\nfor (var key in p) {\r\n    if (p.hasOwnProperty(key)) {\r\n        console.log(key + \" = \" + p[key]);\r\n    }\r\n}</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;p&gt;\r\n  Output:&lt;br&gt;\r\n  p1 = values1&lt;br&gt;\r\n  p2 = values2&lt;br&gt;\r\n  p3 = values3\r\n&lt;/p&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":20,"body":"<p>via <strong>prototype</strong> with <strong>forEach()</strong> which should skip the <strong>prototype chain</strong> properties:</p>\n\n<pre><code>Object.prototype.each = function(f) {\n    var obj = this\n    Object.keys(obj).forEach( function(key) { \n        f( key , obj[key] ) \n    });\n}\n\n\n//print all keys and values\nvar obj = {a:1,b:2,c:3}\nobj.each(function(key,value) { console.log(key + \" \" + value) });\n// a 1\n// b 2\n// c 3\n</code></pre>\n"},{"score":257,"body":"<p>The question won't be complete if we don't mention about alternative methods for looping through objects.</p>\n\n<p>Nowadays many well known JavaScript libraries provide their own methods for iterating over collections, i.e. over <em>arrays</em>, <em>objects</em>, and <em>array-like objects</em>. These methods are convenient to use and are entirely compatible with any browser.</p>\n\n<ol>\n<li><p>If you work with <strong>jQuery</strong>, you may use <a href=\"http://api.jquery.com/jQuery.each/\" rel=\"noreferrer\"><code>jQuery.each()</code></a> method. It can be used to seamlessly iterate over both objects and arrays:</p>\n\n<pre><code>$.each(obj, function(key, value) {\n    console.log(key, value);\n});\n</code></pre></li>\n<li><p>In <strong>Underscore.js</strong> you can find method <a href=\"http://underscorejs.org/#each\" rel=\"noreferrer\"><code>_.each()</code></a>, which iterates over a list of elements, yielding each in turn to a supplied function (pay attention to the order of arguments in <em>iteratee</em> function!):</p>\n\n<pre><code>_.each(obj, function(value, key) {\n    console.log(key, value);\n});\n</code></pre></li>\n<li><p><strong>Lo-Dash</strong> provides several methods for iterating over object properties. Basic <a href=\"http://lodash.com/docs#forEach\" rel=\"noreferrer\"><code>_.forEach()</code></a> (or it's alias <code>_.each()</code>) is useful for looping through both objects and arrays, however (!) objects with <code>length</code> property are treated like arrays, and to avoid this behavior it is suggested to use <a href=\"http://lodash.com/docs#forIn\" rel=\"noreferrer\"><code>_.forIn()</code></a> and <a href=\"http://lodash.com/docs#forOwn\" rel=\"noreferrer\"><code>_.forOwn()</code></a> methods (these also have <code>value</code> argument coming first):</p>\n\n<pre><code>_.forIn(obj, function(value, key) {\n    console.log(key, value);\n});\n</code></pre>\n\n<p><code>_.forIn()</code> iterates over <em>own and inherited</em> enumerable properties of an object, while <code>_.forOwn()</code> iterates only over <em>own</em> properties of an object (basically checking against <code>hasOwnProperty</code> function). For simple objects and object literals any of these methods will work fine.</p></li>\n</ol>\n\n<p>Generally all described methods have the same behaviour with any supplied objects. Besides using native <code>for..in</code> loop will usually be <em>faster</em> than any abstraction, such as <code>jQuery.each()</code>, these methods are considerably easier to use, require less coding and provide better error handling.</p>\n"},{"score":54,"body":"<p>In ECMAScript 5 you have new approach in iteration fields of literal - <code>Object.keys</code></p>\n\n<p>More information you can see on <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" rel=\"noreferrer\">MDN</a></p>\n\n<p>My choice is below as a faster solution in current versions of browsers (Chrome30, IE10, FF25)</p>\n\n<pre><code>var keys = Object.keys(p),\n    len = keys.length,\n    i = 0,\n    prop,\n    value;\nwhile (i &lt; len) {\n    prop = keys[i];\n    value = p[prop];\n    i += 1;\n}\n</code></pre>\n\n<p>You can compare performance of this approach with different implementations on <a href=\"http://jsperf.com/\" rel=\"noreferrer\">jsperf.com</a>:</p>\n\n<ul>\n<li><a href=\"http://jsperf.com/extendimplementations/2\" rel=\"noreferrer\">Extend Implementations</a></li>\n<li><a href=\"http://jsperf.com/object-keys-iteration/30\" rel=\"noreferrer\">Object keys iteration</a></li>\n<li><a href=\"http://jsperf.com/object-literal-iteration/5\" rel=\"noreferrer\">object literal iteration</a></li>\n</ul>\n\n<p>Browser support you can see on <a href=\"http://kangax.github.io/es5-compat-table/#Object.keys\" rel=\"noreferrer\">Kangax's compat table</a></p>\n\n<p>For old browser you have <a href=\"http://tokenposts.blogspot.com.au/2012/04/javascript-objectkeys-browser.html\" rel=\"noreferrer\">simple</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" rel=\"noreferrer\">full</a> polyfill</p>\n\n<p><strong>UPD:</strong></p>\n\n<p>performance comparison for all most popular cases in this question on <code>perfjs.info</code>:</p>\n\n<p><a href=\"http://perfjs.info/#!/384A61CA-DA2E-4FD2-A113-080010D4A42B\" rel=\"noreferrer\">object literal iteration</a></p>\n"},{"score":-6,"body":"<p>Besause the asker's ['<em>ultimate goal is to loop through some key value pairs</em>'] and finally don't looking for a loop.</p>\n\n<pre><code>var p ={\"p1\":\"value1\",\"p2\":\"value2\",\"p3\":\"value3\"};\nif('p1' in p){\n  var val=p['p1'];\n  ...\n}\n</code></pre>\n"},{"score":10,"body":"<p>Only JavaScript code without dependencies:</p>\n\n<pre><code>var p = {\"p1\": \"value1\", \"p2\": \"value2\", \"p3\": \"value3\"};\nkeys = Object.keys(p);   // [\"p1\", \"p2\", \"p3\"]\n\nfor(i = 0; i &lt; keys.length; i++){\n  console.log(keys[i] + \"=\" + p[keys[i]]);   // p1=value1, p2=value2, p3=value3\n}\n</code></pre>\n"},{"score":13,"body":"<blockquote>\n  <p>Object.keys(obj) : Array</p>\n  \n  <p>retrieves all string-valued keys of all enumerable own (non-inherited) properties.</p>\n</blockquote>\n\n<p>So it gives the same list of keys as you intend by testing each object key with hasOwnProperty. You don't need that extra test operation than and <code>Object.keys( obj ).forEach(function( key ){})</code> is supposed to be faster. Let's prove it:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var uniqid = function(){\r\n\t\t\tvar text = \"\",\r\n\t\t\t\t\ti = 0,\r\n\t\t\t\t\tpossible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\r\n\t\t\tfor( ; i &lt; 32; i++ ) {\r\n\t\t\t\t\ttext += possible.charAt( Math.floor( Math.random() * possible.length ) );\r\n\t\t\t}\r\n\t\t\treturn text;\r\n\t\t}, \r\n\t\tCYCLES = 100000,\r\n\t\tobj = {}, \r\n\t\tp1,\r\n\t\tp2,\r\n\t\tp3,\r\n\t\tkey;\r\n\r\n// Populate object with random properties\r\nArray.apply( null, Array( CYCLES ) ).forEach(function(){\r\n\tobj[ uniqid() ] = new Date()\r\n});\r\n\r\n// Approach #1\r\np1 = performance.now();\r\nObject.keys( obj ).forEach(function( key ){\r\n\tvar waste = obj[ key ];\r\n});\r\n\r\np2 = performance.now();\r\nconsole.log( \"Object.keys approach took \" + (p2 - p1) + \" milliseconds.\");\r\n\r\n// Approach #2\r\nfor( key in obj ) {\r\n\tif ( obj.hasOwnProperty( key ) ) {\r\n\t\tvar waste = obj[ key ];\r\n\t}\r\n}\r\n\r\np3 = performance.now();\r\nconsole.log( \"for...in/hasOwnProperty approach took \" + (p3 - p2) + \" milliseconds.\");</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>In my Firefox I have following results</p>\n\n<ul>\n<li>Object.keys approach took 40.21101451665163 milliseconds.</li>\n<li>for...in/hasOwnProperty approach took 98.26163508463651 milliseconds.</li>\n</ul>\n\n<p>PS. on Chrome the difference even bigger <a href=\"http://codepen.io/dsheiko/pen/JdrqXa\" rel=\"noreferrer\">http://codepen.io/dsheiko/pen/JdrqXa</a></p>\n\n<p>PS2: In ES6 (EcmaScript 2015) you can iterate iterable object nicer: </p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>let map = new Map().set('a', 1).set('b', 2);\r\nfor (let pair of map) {\r\n    console.log(pair);\r\n}\r\n\r\n// OR \r\nlet map = new Map([\r\n    [false, 'no'],\r\n    [true,  'yes'],\r\n]);\r\nmap.forEach((value, key) =&gt; {\r\n    console.log(key, value);\r\n});</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":5,"body":"<p>I would do this rather than checking <code>obj.hasOwnerProperty</code> within every <code>for ... in</code> loop.</p>\n\n<pre><code>var obj = {a : 1};\nfor(var key in obj){\n    //obj.hasOwnProperty(key) is not needed.\n    console.log(key);\n}\n//then check if anybody has messed the native object. Put this code at the end of the page.\nfor(var key in Object){\n    throw new Error(\"Please don't extend the native object\");\n}\n</code></pre>\n"},{"score":4,"body":"<p>If you want to iterate over <strong><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Enumerable_attribute\" rel=\"nofollow\">non-enumerable properties</a></strong> as well, you can use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\" rel=\"nofollow\"><code>Object.getOwnPropertyNames(obj)</code></a> to return an array of all properties (enumerable or not) found directly upon a given object.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var obj = Object.create({}, {\r\n  // non-enumerable property\r\n  getFoo: {\r\n    value: function() { return this.foo; },\r\n    enumerable: false\r\n  }\r\n});\r\n\r\nobj.foo = 1; // enumerable property\r\n\r\nObject.getOwnPropertyNames(obj).forEach(function (name) {\r\n  document.write(name + ': ' + obj[name] + '&lt;br/&gt;');\r\n});</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":-2,"body":"<p>Since ES2015 you can use the for of loop, to access the element directly:</p>\n\n<pre><code>// before ES2015\nfor(var key of elements){\n  console.log(elements[key]);\n}\n\n\n// ES2015\nfor(let element of elements){\n  console.log(element);\n}\n</code></pre>\n\n<p>Hope this helps someone.</p>\n"},{"score":6,"body":"<p>Loops can be pretty interesting when using pure JavaScript. It seems that only ECMA6 (New 2015 JavaScript specification) got the loops under control. Unfortunately as I'm writing this, both Browsers and popular Integrated development environment (IDE) are still struggling to support completely the new bells and whistles.</p>\n\n<p>At a glance here is what a JavaScript object loop look like before ECMA6:</p>\n\n<pre><code>for (var key in object) {\n  if (p.hasOwnProperty(key)) {\n    var value = object[key];\n    console.log(key); // This is the key;\n    console.log(value); // This is the value;\n  }\n}\n</code></pre>\n\n<p>Also, I know this is out of scope with this question but in 2011, ECMAScript 5.1 added the <code>forEach</code> method for Arrays only which basically created a new improved way to loop through arrays while still leaving non iterable objects with the old verbose and confusing <code>for</code> loop. But the odd part is that this new <code>forEach</code> method does not support <code>break</code> which led to all sorts of other problems.</p>\n\n<p>Basically in 2011, there is not a real solid way to loop in JavaScript other than what many popular libraries (jQuery, Underscore, etc.) decided to re-implement.</p>\n\n<p>As of 2015, we now have a better out of the box way to loop (and break) any object type (including Arrays and Strings). Here is what a loop in JavaScript will eventually look like when the recommendation becomes mainstream:</p>\n\n<pre><code>for (let [key, value] of Object.entries(object)) {\n    console.log(key); // This is the key;\n    console.log(value); // This is the value;\n}\n</code></pre>\n\n<p>Note that most browsers won't support the code above as of June 18th 2016. Even in Chrome you need to enable this special flag for it to work: <code>chrome://flags/#enable-javascript-harmony</code></p>\n\n<p>Until this becomes the new standard, the old method can still be used but there are also alternatives in popular libraries or even <a href=\"https://github.com/nbouvrette/forEach\" rel=\"noreferrer\">lightweight alternatives</a> for those who aren't using any of these libraries.</p>\n"},{"score":18,"body":"<p>It's interesting people in these answers have touched on both <code>Object.keys()</code> and <code>for...of</code> but never combined them:</p>\n\n\n\n<pre><code>var map = {well:'hello', there:'!'};\nfor (let key of Object.keys(map))\n    console.log(key + ':' + map[key]);\n</code></pre>\n\n<p><sub>You can't just <code>for...of</code> an <code>Object</code> because it's not an iterator, and <code>for...index</code> or <code>.forEach()</code>ing the <code>Object.keys()</code> is ugly/inefficient.<br/>\nI'm glad most people are refraining from <code>for...in</code> (with or without checking <code>.hasOwnProperty()</code>) as that's also a bit messy, so other than my answer above, I'm here to say...</sub></p>\n\n<hr>\n\n<p><strong>You can make ordinary object associations iterate! Behaving just like <code>Map</code>s with direct use of the fancy <code>for...of</code></strong><br/>\n<a href=\"http://codepen.io/Hashbrown/pen/mEWadp\" rel=\"noreferrer\">DEMO</a> working in Chrome and FF (I assume ES6 only)</p>\n\n<pre><code>var ordinaryObject = {well:'hello', there:'!'};\nfor (let pair of ordinaryObject)\n    //key:value\n    console.log(pair[0] + ':' + pair[1]);\n\n//or\nfor (let [key, value] of ordinaryObject)\n    console.log(key + ':' + value);\n</code></pre>\n\n<p>So long as you include my shim below:</p>\n\n<pre><code>//makes all objects iterable just like Maps!!! YAY\n//iterates over Object.keys() (which already ignores prototype chain for us)\nObject.prototype[Symbol.iterator] = function() {\n    var keys = Object.keys(this)[Symbol.iterator]();\n    var obj = this;\n    var output;\n    return {next:function() {\n        if (!(output = keys.next()).done)\n            output.value = [output.value, obj[output.value]];\n        return output;\n    }};\n};\n</code></pre>\n\n<p>Without having to create a real Map object that doesn't have the nice syntactic sugar.</p>\n\n<pre><code>var trueMap = new Map([['well', 'hello'], ['there', '!']]);\nfor (let pair of trueMap)\n    console.log(pair[0] + ':' + pair[1]);\n</code></pre>\n\n<p>In fact, with this shim, if you still wanted to take advantage of Map's other functionality (without shimming them all in) but still wanted to use the neat object notation, since objects are now iterable you can now just make a Map from it!</p>\n\n<pre><code>//shown in demo\nvar realMap = new Map({well:'hello', there:'!'});\n</code></pre>\n\n<hr>\n\n<p><strong>For those who don't like to shim, or mess with <code>prototype</code> in general, feel free to make the function on window instead, calling it something like <code>getObjIterator()</code> then;</strong></p>\n\n<pre><code>//no prototype manipulation\nfunction getObjIterator(obj) {\n    //create a dummy object instead of adding functionality to all objects\n    var iterator = new Object();\n\n    //give it what the shim does but as its own local property\n    iterator[Symbol.iterator] = function() {\n        var keys = Object.keys(obj)[Symbol.iterator]();\n        var output;\n\n        return {next:function() {\n            if (!(output = keys.next()).done)\n                output.value = [output.value, obj[output.value]];\n            return output;\n        }};\n    };\n\n    return iterator;\n}\n</code></pre>\n\n<p>Now you can just call it as an ordinary function, nothing else is affected</p>\n\n<pre><code>var realMap = new Map(getObjIterator({well:'hello', there:'!'}))\n</code></pre>\n\n<p>or</p>\n\n<pre><code>for (let pair of getObjIterator(ordinaryObject))\n</code></pre>\n\n<p><a href=\"https://jsfiddle.net/4dkos9mw/16/\" rel=\"noreferrer\">There's no reason why that wouldn't work.</a></p>\n\n<p>Welcome to the future.</p>\n"},{"score":4,"body":"<p>If anybody needs to loop through <strong>arrayObjects with condition</strong>:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var arrayObjects = [{\"building\":\"A\", \"status\":\"good\"},{\"building\":\"B\",\"status\":\"horrible\"}];\r\n\r\nfor (var i=0; i&lt; arrayObjects.length; i++) {\r\n  console.log(arrayObjects[i]);\r\n  \r\n  for(key in arrayObjects[i]) {      \r\n    \r\n      if (key == \"status\" &amp;&amp; arrayObjects[i][key] == \"good\") {\r\n        \r\n          console.log(key + \"-&gt;\" + arrayObjects[i][key]);\r\n      }else{\r\n          console.log(\"nothing found\");\r\n      }\r\n   }\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":28,"body":"<p>Since es2015 is getting more and more popular I am posting this answer which include usage of generator and iterator to smoothly iterate through <code>[key, value]</code> pairs. As it is possible in other languages for instance Ruby.</p>\n\n<p>Ok here is a code:</p>\n\n<pre><code>const MyObject = {\n  'a': 'Hello',\n  'b': 'it\\'s',\n  'c': 'me',\n  'd': 'you',\n  'e': 'looking',\n  'f': 'for',\n  [Symbol.iterator]: function* () {\n    for (const i of Object.keys(this)) {\n      yield [i, this[i]];\n    }\n  }\n};\n\nfor (const [k, v] of MyObject) {\n  console.log(`Here is key ${k} and here is value ${v}`);\n}\n</code></pre>\n\n<p>All information about how can you do an iterator and generator you can find at developer Mozilla page.</p>\n\n<p>Hope It helped someone.</p>\n\n<p><strong>EDIT:</strong></p>\n\n<p>ES2017 will include <code>Object.entries</code> which will make iterating over <code>[key, value]</code> pairs in objects even more easier. It is now known that it will be a part of a standard according to the <a href=\"https://github.com/tc39/proposal-object-values-entries\" rel=\"noreferrer\">ts39</a> stage information.</p>\n\n<p>I think it is time to update my answer to let it became even more fresher than it's now.</p>\n\n<pre><code>const MyObject = {\n  'a': 'Hello',\n  'b': 'it\\'s',\n  'c': 'me',\n  'd': 'you',\n  'e': 'looking',\n  'f': 'for',\n};\n\nfor (const [k, v] of Object.entries(MyObject)) {\n  console.log(`Here is key ${k} and here is value ${v}`);\n}\n</code></pre>\n\n<p>You can find more about usage on\n<a href=\"https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\" rel=\"noreferrer\">MDN</a> page</p>\n"},{"score":4,"body":"<p>Considering ES6 I'd like to add my own spoon of sugar and provide one more approach to iterate over object's properties.</p>\n\n<p>Since plain JS object isn't <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Iteration_protocols\" rel=\"nofollow\">iterable</a> just out of box, we aren't able to use <code>for..of</code> loop for iterating over its content. But no one can stop us <strong>to make it iterable</strong>.</p>\n\n<p>Let's we have <code>book</code> object.</p>\n\n<pre><code>let book = {\n  title: \"Amazing book\",\n  author: \"Me\",\n  pages: 3\n}\n\nbook[Symbol.iterator] = function(){\n\n  let properties = Object.keys(this); // returns an array with property names\n  let counter = 0;\n  let isDone = false;\n\n  let next = () =&gt; {\n    if(counter &gt;= properties.length){\n      isDone = true;\n    }\n    return { done: isDone, value: this[properties[counter++]] }\n  }\n\n  return { next };\n}\n</code></pre>\n\n<p>Since we've made it we can use it this way:</p>\n\n<pre><code>for(let pValue of book){\n  console.log(pValue);\n}\n------------------------\nAmazing book\nMe\n3\n</code></pre>\n\n<p>Or if you know the power of ES6 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*\" rel=\"nofollow\">generators</a>, so you certainly can make the code above much shorter.</p>\n\n<pre><code>book[Symbol.iterator] = function *(){\n\n  let properties = Object.keys(this);\n  for (let p of properties){\n    yield this[p];\n  }\n\n}\n</code></pre>\n\n<p>Sure, you can apply such behavior for all objects with making <code>Object</code> iterable on <code>prototype</code> level.</p>\n\n<pre><code>Object.prototype[Symbol.iterator] = function() {...}\n</code></pre>\n\n<p>Also, objects that comply with the iterable protocol can be used with the new ES2015 feature <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator\" rel=\"nofollow\">spread</a> operator thus we can read object property values as an array.</p>\n\n<pre><code>let pValues = [...book];\nconsole.log(pValues);\n-------------------------\n[\"Amazing book\", \"Me\", 3]\n</code></pre>\n\n<p>Or you can use <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\" rel=\"nofollow\">destructuring</a> assignment:</p>\n\n<pre><code>let [title, , pages] = book; // notice that we can just skip unnecessary values\nconsole.log(title);\nconsole.log(pages);\n------------------\nAmazing book\n3\n</code></pre>\n\n<p>You can check out <a href=\"http://www.es6fiddle.net/isksh68n/\" rel=\"nofollow\"><strong>JSFiddle</strong></a> with all code I've provided above.</p>\n"},{"score":5,"body":"<p>In ES6 we have well-known symbols to expose some previously internal methods, you can use it to define how iterators work for this object:</p>\n\n<pre><code>var p = {\n    \"p1\": \"value1\",\n    \"p2\": \"value2\",\n    \"p3\": \"value3\",\n    *[Symbol.iterator]() {\n        yield *Object.keys(this);\n    }\n};\n\n[...p] //[\"p1\", \"p2\", \"p3\"]\n</code></pre>\n\n<p>this will give the same result as using for...in es6 loop.</p>\n\n<pre><code>for(var key in p) {\n    console.log(key);\n}\n</code></pre>\n\n<p>But its important to know the capabilities you now have using es6!</p>\n"},{"score":7,"body":"<p>You can add a simple <em>forEach</em> function to all objects, so you can automatically loop through any object:</p>\n\n<pre><code>Object.defineProperty(Object.prototype, 'forEach', {\n    value: function (func) {\n        for (var key in this) {\n            if (!this.hasOwnProperty(key)) {\n                // skip loop if the property is from prototype\n                continue;\n            }\n            var value = this[key];\n            func(key, value);\n        }\n    },\n    enumerable: false\n});\n</code></pre>\n\n<p>For those people who don't like the \"<em>for ... in</em>\"-method:</p>\n\n<pre><code>Object.defineProperty(Object.prototype, 'forEach', {\n    value: function (func) {\n        var arr = Object.keys(this);\n        for (var i = 0; i &lt; arr.length; i++) {\n            var key = arr[i];\n            func(key, this[key]);\n        }\n    },\n    enumerable: false\n});\n</code></pre>\n\n<p>Now, you can simple call:</p>\n\n<pre><code>p.forEach (function(key, value){\n    console.log (\"Key: \" + key);\n    console.log (\"Value: \" + value);\n});\n</code></pre>\n\n<p>If you don't want to get conflicts with other forEach-Methods you can name it with your unique name.</p>\n"},{"score":1,"body":"<p>I had a similar problem when using Angular, here is the solution that I've found.</p>\n\n<p><strong>Step 1.</strong> Get all the object keys. using Object.keys. This method returns an array of a given object’s own enumerable properties.</p>\n\n<p><strong>Step 2.</strong> Create an empty array. This is an where all the properties are going to live, since your new ngFor loop is going to point to this array, we gotta catch them all.\n<strong>Step 3.</strong> Iterate throw all keys, and push each one into the array you created.\nHere’s how that looks like in code.</p>\n\n<pre><code>    // Evil response in a variable. Here are all my vehicles.\nlet evilResponse = { \n  \"car\" : \n    { \n       \"color\" : \"red\",\n       \"model\" : \"2013\"\n    },\n   \"motorcycle\": \n    { \n       \"color\" : \"red\",\n       \"model\" : \"2016\"\n    },\n   \"bicycle\": \n    { \n       \"color\" : \"red\",\n       \"model\" : \"2011\"\n    }\n}\n// Step 1. Get all the object keys.\nlet evilResponseProps = Object.keys(evilResponse);\n// Step 2. Create an empty array.\nlet goodResponse = [];\n// Step 3. Iterate throw all keys.\nfor (prop of evilResponseProps) { \n    goodResponse.push(evilResponseProps[prop]);\n}\n</code></pre>\n\n<p>Here is a link to the original post. <a href=\"https://medium.com/@papaponmx/looping-over-object-properties-with-ngfor-in-angular-869cd7b2ddcc\" rel=\"nofollow noreferrer\">https://medium.com/@papaponmx/looping-over-object-properties-with-ngfor-in-angular-869cd7b2ddcc</a></p>\n"},{"score":1,"body":"<p>An object becomes an iterator when it implements the .next() method</p>\n\n<pre><code>const james = {\nname: 'James',\nheight: `5'10\"`,\nweight: 185,\n\n[Symbol.iterator]() {\nlet properties = []\nfor (let key of Object.keys(james)){\n     properties.push(key);\n }\n\nindex = 0;\nreturn {\n        next: () =&gt; {\n            let key = properties[index];\n            let value = this[key];\n            let done = index &gt;= properties.length - 1 ;\n            index++;\n            return { key, value, done };\n        }\n    };\n  }\n\n};\n\n\nconst iterator = james[Symbol.iterator]();\n\nconsole.log(iterator.next().value); // 'James'\nconsole.log(iterator.next().value); // `5'10`\nconsole.log(iterator.next().value); // 185\n</code></pre>\n"},{"score":8,"body":"<p>The <code>Object.keys()</code> method returns an array of a given object's own enumerable properties. Read more about it <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" rel=\"noreferrer\">here</a></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var p = {\r\n    \"p1\": \"value1\",\r\n    \"p2\": \"value2\",\r\n    \"p3\": \"value3\"\r\n};\r\n\r\nObject.keys(p).map((key)=&gt; console.log(key + \"-&gt;\" + p[key]))</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":10,"body":"<p>Here is another method to iterate through an object.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>   var p = {\r\n\"p1\": \"value1\",\r\n\"p2\": \"value2\",\r\n\"p3\": \"value3\"\r\n};\r\n\r\n\r\nObject.keys(p).forEach(key =&gt; { console.log(key, p[key]) })</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":0,"body":"<p>If you want to iterate only over properties use one of the answers above, however if you want to iterate over everything including functions, then you might want to use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\" rel=\"nofollow noreferrer\">Object.getOwnPropertyNames(obj)</a></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>for (let o of Object.getOwnPropertyNames(Math)) {\r\n  console.log(o);\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>I sometimes use this to fast test all functions on objects with simple inputs and outputs.</p>\n"},{"score":-1,"body":"<ul>\n<li>single level indent</li>\n<li>single set of brackets</li>\n<li>highest browser compatibility</li>\n<li>hasOwnProperty safe</li>\n</ul>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var p = {\"p1\": \"value1\", \"p2\": \"value2\", \"p3\": \"value3\"};\r\n\r\nfor (var key in p) if (p.hasOwnProperty(key)) {\r\n  var value = p[key];\r\n  console.log(key, value);\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":5,"body":"<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>    var p =[{\"username\":\"ordermanageadmin\",\"user_id\":\"2\",\"resource_id\":\"Magento_Sales::actions\"},\r\n{\"username\":\"ordermanageadmin_1\",\"user_id\":\"3\",\"resource_id\":\"Magento_Sales::actions\"}]\r\nfor(var value in p) {\r\n    for (var key in value) {\r\n        if (p.hasOwnProperty(key)) {\r\n            console.log(key + \" -&gt; \" + p[key]);\r\n        }\r\n    }\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":4,"body":"<p>since ES06 you can get the values of an object as array with</p>\n\n<pre><code>let arrValues = Object.values( yourObject) ;\n</code></pre>\n\n<p>it return the an array of the object values and it not extract values from Prototype!!</p>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values\" rel=\"noreferrer\">MDN DOCS Object.values()</a></p>\n\n<p>and for keys ( allready answerd before me here ) </p>\n\n<pre><code>let arrKeys   = Object.keys(yourObject);\n</code></pre>\n"},{"score":54,"body":"<p>Preface:</p>\n\n<ul>\n<li>Object properties can be <em>own</em> (the property is on the object itself) or <em>inherited</em> (not on the object itself, on one of its prototypes).</li>\n<li>Object properties can be <em>enumerable</em> or <em>non-enumerable</em>. Non-enumerable properties are left out of lots of property enumerations/arrays.</li>\n<li>Property names can be strings or Symbols. Properties whose names are Symbols are left out of lots of property enumerations/arrays.</li>\n</ul>\n\n<p>Here in 2018, your options for looping through an object's properties are (some examples follow the list):</p>\n\n<ol>\n<li><strong><code>for-in</code></strong> [<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for...in\" rel=\"noreferrer\">MDN</a>, <a href=\"https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements\" rel=\"noreferrer\">spec</a>] &mdash; A loop structure that loops through the names of an object's <em>enumerable</em> properties, including inherited ones, whose names are strings</li>\n<li><strong><code>Object.keys</code></strong> [<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\" rel=\"noreferrer\">MDN</a>, <a href=\"https://tc39.github.io/ecma262/#sec-object.keys\" rel=\"noreferrer\">spec</a>] &mdash; A function providing an array of the names of an object's <em>own</em>, <em>enumerable</em> properties whose names are strings.</li>\n<li><strong><code>Object.values</code></strong> [<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/values\" rel=\"noreferrer\">MDN</a>, <a href=\"https://tc39.github.io/ecma262/#sec-object.values\" rel=\"noreferrer\">spec</a>] &mdash; A function providing an array of the <em>values</em> of an object's <em>own</em>, <em>enumerable</em> properties.</li>\n<li><strong><code>Object.entries</code></strong> [<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\" rel=\"noreferrer\">MDN</a>, <a href=\"https://tc39.github.io/ecma262/#sec-object.entries\" rel=\"noreferrer\">spec</a>] &mdash; A function providing an array of the names <em>and</em> values of an object's <em>own</em>, <em>enumerable</em> properties (each entry in the array is a <code>[name, value]</code> array).</li>\n<li><strong><code>Object.getOwnPropertyNames</code></strong> [<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\" rel=\"noreferrer\">MDN</a>, <a href=\"https://tc39.github.io/ecma262/#sec-object.getownpropertynames\" rel=\"noreferrer\">spec</a>] &mdash; A function providing an array of the names of an object's <em>own</em> properties (even non-enumerable ones) whose names are strings.</li>\n<li><strong><code>Object.getOwnPropertySymbols</code></strong> [<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\" rel=\"noreferrer\">MDN</a>, <a href=\"https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols\" rel=\"noreferrer\">spec</a>] &mdash; A function providing an array of the names of an object's <em>own</em> properties (even non-enumerable ones) whose names are Symbols.</li>\n<li><strong><code>Reflect.ownKeys</code></strong> [<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys\" rel=\"noreferrer\">MDN</a>, <a href=\"https://tc39.github.io/ecma262/#sec-reflect.ownkeys\" rel=\"noreferrer\">spec</a>] &mdash; A function providing an array of the names of an object's <em>own</em> properties (even non-enumerable ones), whether those names are strings or Symbols.</li>\n<li>If you want <strong>all</strong> of an object's properties, including non-enumerable inherited ones, you need to use a loop and <code>Object.getPrototypeOf</code> [<a href=\"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\" rel=\"noreferrer\">MDN</a>, <a href=\"https://tc39.github.io/ecma262/#sec-object.getprototypeof\" rel=\"noreferrer\">spec</a>] and use <code>Object.getOwnPropertyNames</code>, <code>Object.getOwnPropertySymbols</code>, or <code>Reflect.ownKeys</code> on each object in the prototype chain (example at the bottom of this answer).</li>\n</ol>\n\n<p>With all of them except <code>for-in</code>, you'd use some kind of looping construct on the array (<code>for</code>, <code>for-of</code>, <code>forEach</code>, etc.).</p>\n\n<p>Examples:</p>\n\n<p><strong><code>for-in</code>:</strong></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// A prototype object to inherit from, with a string-named property\r\nconst p = {answer: 42};\r\n// The object we'll look at, which inherits from `p`\r\nconst o = Object.create(p);\r\n// A string-named property\r\no.question = \"Life, the Universe, and Everything\";\r\n// A symbol-named property\r\no[Symbol(\"author\")] = \"Douglas Adams\";\r\nfor (const name in o) {\r\n    const value = o[name];\r\n    console.log(`${name} = ${value}`);\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong><code>Object.keys</code></strong> <em>(with a <code>for-of</code> loop, but you can use any looping construct)</em>:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// A prototype object to inherit from, with a string-named property\r\nconst p = {answer: 42};\r\n// The object we'll look at, which inherits from `p`\r\nconst o = Object.create(p);\r\n// A string-named property\r\no.question = \"Life, the Universe, and Everything\";\r\n// A symbol-named property\r\no[Symbol(\"author\")] = \"Douglas Adams\";\r\nfor (const name of Object.keys(o)) {\r\n    const value = o[name];\r\n    console.log(`${name} = ${value}`);\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong><code>Object.values</code>:</strong></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// A prototype object to inherit from, with a string-named property\r\nconst p = {answer: 42};\r\n// The object we'll look at, which inherits from `p`\r\nconst o = Object.create(p);\r\n// A string-named property\r\no.question = \"Life, the Universe, and Everything\";\r\n// A symbol-named property\r\no[Symbol(\"author\")] = \"Douglas Adams\";\r\nfor (const value of Object.values(o)) {\r\n    console.log(`${value}`);\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong><code>Object.entries</code>:</strong></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// A prototype object to inherit from, with a string-named property\r\nconst p = {answer: 42};\r\n// The object we'll look at, which inherits from `p`\r\nconst o = Object.create(p);\r\n// A string-named property\r\no.question = \"Life, the Universe, and Everything\";\r\n// A symbol-named property\r\no[Symbol(\"author\")] = \"Douglas Adams\";\r\nfor (const [name, value] of Object.entries(o)) {\r\n    console.log(`${name} = ${value}`);\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong><code>Object.getOwnPropertyNames</code>:</strong></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// A prototype object to inherit from, with a string-named property\r\nconst p = {answer: 42};\r\n// The object we'll look at, which inherits from `p`\r\nconst o = Object.create(p);\r\n// A string-named property\r\no.question = \"Life, the Universe, and Everything\";\r\n// A symbol-named property\r\no[Symbol(\"author\")] = \"Douglas Adams\";\r\nfor (const name of Object.getOwnPropertyNames(o)) {\r\n    const value = o[name];\r\n    console.log(`${name} = ${value}`);\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong><code>Object.getOwnPropertySymbols</code>:</strong></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// A prototype object to inherit from, with a string-named property\r\nconst p = {answer: 42};\r\n// The object we'll look at, which inherits from `p`\r\nconst o = Object.create(p);\r\n// A string-named property\r\no.question = \"Life, the Universe, and Everything\";\r\n// A symbol-named property\r\no[Symbol(\"author\")] = \"Douglas Adams\";\r\nfor (const name of Object.getOwnPropertySymbols(o)) {\r\n    const value = o[name];\r\n    console.log(`${String(name)} = ${value}`);\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong><code>Reflect.ownKeys</code>:</strong></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// A prototype object to inherit from, with a string-named property\r\nconst p = {answer: 42};\r\n// The object we'll look at, which inherits from `p`\r\nconst o = Object.create(p);\r\n// A string-named property\r\no.question = \"Life, the Universe, and Everything\";\r\n// A symbol-named property\r\no[Symbol(\"author\")] = \"Douglas Adams\";\r\nfor (const name of Reflect.ownKeys(o)) {\r\n    const value = o[name];\r\n    console.log(`${String(name)} = ${value}`);\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><strong>All properties</strong>, including inherited non-enumerable ones:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>// A prototype object to inherit from, with a string-named property\r\nconst p = {answer: 42};\r\n// The object we'll look at, which inherits from `p`\r\nconst o = Object.create(p);\r\n// A string-named property\r\no.question = \"Life, the Universe, and Everything\";\r\n// A symbol-named property\r\no[Symbol(\"author\")] = \"Douglas Adams\";\r\nfor (let depth = 0, current = o; current; ++depth, current = Object.getPrototypeOf(current)) {\r\n    for (const name of Reflect.ownKeys(current)) {\r\n        const value = o[name];\r\n        console.log(`[${depth}] ${String(name)} = ${String(value)}`);\r\n    }\r\n}</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>.as-console-wrapper {\r\n  max-height: 100% !important;\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":9,"body":"<p>In latest ES script, you can do something like this:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>let p = {foo: \"bar\"};\r\nfor (let [key, value] of Object.entries(p)) {\r\n  console.log(key, value);\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":3,"body":"<p><code>Object.entries()</code> function:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var p = {\r\n\t    \"p1\": \"value1\",\r\n\t    \"p2\": \"value2\",\r\n\t    \"p3\": \"value3\"\r\n\t};\r\n\r\nfor (var i in Object.entries(p)){\r\n\tvar key = Object.entries(p)[i][0];\r\n\tvar value = Object.entries(p)[i][1];\r\n\tconsole.log('key['+i+']='+key+' '+'value['+i+']='+value);\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":1,"body":"<p>This is how to loop through a javascript object and put the data into a table.\n<div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;body&gt;\r\n&lt;script&gt;\r\nfunction createTable(objectArray, fields, fieldTitles) {\r\n  let body = document.getElementsByTagName('body')[0];\r\n  let tbl = document.createElement('table');\r\n  let thead = document.createElement('thead');\r\n  let thr = document.createElement('tr');\r\n\r\n  for (p in objectArray[0]){\r\n    let th = document.createElement('th');\r\n    th.appendChild(document.createTextNode(p));\r\n    thr.appendChild(th);\r\n    \r\n  }\r\n \r\n  thead.appendChild(thr);\r\n  tbl.appendChild(thead);\r\n\r\n  let tbdy = document.createElement('tbody');\r\n  let tr = document.createElement('tr');\r\n  objectArray.forEach((object) =&gt; {\r\n    let n = 0;\r\n    let tr = document.createElement('tr');\r\n    for (p in objectArray[0]){\r\n      var td = document.createElement('td');\r\n      td.appendChild(document.createTextNode(object[p]));\r\n      tr.appendChild(td);\r\n      n++;\r\n    };\r\n    tbdy.appendChild(tr);    \r\n  });\r\n  tbl.appendChild(tbdy);\r\n  body.appendChild(tbl)\r\n  return tbl;\r\n}\r\n\r\ncreateTable([\r\n              {name: 'Banana', price: '3.04'}, // k[0]\r\n              {name: 'Orange', price: '2.56'},  // k[1]\r\n              {name: 'Apple', price: '1.45'}\r\n           ])\r\n&lt;/script&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":-1,"body":"<p>If your application is in string creation, a nice combination is with Object.keys, implode and the .map array method. For example, if we have a json object like </p>\n\n<pre><code>var data = {\n    key1: 10,\n    key2: 'someString',\n    key3: 3000\n}\n</code></pre>\n\n<p>.. and we'd like to generate \n\"The values are key1 = 10, key2 = someString, key3 = 3000.\"</p>\n\n<p>We can accomplish this in the single line of code:</p>\n\n<pre><code>var str = `The values are ${implode(', ', Object.keys(data).map(function(key){return `${key} = ${data[key]}`}))}.`;\n</code></pre>\n\n<p>Implode collapses an array to a string with a delimiter (first argument) inserted between elements; .map iterates through an array returning an array, and Object.keys has been elaborated quite well by the other answers.</p>\n"},{"score":14,"body":"<p>You can also use Object.keys() and iterate over the object keys like below to get the value:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var p = {\r\n    \"p1\": \"value1\",\r\n    \"p2\": \"value2\",\r\n    \"p3\": \"value3\"\r\n};\r\n\r\nObject.keys(p).forEach((key)=&gt; {\r\n console.log(key +' -&gt; '+ p[key]);\r\n});</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":6,"body":"<p><strong>Using a <code>for-of</code> on <code>Object.keys()</code></strong></p>\n\n<p>Like:</p>\n\n<pre><code>let object = {\n   \"key1\": \"value1\"\n   \"key2\": \"value2\"\n   \"key3\": \"value3\"\n};\n\nfor (var key of Object.keys(p)) {\n   console.log(key + \" : \" + object[key])\n}\n</code></pre>\n"},{"score":4,"body":"<p>Multiple way to iterate object in javascript</p>\n\n<p>Using <strong>for...in</strong> loop</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code> var p = {\r\n    \"p1\": \"value1\",\r\n    \"p2\": \"value2\",\r\n    \"p3\": \"value3\"\r\n};\r\nfor (let key in p){\r\n   if(p.hasOwnProperty(key)){\r\n     console.log(`${key} : ${p[key]}`)\r\n   }\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Using <strong>for...of</strong> loop</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code> var p = {\r\n    \"p1\": \"value1\",\r\n    \"p2\": \"value2\",\r\n    \"p3\": \"value3\"\r\n};\r\nfor (let key of Object.keys(p)){\r\n     console.log(`key: ${key} &amp; value: ${p[key]}`)\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\" rel=\"nofollow noreferrer\">forEach()</a> with <strong>Object.keys</strong>, <strong>Object.values</strong>, <strong>Object.entries</strong></p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var p = {\r\n    \"p1\": \"value1\",\r\n    \"p2\": \"value2\",\r\n    \"p3\": \"value3\"\r\n};\r\nObject.keys(p).forEach(key=&gt;{\r\n   console.log(`${key} : ${p[key]}`);\r\n});\r\nObject.values(p).forEach(value=&gt;{\r\n   console.log(value);\r\n});\r\nObject.entries(p).forEach(([key,value])=&gt;{\r\n    console.log(`${key}:${value}`)\r\n})</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":4,"body":"<p>A good way for looping on an enumerable JavaScript object which could be awesome and common for ReactJS is using <code>Object.keys</code> or <code>Object.entries</code> with using <code>map</code> function. like below:</p>\n\n<pre><code>// assume items:\n\nconst items = {\n  first: { name: 'phone', price: 400 },\n  second: { name: 'tv', price: 300 },\n  third: { name: 'sofa', price: 250 },\n};\n</code></pre>\n\n<p>For looping and show some UI on <code>ReactJS</code> act like below:</p>\n\n<pre><code>~~~\n&lt;div&gt;\n  {Object.entries(items).map(([key, ({ name, price })]) =&gt; (\n    &lt;div key={key}&gt;\n     &lt;span&gt;name: {name}&lt;/span&gt;\n     &lt;span&gt;price: {price}&lt;/span&gt;\n    &lt;/div&gt;\n  ))}\n&lt;/div&gt;\n</code></pre>\n\n<p>Actually, I use the destructuring assignment twice, once for getting <code>key</code> once for getting <code>name</code> and <code>price</code>.</p>\n"},{"score":17,"body":"<h2>Performance</h2>\n\n<p>Today 2020.03.06 I perform tests of chosen solutions on Chrome v80.0, Safari v13.0.5 and Firefox 73.0.1 on MacOs High Sierra v10.13.6</p>\n\n<h3>Conclusions</h3>\n\n<ul>\n<li>solutions based on <code>for-in</code> (A,B) are fast (or fastest) for all browsers for big and small objects</li>\n<li>surprisingly <code>for-of</code> (H) solution is fast on chrome for small and big objects</li>\n<li>solutions based on explicit index <code>i</code> (J,K) are quite fast on all browsers for small objects (for firefox also fast for big ojbects but medium fast on other browsers)</li>\n<li>solutions based on iterators (D,E) are slowest and not recommended</li>\n<li>solution C is slow for big objects and medium-slow for small objects</li>\n</ul>\n\n<p><a href=\"https://i.stack.imgur.com/M6NzO.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/M6NzO.png\" alt=\"enter image description here\"></a></p>\n\n<h3>Details</h3>\n\n<p>Performance tests was performed for </p>\n\n<ul>\n<li>small object - with 3 fields - you can perform test on your machine <a href=\"https://jsbench.me/wok7em87k8/1\" rel=\"noreferrer\">HERE</a></li>\n<li>'big' object - with 1000 fields - you can perform test on your machine <a href=\"https://jsbench.me/0pk7emfoy9/1\" rel=\"noreferrer\">HERE</a></li>\n</ul>\n\n<p>Below snippets presents used solutions</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function A(obj,s='') {\r\n\tfor (let key in obj) if (obj.hasOwnProperty(key)) s+=key+'-&gt;'+obj[key] + ' ';\r\n  return s;\r\n}\r\n\r\nfunction B(obj,s='') {\r\n\tfor (let key in obj) s+=key+'-&gt;'+obj[key] + ' ';\r\n  return s;\r\n}\r\n\r\nfunction C(obj,s='') {\r\n  const map = new Map(Object.entries(obj));\r\n\tfor (let [key,value] of map) s+=key+'-&gt;'+value + ' ';\r\n  return s;\r\n}\r\n\r\nfunction D(obj,s='') {\r\n  let o = { \r\n    ...obj,\r\n    *[Symbol.iterator]() {\r\n      for (const i of Object.keys(this)) yield [i, this[i]];    \r\n    }\r\n  }\r\n  for (let [key,value] of o) s+=key+'-&gt;'+value + ' ';\r\n  return s;\r\n}\r\n\r\nfunction E(obj,s='') {\r\n  let o = { \r\n    ...obj,\r\n    *[Symbol.iterator]() {yield *Object.keys(this)}\r\n  }\r\n  for (let key of o) s+=key+'-&gt;'+o[key] + ' ';\r\n  return s;\r\n}\r\n\r\nfunction F(obj,s='') {\r\n\tfor (let key of Object.keys(obj)) s+=key+'-&gt;'+obj[key]+' ';\r\n  return s;\r\n}\r\n\r\nfunction G(obj,s='') {\r\n\tfor (let [key, value] of Object.entries(obj)) s+=key+'-&gt;'+value+' ';\r\n  return s;\r\n}\r\n\r\nfunction H(obj,s='') {\r\n\tfor (let key of Object.getOwnPropertyNames(obj)) s+=key+'-&gt;'+obj[key]+' ';\r\n  return s;\r\n}\r\n\r\nfunction I(obj,s='') {\r\n\tfor (const key of Reflect.ownKeys(obj)) s+=key+'-&gt;'+obj[key]+' ';\r\n  return s;\r\n}\r\n\r\nfunction J(obj,s='') {\r\n  let keys = Object.keys(obj);\r\n\tfor(let i = 0; i &lt; keys.length; i++){\r\n    let key = keys[i];\r\n    s+=key+'-&gt;'+obj[key]+' ';\r\n  }\r\n  return s;\r\n}\r\n\r\nfunction K(obj,s='') {\r\n  var keys = Object.keys(obj), len = keys.length, i = 0;\r\n  while (i &lt; len) {\r\n    let key = keys[i];\r\n    s+=key+'-&gt;'+obj[key]+' ';\r\n    i += 1;\r\n  }\r\n  return s;\r\n}\r\n\r\nfunction L(obj,s='') {\r\n  Object.keys(obj).forEach(key=&gt; s+=key+'-&gt;'+obj[key]+' ' );\r\n  return s;\r\n}\r\n\r\nfunction M(obj,s='') {\r\n  Object.entries(obj).forEach(([key, value]) =&gt; s+=key+'-&gt;'+value+' ');\r\n  return s;\r\n}\r\n\r\nfunction N(obj,s='') {\r\n  Object.getOwnPropertyNames(obj).forEach(key =&gt; s+=key+'-&gt;'+obj[key]+' ');\r\n  return s;\r\n}\r\n\r\nfunction O(obj,s='') {\r\n  Reflect.ownKeys(obj).forEach(key=&gt; s+=key+'-&gt;'+obj[key]+' ' );\r\n  return s;\r\n}\r\n\r\n\r\n\r\n// TEST\r\n\r\nvar p = {\r\n    \"p1\": \"value1\",\r\n    \"p2\": \"value2\",\r\n    \"p3\": \"value3\"\r\n};\r\nlet log = (name,f) =&gt; console.log(`${name} ${f(p)}`)\r\n\r\nlog('A',A);\r\nlog('B',B);\r\nlog('C',C);\r\nlog('D',D);\r\nlog('E',E);\r\nlog('F',F);\r\nlog('G',G);\r\nlog('H',H);\r\nlog('I',I);\r\nlog('J',J);\r\nlog('K',K);\r\nlog('L',L);\r\nlog('M',M);\r\nlog('N',N);\r\nlog('O',O);</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>This snippet only presents choosen solutions</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>And here are result for small objects on chrome</p>\n\n<p><a href=\"https://i.stack.imgur.com/z8KJL.png\" rel=\"noreferrer\"><img src=\"https://i.stack.imgur.com/z8KJL.png\" alt=\"enter image description here\"></a></p>\n"}],"score":3035}