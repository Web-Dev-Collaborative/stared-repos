{"body":"<p>I need to be able to merge two (very simple) JavaScript objects at runtime.  For example I'd like to:</p>\n\n<pre><code>var obj1 = { food: 'pizza', car: 'ford' }\nvar obj2 = { animal: 'dog' }\n\nobj1.merge(obj2);\n\n//obj1 now has three properties: food, car, and animal\n</code></pre>\n\n<p>Does anyone have a script for this or know of a built in way to do this?  I do not need recursion, and I do not need to merge functions, just methods on flat objects.</p>\n","title":"How can I merge properties of two JavaScript objects dynamically?","answers":[{"score":3114,"body":"<p><strong>ECMAScript 2018 Standard Method</strong></p>\n\n<p>You would use <a href=\"https://github.com/tc39/proposal-object-rest-spread\" rel=\"noreferrer\">object spread</a>:</p>\n\n<pre><code>let merged = {...obj1, ...obj2};\n</code></pre>\n\n<p><code>merged</code> is now the union of <code>obj1</code> and <code>obj2</code>. Properties in <code>obj2</code> will overwrite those in <code>obj1</code>.</p>\n\n<pre><code>/** There's no limit to the number of objects you can merge.\n *  Later properties overwrite earlier properties with the same name. */\nconst allRules = {...obj1, ...obj2, ...obj3};\n</code></pre>\n\n<p>Here is also the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\" rel=\"noreferrer\">MDN documentation</a> for this syntax. If you're using babel you'll need the <a href=\"https://babeljs.io/docs/en/babel-plugin-transform-object-rest-spread.html\" rel=\"noreferrer\">babel-plugin-transform-object-rest-spread</a> plugin for it to work.</p>\n\n<p><strong>ECMAScript 2015 (ES6) Standard Method</strong></p>\n\n<pre><code>/* For the case in question, you would do: */\nObject.assign(obj1, obj2);\n\n/** There's no limit to the number of objects you can merge.\n *  All objects get merged into the first object. \n *  Only the object in the first argument is mutated and returned.\n *  Later properties overwrite earlier properties with the same name. */\nconst allRules = Object.assign({}, obj1, obj2, obj3, etc);\n</code></pre>\n\n<p>(see <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Browser_compatibility\" rel=\"noreferrer\">MDN JavaScript Reference</a>)</p>\n\n<hr>\n\n<p><strong>Method for ES5 and Earlier</strong></p>\n\n<pre><code>for (var attrname in obj2) { obj1[attrname] = obj2[attrname]; }\n</code></pre>\n\n<p>Note that this will simply add all attributes of <code>obj2</code> to <code>obj1</code> which might not be what you want if you still want to use the unmodified <code>obj1</code>.</p>\n\n<p>If you're using a framework that craps all over your prototypes then you have to get fancier with checks like <code>hasOwnProperty</code>, but that code will work for 99% of cases.</p>\n\n<p>Example function:</p>\n\n<pre><code>/**\n * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\n * @param obj1\n * @param obj2\n * @returns obj3 a new object based on obj1 and obj2\n */\nfunction merge_options(obj1,obj2){\n    var obj3 = {};\n    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }\n    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }\n    return obj3;\n}\n</code></pre>\n"},{"score":13,"body":"<p><a href=\"http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework\" rel=\"noreferrer\">Prototype</a> has this:</p>\n\n<pre><code>Object.extend = function(destination,source) {\n    for (var property in source)\n        destination[property] = source[property];\n    return destination;\n}\n</code></pre>\n\n<p><code>obj1.extend(obj2)</code> will do what you want.</p>\n"},{"score":1202,"body":"<p>jQuery also has a utility for this: <a href=\"http://api.jquery.com/jQuery.extend/\" rel=\"noreferrer\">http://api.jquery.com/jQuery.extend/</a>.</p>\n\n<p>Taken from the jQuery documentation:</p>\n\n<pre><code>// Merge options object into settings object\nvar settings = { validate: false, limit: 5, name: \"foo\" };\nvar options  = { validate: true, name: \"bar\" };\njQuery.extend(settings, options);\n\n// Now the content of settings object is the following:\n// { validate: true, limit: 5, name: \"bar\" }\n</code></pre>\n\n<p>The above code will mutate the <strong>existing object</strong> named <em><code>settings</code></em>.</p>\n\n<hr>\n\n<p>If you want to create a <strong>new object</strong> without modifying either argument, use this:</p>\n\n<pre><code>var defaults = { validate: false, limit: 5, name: \"foo\" };\nvar options = { validate: true, name: \"bar\" };\n\n/* Merge defaults and options, without modifying defaults */\nvar settings = $.extend({}, defaults, options);\n\n// The content of settings variable is now the following:\n// {validate: true, limit: 5, name: \"bar\"}\n// The 'defaults' and 'options' variables remained the same.\n</code></pre>\n"},{"score":271,"body":"<p>I googled for code to merge object properties and ended up here. However since there wasn't any code for recursive merge I wrote it myself. (Maybe jQuery extend is recursive BTW?) Anyhow, hopefully someone else will find it useful as well.</p>\n\n<p>(Now the code does not use <code>Object.prototype</code> :)</p>\n\n<h2>Code</h2>\n\n<pre><code>/*\n* Recursively merge properties of two objects \n*/\nfunction MergeRecursive(obj1, obj2) {\n\n  for (var p in obj2) {\n    try {\n      // Property in destination object set; update its value.\n      if ( obj2[p].constructor==Object ) {\n        obj1[p] = MergeRecursive(obj1[p], obj2[p]);\n\n      } else {\n        obj1[p] = obj2[p];\n\n      }\n\n    } catch(e) {\n      // Property in destination object not set; create it and set its value.\n      obj1[p] = obj2[p];\n\n    }\n  }\n\n  return obj1;\n}\n</code></pre>\n\n<h2>An example</h2>\n\n<pre><code>o1 = {  a : 1,\n        b : 2,\n        c : {\n          ca : 1,\n          cb : 2,\n          cc : {\n            cca : 100,\n            ccb : 200 } } };\n\no2 = {  a : 10,\n        c : {\n          ca : 10,\n          cb : 20, \n          cc : {\n            cca : 101,\n            ccb : 202 } } };\n\no3 = MergeRecursive(o1, o2);\n</code></pre>\n\n<p><strong>Produces object o3 like</strong></p>\n\n<pre><code>o3 = {  a : 10,\n        b : 2,\n        c : {\n          ca : 10,\n          cb : 20,\n          cc : { \n            cca : 101,\n            ccb : 202 } } };\n</code></pre>\n"},{"score":41,"body":"<p>The given solutions should be modified to check <code>source.hasOwnProperty(property)</code> in the <code>for..in</code> loops before assigning - otherwise, you end up copying the properties of the whole prototype chain, which is rarely desired...</p>\n"},{"score":1,"body":"<p>The correct implementation in <a href=\"http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework\" rel=\"nofollow noreferrer\">Prototype</a> should look like this:</p>\n\n<pre><code>var obj1 = {food: 'pizza', car: 'ford'}\nvar obj2 = {animal: 'dog'}\n\nobj1 = Object.extend(obj1, obj2);\n</code></pre>\n"},{"score":10,"body":"<p>In <a href=\"http://en.wikipedia.org/wiki/MooTools\" rel=\"nofollow noreferrer\">MooTools</a>, there's <a href=\"http://mootools.net/docs/core/Types/Object#Object:Object-merge\" rel=\"nofollow noreferrer\">Object.merge()</a>:</p>\n\n<pre><code>Object.merge(obj1, obj2);\n</code></pre>\n"},{"score":19,"body":"<p>For not-too-complicated objects you could use <a href=\"http://en.wikipedia.org/wiki/JSON\" rel=\"noreferrer\">JSON</a>:</p>\n\n<pre><code>var obj1 = { food: 'pizza', car: 'ford' }\nvar obj2 = { animal: 'dog', car: 'chevy'}\nvar objMerge;\n\nobjMerge = JSON.stringify(obj1) + JSON.stringify(obj2);\n\n// {\"food\": \"pizza\",\"car\":\"ford\"}{\"animal\":\"dog\",\"car\":\"chevy\"}\n\nobjMerge = objMerge.replace(/\\}\\{/, \",\"); //  \\_ replace with comma for valid JSON\n\nobjMerge = JSON.parse(objMerge); // { food: 'pizza', animal: 'dog', car: 'chevy'}\n// Of same keys in both objects, the last object's value is retained_/\n</code></pre>\n\n<p>Mind you that in this example \"}{\" <strong><em>must not occur</em></strong> within a string!</p>\n"},{"score":17,"body":"<p>The best way for you to do this is to add a proper property that is non-enumerable using Object.defineProperty. </p>\n\n<p>This way you will still be able to iterate over your objects properties without having the newly created \"extend\" that you would get if you were to create the property with Object.prototype.extend.</p>\n\n<p>Hopefully this helps:</p>\n\n<pre>\nObject.defineProperty(Object.prototype, \"extend\", {\n    enumerable: false,\n    value: function(from) {\n        var props = Object.getOwnPropertyNames(from);\n        var dest = this;\n        props.forEach(function(name) {\n            if (name in dest) {\n                var destination = Object.getOwnPropertyDescriptor(from, name);\n                Object.defineProperty(dest, name, destination);\n            }\n        });\n        return this;\n    }\n});\n</pre>\n\n<p>Once you have that working, you can do:</p>\n\n<pre>\nvar obj = {\n    name: 'stack',\n    finish: 'overflow'\n}\nvar replacement = {\n    name: 'stock'\n};\n\nobj.extend(replacement);\n</pre>\n\n<p>I just wrote a blog post about it here: <a href=\"http://onemoredigit.com/post/1527191998/extending-objects-in-node-js\" rel=\"noreferrer\">http://onemoredigit.com/post/1527191998/extending-objects-in-node-js</a></p>\n"},{"score":10,"body":"<p>I extended David Coallier's method:</p>\n\n<ul>\n<li>Added the possibility to merge multiple objects</li>\n<li>Supports deep objects</li>\n<li>override parameter (that's detected if the last parameter is a boolean)</li>\n</ul>\n\n<p>If override is false, no property gets overridden but new properties will be added.</p>\n\n<p>Usage:\nobj.merge(merges... [, override]);</p>\n\n<p>Here is my code:</p>\n\n<pre><code>Object.defineProperty(Object.prototype, \"merge\", {\n    enumerable: false,\n    value: function () {\n        var override = true,\n            dest = this,\n            len = arguments.length,\n            props, merge, i, from;\n\n        if (typeof(arguments[arguments.length - 1]) === \"boolean\") {\n            override = arguments[arguments.length - 1];\n            len = arguments.length - 1;\n        }\n\n        for (i = 0; i &lt; len; i++) {\n            from = arguments[i];\n            if (from != null) {\n                Object.getOwnPropertyNames(from).forEach(function (name) {\n                    var descriptor;\n\n                    // nesting\n                    if ((typeof(dest[name]) === \"object\" || typeof(dest[name]) === \"undefined\")\n                            &amp;&amp; typeof(from[name]) === \"object\") {\n\n                        // ensure proper types (Array rsp Object)\n                        if (typeof(dest[name]) === \"undefined\") {\n                            dest[name] = Array.isArray(from[name]) ? [] : {};\n                        }\n                        if (override) {\n                            if (!Array.isArray(dest[name]) &amp;&amp; Array.isArray(from[name])) {\n                                dest[name] = [];\n                            }\n                            else if (Array.isArray(dest[name]) &amp;&amp; !Array.isArray(from[name])) {\n                                dest[name] = {};\n                            }\n                        }\n                        dest[name].merge(from[name], override);\n                    } \n\n                    // flat properties\n                    else if ((name in dest &amp;&amp; override) || !(name in dest)) {\n                        descriptor = Object.getOwnPropertyDescriptor(from, name);\n                        if (descriptor.configurable) {\n                            Object.defineProperty(dest, name, descriptor);\n                        }\n                    }\n                });\n            }\n        }\n        return this;\n    }\n});\n</code></pre>\n\n<p>Examples and TestCases:</p>\n\n<pre><code>function clone (obj) {\n    return JSON.parse(JSON.stringify(obj));\n}\nvar obj = {\n    name : \"trick\",\n    value : \"value\"\n};\n\nvar mergeObj = {\n    name : \"truck\",\n    value2 : \"value2\"\n};\n\nvar mergeObj2 = {\n    name : \"track\",\n    value : \"mergeObj2\",\n    value2 : \"value2-mergeObj2\",\n    value3 : \"value3\"\n};\n\nassertTrue(\"Standard\", clone(obj).merge(mergeObj).equals({\n    name : \"truck\",\n    value : \"value\",\n    value2 : \"value2\"\n}));\n\nassertTrue(\"Standard no Override\", clone(obj).merge(mergeObj, false).equals({\n    name : \"trick\",\n    value : \"value\",\n    value2 : \"value2\"\n}));\n\nassertTrue(\"Multiple\", clone(obj).merge(mergeObj, mergeObj2).equals({\n    name : \"track\",\n    value : \"mergeObj2\",\n    value2 : \"value2-mergeObj2\",\n    value3 : \"value3\"\n}));\n\nassertTrue(\"Multiple no Override\", clone(obj).merge(mergeObj, mergeObj2, false).equals({\n    name : \"trick\",\n    value : \"value\",\n    value2 : \"value2\",\n    value3 : \"value3\"\n}));\n\nvar deep = {\n    first : {\n        name : \"trick\",\n        val : \"value\"\n    },\n    second : {\n        foo : \"bar\"\n    }\n};\n\nvar deepMerge = {\n    first : {\n        name : \"track\",\n        anotherVal : \"wohoo\"\n    },\n    second : {\n        foo : \"baz\",\n        bar : \"bam\"\n    },\n    v : \"on first layer\"\n};\n\nassertTrue(\"Deep merges\", clone(deep).merge(deepMerge).equals({\n    first : {\n        name : \"track\",\n        val : \"value\",\n        anotherVal : \"wohoo\"\n    },\n    second : {\n        foo : \"baz\",\n        bar : \"bam\"\n    },\n    v : \"on first layer\"\n}));\n\nassertTrue(\"Deep merges no override\", clone(deep).merge(deepMerge, false).equals({\n    first : {\n        name : \"trick\",\n        val : \"value\",\n        anotherVal : \"wohoo\"\n    },\n    second : {\n        foo : \"bar\",\n        bar : \"bam\"\n    },\n    v : \"on first layer\"\n}));\n\nvar obj1 = {a: 1, b: \"hello\"};\nobj1.merge({c: 3});\nassertTrue(obj1.equals({a: 1, b: \"hello\", c: 3}));\n\nobj1.merge({a: 2, b: \"mom\", d: \"new property\"}, false);\nassertTrue(obj1.equals({a: 1, b: \"hello\", c: 3, d: \"new property\"}));\n\nvar obj2 = {};\nobj2.merge({a: 1}, {b: 2}, {a: 3});\nassertTrue(obj2.equals({a: 3, b: 2}));\n\nvar a = [];\nvar b = [1, [2, 3], 4];\na.merge(b);\nassertEquals(1, a[0]);\nassertEquals([2, 3], a[1]);\nassertEquals(4, a[2]);\n\n\nvar o1 = {};\nvar o2 = {a: 1, b: {c: 2}};\nvar o3 = {d: 3};\no1.merge(o2, o3);\nassertTrue(o1.equals({a: 1, b: {c: 2}, d: 3}));\no1.b.c = 99;\nassertTrue(o2.equals({a: 1, b: {c: 2}}));\n\n// checking types with arrays and objects\nvar bo;\na = [];\nbo = [1, {0:2, 1:3}, 4];\nb = [1, [2, 3], 4];\n\na.merge(b);\nassertTrue(\"Array stays Array?\", Array.isArray(a[1]));\n\na = [];\na.merge(bo);\nassertTrue(\"Object stays Object?\", !Array.isArray(a[1]));\n\na = [];\na.merge(b);\na.merge(bo);\nassertTrue(\"Object overrides Array\", !Array.isArray(a[1]));\n\na = [];\na.merge(b);\na.merge(bo, false);\nassertTrue(\"Object does not override Array\", Array.isArray(a[1]));\n\na = [];\na.merge(bo);\na.merge(b);\nassertTrue(\"Array overrides Object\", Array.isArray(a[1]));\n\na = [];\na.merge(bo);\na.merge(b, false);\nassertTrue(\"Array does not override Object\", !Array.isArray(a[1]));\n</code></pre>\n\n<p>My equals method can be found here: <a href=\"https://stackoverflow.com/questions/1068834/object-comparison-in-javascript/5522917#5522917\">Object comparison in JavaScript</a></p>\n"},{"score":1,"body":"<p>I'm kind of getting started with JavaScript, so correct me if I'm wrong.</p>\n\n<p>But wouldn't it be better if you could merge any number of objects? Here's how I do it using the native <code>Arguments</code> object.</p>\n\n<p>The key to is that you can actually pass any number of arguments to a JavaScript function without defining them in the function declaration. You just can't access them without using the Arguments object.</p>\n\n<pre><code>function mergeObjects() (\n    var tmpObj = {};\n\n    for(var o in arguments) {\n        for(var m in arguments[o]) {\n            tmpObj[m] = arguments[o][m];\n        }\n    }\n    return tmpObj;\n}\n</code></pre>\n"},{"score":2,"body":"<p>Use:</p>\n\n<pre><code>//Takes any number of objects and returns one merged object\nvar objectMerge = function(){\n    var out = {};\n    if(!arguments.length)\n        return out;\n    for(var i=0; i&lt;arguments.length; i++) {\n        for(var key in arguments[i]){\n            out[key] = arguments[i][key];\n        }\n    }\n    return out;\n}\n</code></pre>\n\n<p>It was tested with:</p>\n\n<pre><code>console.log(objectMerge({a:1, b:2}, {a:2, c:4}));\n</code></pre>\n\n<p>It results in:</p>\n\n<pre><code>{ a: 2, b: 2, c: 4 }\n</code></pre>\n"},{"score":9,"body":"<p>In <a href=\"http://en.wikipedia.org/wiki/Ext_JS\" rel=\"nofollow noreferrer\">Ext&nbsp;JS</a> 4 it can be done as follows:</p>\n\n<pre><code>var mergedObject = Ext.Object.merge(object1, object2)\n\n// Or shorter:\nvar mergedObject2 = Ext.merge(object1, object2)\n</code></pre>\n\n<p>See <em><a href=\"http://docs.sencha.com/ext-js/4-0/#/api/Ext.Object-method-merge\" rel=\"nofollow noreferrer\">merge( object ) : Object</a></em>.</p>\n"},{"score":2,"body":"<p>gossi's extension of David Coallier's method:</p>\n\n<p>Check these two lines:</p>\n\n<pre><code>from = arguments[i];\nObject.getOwnPropertyNames(from).forEach(function (name) {\n</code></pre>\n\n<p>One need to check \"from\" against null object... If for example merging an object that comes from an <a href=\"http://en.wikipedia.org/wiki/Ajax_%28programming%29\" rel=\"nofollow\">Ajax</a> response, previously created on a server, an object property can have a value of \"null\", and in that case the above code generates an error saying:</p>\n\n<blockquote>\n  <p>\"from\" is not a valid object</p>\n</blockquote>\n\n<p>So for example, wrapping the \"...Object.getOwnPropertyNames(from).forEach...\" function with an \"if (from != null) { ... }\" will prevent that error occurring.</p>\n"},{"score":2,"body":"<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function extend(o, o1, o2){\r\n    if( !(o instanceof Object) ) o = {};\r\n\r\n    copy(o, o1);\r\n    if( o2 )\r\n        copy(o, o2)\r\n\r\n    function isObject(obj) {\r\n        var type = Object.prototype.toString.call(obj);\r\n        return obj === Object(obj) &amp;&amp; type != '[object Array]' &amp;&amp; type != '[object Function]';\r\n    };\r\n\r\n    function copy(a,b){\r\n        // copy o2 to o\r\n        for( var key in b )\r\n            if( b.hasOwnProperty(key) ){\r\n                if( isObject(b[key]) ){\r\n                    if( !isObject(a[key]) )\r\n                        a[key] = Object.assign({}, b[key]); \r\n                    else copy(a[key], b[key])\r\n                }\r\n                else\r\n                    a[key] = b[key];\r\n            }\r\n    }\r\n\r\n    return o;\r\n};\r\n\r\n\r\nvar o1 = {a:{foo:1}, b:1},\r\n    o2 = {a:{bar:2}, b:[1], c:()=&gt;{}},\r\n    newMerged = extend({}, o1, o2);\r\n    \r\nconsole.log( newMerged )\r\nconsole.log( o1 )\r\nconsole.log( o2 )</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":67,"body":"<p>I need to merge objects today, and this question (and answers) helped me a lot. I tried some of the answers, but none of them fit my needs, so I combined some of the answers, added something myself and came up with a new merge function. Here it is:</p>\n\n\n\n<pre class=\"lang-js prettyprint-override\"><code>var merge = function() {\n    var obj = {},\n        i = 0,\n        il = arguments.length,\n        key;\n    for (; i &lt; il; i++) {\n        for (key in arguments[i]) {\n            if (arguments[i].hasOwnProperty(key)) {\n                obj[key] = arguments[i][key];\n            }\n        }\n    }\n    return obj;\n};\n</code></pre>\n\n<p>Some example usages:</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>var t1 = {\n    key1: 1,\n    key2: \"test\",\n    key3: [5, 2, 76, 21]\n};\nvar t2 = {\n    key1: {\n        ik1: \"hello\",\n        ik2: \"world\",\n        ik3: 3\n    }\n};\nvar t3 = {\n    key2: 3,\n    key3: {\n        t1: 1,\n        t2: 2,\n        t3: {\n            a1: 1,\n            a2: 3,\n            a4: [21, 3, 42, \"asd\"]\n        }\n    }\n};\n\nconsole.log(merge(t1, t2));\nconsole.log(merge(t1, t3));\nconsole.log(merge(t2, t3));\nconsole.log(merge(t1, t2, t3));\nconsole.log(merge({}, t1, { key1: 1 }));\n</code></pre>\n"},{"score":7,"body":"<p>Based on <a href=\"https://stackoverflow.com/questions/171251/how-can-i-merge-properties-of-two-javascript-objects-dynamically/383245#383245\">Markus'</a> and <a href=\"https://stackoverflow.com/questions/171251/how-can-i-merge-properties-of-two-javascript-objects-dynamically/7965071#7965071\">vsync' answer</a>, this is an expanded version. The function takes any number of arguments. It can be used to set properties on <a href=\"http://en.wikipedia.org/wiki/Document_Object_Model\" rel=\"noreferrer\">DOM</a> nodes and makes deep copies of values. However, the first argument is given by reference.</p>\n\n<p>To detect a DOM node, the isDOMNode() function is used (see Stack&nbsp;Overflow question <em><a href=\"https://stackoverflow.com/a/8736129/1131084\">JavaScript isDOM — How do you check if a JavaScript Object is a DOM Object?</a></em>)</p>\n\n<p>It was tested in <a href=\"http://en.wikipedia.org/wiki/Opera_%28web_browser%29\" rel=\"noreferrer\">Opera</a> 11, Firefox 6, <a href=\"http://en.wikipedia.org/wiki/Internet_Explorer_8\" rel=\"noreferrer\">Internet&nbsp;Explorer&nbsp;8</a> and Google Chrome 16.</p>\n\n<h2>Code</h2>\n\n<pre><code>function mergeRecursive() {\n\n  // _mergeRecursive does the actual job with two arguments.\n  var _mergeRecursive = function (dst, src) {\n    if (isDOMNode(src) || typeof src !== 'object' || src === null) {\n      return dst;\n    }\n\n    for (var p in src) {\n      if (!src.hasOwnProperty(p))\n        continue;\n      if (src[p] === undefined)\n        continue;\n      if ( typeof src[p] !== 'object' || src[p] === null) {\n        dst[p] = src[p];\n      } else if (typeof dst[p]!=='object' || dst[p] === null) {\n        dst[p] = _mergeRecursive(src[p].constructor===Array ? [] : {}, src[p]);\n      } else {\n        _mergeRecursive(dst[p], src[p]);\n      }\n    }\n    return dst;\n  }\n\n  // Loop through arguments and merge them into the first argument.\n  var out = arguments[0];\n  if (typeof out !== 'object' || out === null)\n    return out;\n  for (var i = 1, il = arguments.length; i &lt; il; i++) {\n    _mergeRecursive(out, arguments[i]);\n  }\n  return out;\n}\n</code></pre>\n\n<h2>Some examples</h2>\n\n<p>Set innerHTML and style of a HTML Element</p>\n\n<pre><code>mergeRecursive(\n  document.getElementById('mydiv'),\n  {style: {border: '5px solid green', color: 'red'}},\n  {innerHTML: 'Hello world!'});\n</code></pre>\n\n<p>Merge arrays and objects. Note that undefined can be used to preserv values in the lefthand array/object.</p>\n\n<pre><code>o = mergeRecursive({a:'a'}, [1,2,3], [undefined, null, [30,31]], {a:undefined, b:'b'});\n// o = {0:1, 1:null, 2:[30,31], a:'a', b:'b'}\n</code></pre>\n\n<p>Any argument not beeing a JavaScript object (including null) will be ignored. Except for the first argument, also DOM nodes are discarded. Beware that i.e. strings, created like new String() are in fact objects.</p>\n\n<pre><code>o = mergeRecursive({a:'a'}, 1, true, null, undefined, [1,2,3], 'bc', new String('de'));\n// o = {0:'d', 1:'e', 2:3, a:'a'}\n</code></pre>\n\n<p>If you want to merge two objects into a new (without affecting any of the two) supply {} as first argument</p>\n\n<pre><code>var a={}, b={b:'abc'}, c={c:'cde'}, o;\no = mergeRecursive(a, b, c);\n// o===a is true, o===b is false, o===c is false\n</code></pre>\n\n<p><strong>Edit</strong> (by ReaperSoon):</p>\n\n<p>To also merge arrays</p>\n\n<pre><code>function mergeRecursive(obj1, obj2) {\n  if (Array.isArray(obj2)) { return obj1.concat(obj2); }\n  for (var p in obj2) {\n    try {\n      // Property in destination object set; update its value.\n      if ( obj2[p].constructor==Object ) {\n        obj1[p] = mergeRecursive(obj1[p], obj2[p]);\n      } else if (Array.isArray(obj2[p])) {\n        obj1[p] = obj1[p].concat(obj2[p]);\n      } else {\n        obj1[p] = obj2[p];\n      }\n    } catch(e) {\n      // Property in destination object not set; create it and set its value.\n      obj1[p] = obj2[p];\n    }\n  }\n  return obj1;\n}\n</code></pre>\n"},{"score":1,"body":"<p>In <a href=\"http://en.wikipedia.org/wiki/Yahoo!_UI_Library\" rel=\"nofollow\">YUI</a> <a href=\"http://yuilibrary.com/yui/docs/yui/yui-merge.html\" rel=\"nofollow\"><code>Y.merge</code></a> should get the job done:</p>\n\n<pre><code>Y.merge(obj1, obj2, obj3....) \n</code></pre>\n"},{"score":177,"body":"<p>Note that <a href=\"http://underscorejs.org/\" rel=\"noreferrer\"><code>underscore.js</code></a>'s <a href=\"http://underscorejs.org/#extend\" rel=\"noreferrer\"><code>extend</code>-method</a> does this in a one-liner:</p>\n\n<pre><code>_.extend({name : 'moe'}, {age : 50});\n=&gt; {name : 'moe', age : 50}\n</code></pre>\n"},{"score":12,"body":"<p>Just if anyone is using <a href=\"http://closure-library.googlecode.com/svn/docs/closure_goog_object_object.js.html\" rel=\"nofollow noreferrer\">Google Closure Library</a>:</p>\n\n<pre><code>goog.require('goog.object');\nvar a = {'a': 1, 'b': 2};\nvar b = {'b': 3, 'c': 4};\ngoog.object.extend(a, b);\n// Now object a == {'a': 1, 'b': 3, 'c': 4};\n</code></pre>\n\n<p><a href=\"http://closure-library.googlecode.com/svn/docs/closure_goog_array_array.js.html\" rel=\"nofollow noreferrer\">Similar helper function exists for array</a>:</p>\n\n<pre><code>var a = [1, 2];\nvar b = [3, 4];\ngoog.array.extend(a, b); // Extends array 'a'\ngoog.array.concat(a, b); // Returns concatenation of array 'a' and 'b'\n</code></pre>\n"},{"score":-1,"body":"<pre><code>function extend()\n{ \n    var o = {}; \n\n    for (var i in arguments)\n    { \n        var s = arguments[i]; \n\n        for (var i in s)\n        { \n            o[i] = s[i]; \n        } \n    } \n\n    return o;\n}\n</code></pre>\n"},{"score":29,"body":"<p>Just by the way, what you're all doing is overwriting properties, not merging...</p>\n\n<p>This is how JavaScript objects area really merged: Only keys in the <code>to</code> object which are not objects themselves will be overwritten by <code>from</code>. Everything else will be <strong><em>really merged</em></strong>. Of course you can change this behaviour to not overwrite anything which exists like only if <code>to[n] is undefined</code>, etc...:</p>\n\n<pre><code>var realMerge = function (to, from) {\n\n    for (n in from) {\n\n        if (typeof to[n] != 'object') {\n            to[n] = from[n];\n        } else if (typeof from[n] == 'object') {\n            to[n] = realMerge(to[n], from[n]);\n        }\n    }\n    return to;\n};\n</code></pre>\n\n<p>Usage:</p>\n\n<pre><code>var merged = realMerge(obj1, obj2);\n</code></pre>\n"},{"score":0,"body":"<p>This merges <code>obj</code> into a \"default\" <code>def</code>. <code>obj</code> has precedence for anything that exists in both, since <code>obj</code> is copied into <code>def</code>. Note also that this is recursive.</p>\n\n<pre><code>function mergeObjs(def, obj) {\n    if (typeof obj == 'undefined') {\n        return def;\n    } else if (typeof def == 'undefined') {\n        return obj;\n    }\n    for (var i in obj) {\n        if (obj[i] != null &amp;&amp; obj[i].constructor == Object) {\n            def[i] = mergeObjs(def[i], obj[i]);\n        } else {\n            def[i] = obj[i];\n        }\n    }\n    return def;\n}\n\na = {x : {y : [123]}}\nb = {x : {z : 123}}\nconsole.log(mergeObjs(a, b));\n// {x: {y : [123], z : 123}}\n</code></pre>\n"},{"score":4,"body":"<p>It's worth mentioning that the version from the <a href=\"http://www.140byt.es/\" rel=\"nofollow\">140byt.es collection</a> is solving the task within minimum space and is worth a try for this purpose:</p>\n\n<p>Code:</p>\n\n<pre><code>function m(a,b,c){for(c in b)b.hasOwnProperty(c)&amp;&amp;((typeof a[c])[0]=='o'?m(a[c],b[c]):a[c]=b[c])}\n</code></pre>\n\n<p>Usage for your purpose:</p>\n\n<pre><code>m(obj1,obj2);\n</code></pre>\n\n<p>Here's the <a href=\"https://gist.github.com/988478\" rel=\"nofollow\">original Gist</a>.</p>\n"},{"score":0,"body":"<pre><code>A={a:1,b:function(){alert(9)}}\nB={a:2,c:3}\nA.merge = function(){for(var i in B){A[i]=B[i]}}\nA.merge()\n</code></pre>\n\n<p>Result is: {a:2,c:3,b:function()}</p>\n"},{"score":28,"body":"<p>Here's my stab which</p>\n\n<ol>\n<li>Supports deep merge</li>\n<li>Does not mutate arguments</li>\n<li>Takes any number of arguments</li>\n<li>Does not extend the object prototype</li>\n<li>Does not depend on another library (<a href=\"http://en.wikipedia.org/wiki/JQuery\" rel=\"noreferrer\">jQuery</a>, <a href=\"http://en.wikipedia.org/wiki/MooTools\" rel=\"noreferrer\">MooTools</a>, <a href=\"https://en.wikipedia.org/wiki/Underscore.js\" rel=\"noreferrer\">Underscore.js</a>, etc.)</li>\n<li>Includes check for hasOwnProperty</li>\n<li><p>Is short :)</p>\n\n<pre><code>/*\n    Recursively merge properties and return new object\n    obj1 &amp;lt;- obj2 [ &amp;lt;- ... ]\n*/\nfunction merge () {\n    var dst = {}\n        ,src\n        ,p\n        ,args = [].splice.call(arguments, 0)\n    ;\n\n    while (args.length &gt; 0) {\n        src = args.splice(0, 1)[0];\n        if (toString.call(src) == '[object Object]') {\n            for (p in src) {\n                if (src.hasOwnProperty(p)) {\n                    if (toString.call(src[p]) == '[object Object]') {\n                        dst[p] = merge(dst[p] || {}, src[p]);\n                    } else {\n                        dst[p] = src[p];\n                    }\n                }\n            }\n        }\n    }\n\n   return dst;\n}\n</code></pre></li>\n</ol>\n\n<p>Example:</p>\n\n<pre><code>a = {\n    \"p1\": \"p1a\",\n    \"p2\": [\n        \"a\",\n        \"b\",\n        \"c\"\n    ],\n    \"p3\": true,\n    \"p5\": null,\n    \"p6\": {\n        \"p61\": \"p61a\",\n        \"p62\": \"p62a\",\n        \"p63\": [\n            \"aa\",\n            \"bb\",\n            \"cc\"\n        ],\n        \"p64\": {\n            \"p641\": \"p641a\"\n        }\n    }\n};\n\nb = {\n    \"p1\": \"p1b\",\n    \"p2\": [\n        \"d\",\n        \"e\",\n        \"f\"\n    ],\n    \"p3\": false,\n    \"p4\": true,\n    \"p6\": {\n        \"p61\": \"p61b\",\n        \"p64\": {\n            \"p642\": \"p642b\"\n        }\n    }\n};\n\nc = {\n    \"p1\": \"p1c\",\n    \"p3\": null,\n    \"p6\": {\n        \"p62\": \"p62c\",\n        \"p64\": {\n            \"p643\": \"p641c\"\n        }\n    }\n};\n\nd = merge(a, b, c);\n\n\n/*\n    d = {\n        \"p1\": \"p1c\",\n        \"p2\": [\n            \"d\",\n            \"e\",\n            \"f\"\n        ],\n        \"p3\": null,\n        \"p5\": null,\n        \"p6\": {\n            \"p61\": \"p61b\",\n            \"p62\": \"p62c\",\n            \"p63\": [\n                \"aa\",\n                \"bb\",\n                \"cc\"\n            ],\n            \"p64\": {\n                \"p641\": \"p641a\",\n                \"p642\": \"p642b\",\n                \"p643\": \"p641c\"\n            }\n        },\n        \"p4\": true\n    };\n*/\n</code></pre>\n"},{"score":0,"body":"<p>You could assign every object a default merge (perhaps 'inherit' a better name) method:</p>\n\n<p>It should work with either objects or instantiated functions.</p>\n\n<p>The below code handles overriding the merged values if so desired:</p>\n\n<pre><code>Object.prototype.merge = function(obj, override) {\n// Don't override by default\n\n    for (var key in obj) {\n        var n = obj[key];\n        var t = this[key];\n        this[key] = (override &amp;&amp; t) ? n : t;\n    };\n\n};\n</code></pre>\n\n<p>Test data is below:</p>\n\n<pre><code>var Mammal = function () {\n    this.eyes = 2;\n    this.thinking_brain = false;\n    this.say = function () {\n    console.log('screaming like a mammal')};\n}\n\nvar Human = function () {\n    this.thinking_brain = true;\n    this.say = function() {console.log('shouting like a human')};\n}\n\njohn = new Human();\n\n// Extend mammal, but do not override from mammal\njohn.merge(new Mammal());\njohn.say();\n\n// Extend mammal and override from mammal\njohn.merge(new Mammal(), true);\njohn.say();\n</code></pre>\n"},{"score":2,"body":"<p>My way:</p>\n\n<pre><code>function mergeObjects(defaults, settings) {\n    Object.keys(defaults).forEach(function(key_default) {\n        if (typeof settings[key_default] == \"undefined\") {\n            settings[key_default] = defaults[key_default];\n        } else if (isObject(defaults[key_default]) &amp;&amp; isObject(settings[key_default])) {\n            mergeObjects(defaults[key_default], settings[key_default]);\n        }\n    });\n\n    function isObject(object) {\n        return Object.prototype.toString.call(object) === '[object Object]';\n    }\n\n    return settings;\n}\n</code></pre>\n\n<p>:)</p>\n"},{"score":1,"body":"<p>I've used Object.create() to keep the default settings (utilising __proto__ or Object.getPrototypeOf() ). </p>\n\n<pre><code>function myPlugin( settings ){\n    var defaults = {\n        \"keyName\": [ \"string 1\", \"string 2\" ]\n    }\n    var options = Object.create( defaults );\n    for (var key in settings) { options[key] = settings[key]; }\n}\nmyPlugin( { \"keyName\": [\"string 3\", \"string 4\" ] } );\n</code></pre>\n\n<p>This way I can always 'concat()' or 'push()' later.</p>\n\n<pre><code>var newArray = options['keyName'].concat( options.__proto__['keyName'] );\n</code></pre>\n\n<p><strong>Note</strong>: You'll need to do a hasOwnProperty check before concatenation to avoid duplication.</p>\n"},{"score":84,"body":"<p>Similar to jQuery extend(), you have the same function in <a href=\"http://en.wikipedia.org/wiki/AngularJS\" rel=\"noreferrer\">AngularJS</a>:</p>\n\n<pre><code>// Merge the 'options' object into the 'settings' object\nvar settings = {validate: false, limit: 5, name: \"foo\"};\nvar options  = {validate: true, name: \"bar\"};\nangular.extend(settings, options);\n</code></pre>\n"},{"score":5,"body":"<p>With <a href=\"https://en.wikipedia.org/wiki/Underscore.js\" rel=\"nofollow\">Underscore.js</a>, to merge an array of objects do:</p>\n\n<pre><code>var arrayOfObjects = [ {a:1}, {b:2, c:3}, {d:4} ];\n_(arrayOfObjects).reduce(function(memo, o) { return _(memo).extend(o); });\n</code></pre>\n\n<p>It results in:</p>\n\n<pre><code>Object {a: 1, b: 2, c: 3, d: 4}\n</code></pre>\n"},{"score":1,"body":"<p>For those using <a href=\"http://en.wikipedia.org/wiki/Node.js\" rel=\"nofollow\">Node.js</a>, there's an NPM module: <a href=\"https://www.npmjs.com/package/node.extend\" rel=\"nofollow\">node.extend</a></p>\n\n<h1>Install:</h1>\n\n<pre><code>npm install node.extend\n</code></pre>\n\n<h1>Usage:</h1>\n\n<pre><code>var extend = require('node.extend');\nvar destObject = extend(true, {}, sourceObject);\n// Where sourceObject is the object whose properties will be copied into another.\n</code></pre>\n"},{"score":18,"body":"<p>There's a library called <a href=\"https://github.com/nrf110/deepmerge\" rel=\"noreferrer\"><code>deepmerge</code></a> on <a href=\"http://en.wikipedia.org/wiki/GitHub\" rel=\"noreferrer\">GitHub</a>: That seems to be getting some traction. It's a standalone, available through both the <a href=\"https://en.wikipedia.org/wiki/Npm_(software)\" rel=\"noreferrer\">npm</a> and bower package managers.</p>\n\n<p>I would be inclined to use or improve on this instead of copy-pasting code from answers.</p>\n"},{"score":357,"body":"<p>The <a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-object.assign\" rel=\"noreferrer\">Harmony ECMAScript 2015 (ES6)</a> specifies <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" rel=\"noreferrer\"><strong><code>Object.assign</code></strong></a> which will do this.</p>\n\n<pre><code>Object.assign(obj1, obj2);\n</code></pre>\n\n<p>Current browser support is <a href=\"http://kangax.github.io/compat-table/es6/#test-Object_static_methods_Object.assign\" rel=\"noreferrer\">getting better</a>, but if you're developing for browsers that don't have support, you can use a <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign#Polyfill\" rel=\"noreferrer\">polyfill</a>.</p>\n"},{"score":0,"body":"<p>This solution creates a <strong>new object</strong> and is able to handle <strong>multiple objects</strong>.</p>\n\n<p>Furthermore, it is <strong>recursive</strong> and you can chose weather you <strong>want</strong> to <strong>overwrite Values</strong> and <strong>Objects</strong>.</p>\n\n<pre><code>    function extendObjects() {\n\n        var newObject        = {};\n        var overwriteValues  = false;\n        var overwriteObjects = false;\n\n        for ( var indexArgument = 0; indexArgument &lt; arguments.length; indexArgument++ ) {\n\n            if ( typeof arguments[indexArgument] !== 'object' ) {\n\n                if ( arguments[indexArgument] == 'overwriteValues_True' ) {\n\n                    overwriteValues = true;            \n                } else if ( arguments[indexArgument] == 'overwriteValues_False' ) {\n\n                    overwriteValues = false;                             \n                } else if ( arguments[indexArgument] == 'overwriteObjects_True' ) {\n\n                    overwriteObjects = true;     \n                } else if ( arguments[indexArgument] == 'overwriteObjects_False' ) {\n\n                    overwriteObjects = false; \n                }\n\n            } else {\n\n                extendObject( arguments[indexArgument], newObject, overwriteValues, overwriteObjects );\n            }\n\n        }\n\n        function extendObject( object, extendedObject, overwriteValues, overwriteObjects ) {\n\n            for ( var indexObject in object ) {\n\n                if ( typeof object[indexObject] === 'object' ) {\n\n                    if ( typeof extendedObject[indexObject] === \"undefined\" || overwriteObjects ) {\n                        extendedObject[indexObject] = object[indexObject];\n                    }\n\n                    extendObject( object[indexObject], extendedObject[indexObject], overwriteValues, overwriteObjects );\n\n                } else {\n\n                    if ( typeof extendedObject[indexObject] === \"undefined\" || overwriteValues ) {\n                        extendedObject[indexObject] = object[indexObject];\n                    }\n\n                }\n\n            }     \n\n            return extendedObject;\n\n        }\n\n        return newObject;\n    }\n\n    var object1           = { a : 1, b : 2, testArr : [888, { innArr : 1 }, 777 ], data : { e : 12, c : { lol : 1 }, rofl : { O : 3 } } };\n    var object2           = { a : 6, b : 9, data : { a : 17, b : 18, e : 13, rofl : { O : 99, copter : { mao : 1 } } }, hexa : { tetra : 66 } };\n    var object3           = { f : 13, g : 666, a : 333, data : { c : { xD : 45 } }, testArr : [888, { innArr : 3 }, 555 ]  };\n\n    var newExtendedObject = extendObjects( 'overwriteValues_False', 'overwriteObjects_False', object1, object2, object3 );\n</code></pre>\n\n<p><strong>Contents of newExtendedObject:</strong></p>\n\n<pre><code>{\"a\":1,\"b\":2,\"testArr\":[888,{\"innArr\":1},777],\"data\":{\"e\":12,\"c\":{\"lol\":1,\"xD\":45},\"rofl\":{\"O\":3,\"copter\":{\"mao\":1}},\"a\":17,\"b\":18},\"hexa\":{\"tetra\":66},\"f\":13,\"g\":666}\n</code></pre>\n\n<p>Fiddle: <a href=\"http://jsfiddle.net/o0gb2umb/\" rel=\"nofollow\">http://jsfiddle.net/o0gb2umb/</a></p>\n"},{"score":36,"body":"<p>The following two are probably a good starting point. lodash also has a customizer function for those special needs!</p>\n\n<p><code>_.extend</code> (<a href=\"http://underscorejs.org/#extend\" rel=\"noreferrer\">http://underscorejs.org/#extend</a>) <br/>\n<code>_.merge</code> (<a href=\"https://lodash.com/docs#merge\" rel=\"noreferrer\">https://lodash.com/docs#merge</a>)</p>\n"},{"score":0,"body":"<p>Another method:</p>\n\n<pre><code>function concat_collection(obj1, obj2) {\n    var i;\n    var arr = new Array();\n\n    var len1 = obj1.length;\n    for (i=0; i&lt;len1; i++) {\n        arr.push(obj1[i]);\n    }\n\n    var len2 = obj2.length;\n    for (i=0; i&lt;len2; i++) {\n        arr.push(obj2[i]);\n    }\n\n    return arr;\n}\n\nvar ELEMENTS = concat_collection(A,B);\nfor(var i = 0; i &lt; ELEMENTS.length; i++) {\n    alert(ELEMENTS[i].value);\n}\n</code></pre>\n"},{"score":2,"body":"<p>I use the following which is in pure JavaScript. It starts from the right-most argument and combines them all the way up to the first argument. There is no return value, only the first argument is modified and the left-most parameter (except the first one) has the highest weight on properties.</p>\n\n<pre><code>var merge = function() {\n  var il = arguments.length;\n\n  for (var i = il - 1; i &gt; 0; --i) {\n    for (var key in arguments[i]) {\n      if (arguments[i].hasOwnProperty(key)) {\n        arguments[0][key] = arguments[i][key];\n      }\n    }\n  }\n};\n</code></pre>\n"},{"score":16,"body":"<p>You can simply use jQuery <strong><code>extend</code></strong></p>\n\n<pre><code>var obj1 = { val1: false, limit: 5, name: \"foo\" };\nvar obj2 = { val2: true, name: \"bar\" };\n\njQuery.extend(obj1, obj2);\n</code></pre>\n\n<p>Now <code>obj1</code> contains all the values of <code>obj1</code> and <code>obj2</code></p>\n"},{"score":0,"body":"<p>If you are using <a href=\"http://en.wikipedia.org/wiki/Dojo_Toolkit\" rel=\"nofollow\">Dojo Toolkit</a> then the best way to merge two object is using a mixin. </p>\n\n<p>Below is the sample for Dojo Toolkit mixin:</p>\n\n<pre><code>// Dojo 1.7+ (AMD)\nrequire([\"dojo/_base/lang\"], function(lang){\n  var a = { b:\"c\", d:\"e\" };\n  lang.mixin(a, { d:\"f\", g:\"h\" });\n  console.log(a); // b:c, d:f, g:h\n});\n\n// Dojo &lt; 1.7\nvar a = { b:\"c\", d:\"e\" };\ndojo.mixin(a, { d:\"f\", g:\"h\" });\nconsole.log(a); // b:c, d:f, g:h\n</code></pre>\n\n<p>For more details, please <em><a href=\"http://dojotoolkit.org/reference-guide/1.7/dojo/mixin.html\" rel=\"nofollow\">mixin</a></em>.</p>\n"},{"score":1,"body":"<p>You can merge objects through following my method</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var obj1 = { food: 'pizza', car: 'ford' };\r\nvar obj2 = { animal: 'dog' };\r\n\r\nvar result = mergeObjects([obj1, obj2]);\r\n\r\nconsole.log(result);\r\ndocument.write(\"result: &lt;pre&gt;\" + JSON.stringify(result, 0, 3) + \"&lt;/pre&gt;\");\r\n\r\nfunction mergeObjects(objectArray) {\r\n    if (objectArray.length) {\r\n        var b = \"\", i = -1;\r\n        while (objectArray[++i]) {\r\n            var str = JSON.stringify(objectArray[i]);\r\n            b += str.slice(1, str.length - 1);\r\n            if (objectArray[i + 1]) b += \",\";\r\n        }\r\n        return JSON.parse(\"{\" + b + \"}\");\r\n    }\r\n    return {};\r\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":20,"body":"<p><strong>Object.assign()</strong></p>\n\n<p><strong>ECMAScript 2015 (ES6)</strong></p>\n\n<p>This is a new technology, part of the ECMAScript 2015 (ES6) standard.\nThis technology's specification has been finalized, but check the compatibility table for usage and implementation status in various browsers.</p>\n\n<p>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object. It will return the target object.</p>\n\n<pre><code>var o1 = { a: 1 };\nvar o2 = { b: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign(o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\nconsole.log(o1);  // { a: 1, b: 2, c: 3 }, target object itself is changed.\n</code></pre>\n"},{"score":42,"body":"<h1>Merge properties of N objects in one line of code</h1>\n<p>An <code>Object.assign</code> method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need. (<code>IE</code> not supported)</p>\n<pre><code>var clone = Object.assign({}, obj);\n</code></pre>\n<blockquote>\n<p>The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.</p>\n</blockquote>\n<p><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" rel=\"noreferrer\">Read more...</a></p>\n<p>The <strong>polyfill</strong> to support older browsers:</p>\n<pre><code>if (!Object.assign) {\n  Object.defineProperty(Object, 'assign', {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function(target) {\n      'use strict';\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert first argument to object');\n      }\n\n      var to = Object(target);\n      for (var i = 1; i &lt; arguments.length; i++) {\n        var nextSource = arguments[i];\n        if (nextSource === undefined || nextSource === null) {\n          continue;\n        }\n        nextSource = Object(nextSource);\n\n        var keysArray = Object.keys(nextSource);\n        for (var nextIndex = 0, len = keysArray.length; nextIndex &lt; len; nextIndex++) {\n          var nextKey = keysArray[nextIndex];\n          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n          if (desc !== undefined &amp;&amp; desc.enumerable) {\n            to[nextKey] = nextSource[nextKey];\n          }\n        }\n      }\n      return to;\n    }\n  });\n}\n</code></pre>\n"},{"score":5,"body":"<p>You should use lodash's <a href=\"https://lodash.com/docs#defaultsDeep\" rel=\"noreferrer\">defaultsDeep</a></p>\n\n<pre><code>_.defaultsDeep({ 'user': { 'name': 'barney' } }, { 'user': { 'name': 'fred', 'age': 36 } });\n// → { 'user': { 'name': 'barney', 'age': 36 } }\n</code></pre>\n"},{"score":0,"body":"<p>A possible way to achieve this is the following.</p>\n\n<pre><code>if (!Object.prototype.merge){\n    Object.prototype.merge = function(obj){\n        var self = this;\n        Object.keys(obj).forEach(function(key){\n            self[key] = obj[key]\n        });\n    }\n};\n</code></pre>\n\n<p>I don't know if it's better then the other answers. In this method you add the <code>merge function</code> to <code>Objects</code> prototype. This way you can call     <code>obj1.merge(obj2);</code></p>\n\n<p>Note : you should validate your argument to see if its an object and 'throw' a proper <code>Error</code>. If not <code>Object.keys</code> will 'throw' an 'Error'</p>\n"},{"score":0,"body":"<p>Here what I used in my codebase to merge.</p>\n\n<pre><code>function merge(to, from) {\n  if (typeof to === 'object' &amp;&amp; typeof from === 'object') {\n    for (var pro in from) {\n      if (from.hasOwnProperty(pro)) {\n        to[pro] = from[pro];\n      }\n    }\n  }\n  else{\n      throw \"Merge function can apply only on object\";\n  }\n}\n</code></pre>\n"},{"score":-2,"body":"<p>If you need a deep merge that will also \"merge\" arrays by concatenating them in the result, then this ES6 function might be what you need:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function deepMerge(a, b) {\r\n    // If neither is an object, return one of them:\r\n    if (Object(a) !== a &amp;&amp; Object(b) !== b) return b || a;\r\n    // Replace remaining primitive by empty object/array\r\n    if (Object(a) !== a) a = Array.isArray(b) ? [] : {};\r\n    if (Object(b) !== b) b = Array.isArray(a) ? [] : {};\r\n    // Treat arrays differently:\r\n    if (Array.isArray(a) &amp;&amp; Array.isArray(b)) {\r\n        // Merging arrays is interpreted as concatenation of their deep clones:\r\n        return [...a.map(v =&gt; deepMerge(v)), ...b.map(v =&gt; deepMerge(v))];\r\n    } else {\r\n        // Get the keys that exist in either object\r\n        var keys = new Set([...Object.keys(a),...Object.keys(b)]);\r\n        // Recurse and assign to new object\r\n        return Object.assign({}, ...Array.from(keys,\r\n            key =&gt; ({ [key]: deepMerge(a[key], b[key]) }) ));\r\n    }\r\n}\r\n\r\n// Sample data for demo:\r\nvar a = {\r\n    groups: [{\r\n        group: [{\r\n            name: 'John',\r\n            age: 12\r\n        },{\r\n            name: 'Mary',\r\n            age: 20\r\n        }],\r\n        groupName: 'Pair'\r\n    }],\r\n    config: {\r\n        color: 'blue',\r\n        range: 'far'\r\n    }\r\n};\r\n\r\n\r\nvar b = {\r\n    groups: [{\r\n        group: [{\r\n            name: 'Bill',\r\n            age: 15\r\n        }],\r\n        groupName: 'Loner'\r\n    }],\r\n    config: {\r\n        range: 'close',\r\n        strength: 'average'\r\n    }\r\n};\r\n\r\nvar merged = deepMerge(a, b);\r\n\r\nconsole.log(merged);</code></pre>\r\n<pre class=\"snippet-code-css lang-css prettyprint-override\"><code>.as-console-wrapper { max-height: 100% !important; top: 0; }</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Note that if only one argument is passed to this function, it acts as a deep clone function.</p>\n"},{"score":53,"body":"<p>You can use the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\" rel=\"noreferrer\">object spread syntax</a> to achieve this. It's a part of ES2018 and beyond.</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"true\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const obj1 = { food: 'pizza', car: 'ford' };\nconst obj2 = { animal: 'dog' };\n\nconst obj3 = { ...obj1, ...obj2 };\nconsole.log(obj3);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":-1,"body":"<p>You can do the following in EcmaScript2016</p>\n\n<p>Correction: it's a stage 3 proposal, still it has always worked for me</p>\n\n<pre><code>const objA = {\n  attrA: 'hello',\n  attrB: true\n}\n\nconst objB = {\n  attrC: 2\n}\n\nconst mergedObj = {...objA, ...objB}\n</code></pre>\n"},{"score":1,"body":"<h2>The Merge Of JSON Compatible JavaScript Objects</h2>\n\n<p>I encourage the use and utilization of nondestructive methods that don't modify the original source, 'Object.assign' is a <em>destructive method</em> and it also happens to be not so <em>production friendly</em> because it stops working on earlier browsers and you have no way of patching it cleanly, with an alternative.</p>\n\n<p>Merging JS Objects will always be out of reach, or incomplete, whatever the solution. But merging JSON compliant compatible objects is just one step away from being able to write a simple and portable piece of code of a nondestructive method of merging series of JS Objects into a returned master containing all the unique property-names and their corresponding values synthesized in a single master object for the intended purpose.</p>\n\n<p>Having in mind that MSIE8 is the first browser to have added a native support for the JSON object is a great relief, and reusing the already existing technology, is always a welcomed opportunity.</p>\n\n<p>Restricting your code to JSON complant standard objects, is more of an advantage, than a restriction - since these objects can also be transmitted over the Internet. And of course for those who would like a deeper backward compatibility there's always a json plug., whose methods can easily be assigned to a JSON variable in the outer code without having to modify or rewrite the method in use.</p>\n\n<pre><code>function Merge( ){\n    var a = [].slice.call( arguments ), i = 0;\n        while( a[i] )a[i] = JSON.stringify( a[i++] ).slice( 1,-1 );\n        return JSON.parse( \"{\"+ a.join() +\"}\" );\n    }\n</code></pre>\n\n<p>(Of course one can always give it a more meaningful name, which I haven't decided yet; should probably name it JSONmerge)</p>\n\n<p>The use case:</p>\n\n<pre><code>var master = Merge( obj1, obj2, obj3, ...objn );\n</code></pre>\n\n<p>Now, contrary to the <code>Object.assign</code> this leaves all objects untouched and in their original state (in case you've done something wrong and need to reorder the merging objects or be able to use them separately for some other operation before merging them again).</p>\n\n<p>Tthe number of the Merge arguments is also limited <em>only</em> by the arguments length limit [which is huge]. \nThe natively supported JSON parse / stringify is already machine optimized, meaning: it should be faster than any scripted form of JS loop. \nThe iteration over given arguments, is being done using the <code>while</code> - proven to be the fastest loop in JS. </p>\n\n<p>It doesn't harm to briefly mention the fact we already know that duplicate properties of the unique object labels (keys) will be overwritten by the later object containing the same key label, which means you are in control of which property is taking over the previous by simply ordering or reordering the arguments list. And the benefit of getting a clean and updated master object with no dupes as a final output.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>;\r\nvar obj1 = {a:1}, obj2 = {b:2}, obj3 = {c:3}\r\n;\r\nfunction Merge( ){\r\n    var a = [].slice.call( arguments ), i = 0;\r\n        while( a[i] )a[i] = JSON.stringify( a[i++] ).slice( 1,-1 );\r\n        return JSON.parse( \"{\"+ a.join() +\"}\" );\r\n    }\r\n;\r\nvar master = Merge( obj1, obj2, obj3 )\r\n;\r\nconsole.log( JSON.stringify( master ) )\r\n;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":1,"body":"<p>ES5 compatible native one-liner:</p>\n\n<pre><code>var merged = [obj1, obj2].reduce(function(a, o) { for(k in o) a[k] = o[k]; return a; }, {})\n</code></pre>\n"},{"score":13,"body":"<p>**Merging objects is simple using <code>Object.assign</code> or the spread <code>...</code> operator **</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var obj1 = { food: 'pizza', car: 'ford' }\r\nvar obj2 = { animal: 'dog', car: 'BMW' }\r\nvar obj3 = {a: \"A\"}\r\n\r\n\r\nvar mergedObj = Object.assign(obj1,obj2,obj3)\r\n // or using the Spread operator (...)\r\nvar mergedObj = {...obj1,...obj2,...obj3}\r\n\r\nconsole.log(mergedObj);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>The objects are merged from right to left, this means that objects which have identical properties as the objects to their right will be overriden.</p>\n\n<p>In this example <code>obj2.car</code> overrides <code>obj1.car</code></p>\n"},{"score":12,"body":"<p>Wow.. this is the first StackOverflow post I've seen with multiple pages. Apologies for adding another &quot;answer&quot;</p>\n<br />\n<h3>ES5 &amp; Earlier</h3>\n<p>This method is for <em>ES5 &amp; Earlier</em> - there are plenty of other answers addressing ES6.</p>\n<p>I did not see any <em>&quot;deep&quot;</em> object merging utilizing the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments\" rel=\"nofollow noreferrer\"><code>arguments</code></a> property. Here is my answer - <strong>compact</strong> &amp; <strong>recursive</strong>, allowing unlimited object arguments to be passed:</p>\n<pre class=\"lang-js prettyprint-override\"><code>function extend() {\n    for (var o = {}, i = 0; i &lt; arguments.length; i++) {\n        // Uncomment to skip arguments that are not objects (to prevent errors)\n        // if (arguments[i].constructor !== Object) continue;\n        for (var k in arguments[i]) {\n            if (arguments[i].hasOwnProperty(k)) {\n                o[k] = arguments[i][k].constructor === Object\n                    ? extend(o[k] || {}, arguments[i][k])\n                    : arguments[i][k];\n            }\n        }\n    }\n    return o;\n}\n</code></pre>\n<br />\n<h3>Example</h3>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>/**\n * Extend objects\n */\nfunction extend() {\n    for (var o = {}, i = 0; i &lt; arguments.length; i++) {\n        for (var k in arguments[i]) {\n            if (arguments[i].hasOwnProperty(k)) {\n                o[k] = arguments[i][k].constructor === Object\n                    ? extend(o[k] || {}, arguments[i][k])\n                    : arguments[i][k];\n            }\n        }\n    }\n    return o;\n}\n\n/**\n * Example\n */\ndocument.write(JSON.stringify(extend({\n    api: 1,\n    params: {\n        query: 'hello'\n    }\n}, {\n    params: {\n        query: 'there'\n    }\n})));\n// outputs {\"api\": 1, \"params\": {\"query\": \"there\"}}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<br />\n<p><em>This answer is now but a drop in the ocean ...</em></p>\n"},{"score":0,"body":"<p>We can crate a empty object, and combine them by <code>for-loop</code>:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var obj1 = {\r\n  id: '1',\r\n  name: 'name'\r\n}\r\n\r\nvar obj2 = {\r\n  c: 'c',\r\n  d: 'd'\r\n}\r\n\r\nvar obj3 = {}\r\n\r\nfor (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }\r\nfor (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }\r\n\r\n\r\nconsole.log( obj1, obj2, obj3)</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":8,"body":"<pre><code>var obj1 = { food: 'pizza', car: 'ford' }\nvar obj2 = { animal: 'dog' }\n\n// result\nresult: {food: \"pizza\", car: \"ford\", animal: \"dog\"}\n</code></pre>\n\n<p><strong>Using jQuery.extend()</strong> - <a href=\"https://api.jquery.com/jquery.extend/\" rel=\"noreferrer\">Link</a></p>\n\n<pre><code>// Merge obj1 &amp; obj2 to result\nvar result1 = $.extend( {}, obj1, obj2 );\n</code></pre>\n\n<p><strong>Using _.merge()</strong> - <a href=\"https://lodash.com/docs/4.17.10#merge\" rel=\"noreferrer\">Link</a></p>\n\n<pre><code>// Merge obj1 &amp; obj2 to result\nvar result2 = _.merge( {}, obj1, obj2 );\n</code></pre>\n\n<p><strong>Using _.extend()</strong> - <a href=\"https://underscorejs.org/#extend\" rel=\"noreferrer\">Link</a></p>\n\n<pre><code>// Merge obj1 &amp; obj2 to result\nvar result3 = _.extend( {}, obj1, obj2 );\n</code></pre>\n\n<p><strong>Using Object.assign() ECMAScript 2015 (ES6)</strong> - <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" rel=\"noreferrer\">Link</a></p>\n\n<pre><code>// Merge obj1 &amp; obj2 to result\nvar result4 = Object.assign( {}, obj1, obj2 );\n</code></pre>\n\n<p>Output of all</p>\n\n<pre><code>obj1: { animal: 'dog' }\nobj2: { food: 'pizza', car: 'ford' }\nresult1: {food: \"pizza\", car: \"ford\", animal: \"dog\"}\nresult2: {food: \"pizza\", car: \"ford\", animal: \"dog\"}\nresult3: {food: \"pizza\", car: \"ford\", animal: \"dog\"}\nresult4: {food: \"pizza\", car: \"ford\", animal: \"dog\"}\n</code></pre>\n"},{"score":0,"body":"<p>With the following helper, you can merge two objects into one new object:</p>\n\n<pre><code>function extend(obj, src) {\n    for (var key in src) {\n        if (src.hasOwnProperty(key)) obj[key] = src[key];\n    }\n    return obj;\n}\n\n// example\nvar a = { foo: true }, b = { bar: false };\nvar c = extend(a, b);\n\nconsole.log(c);\n// { foo: true, bar: false }\n</code></pre>\n\n<p>This is typically useful when merging an options dict with the default settings in a function or a plugin.</p>\n\n<p>If support for IE 8 is not required, you may use <code>Object.keys</code> for the same functionality instead:</p>\n\n<pre><code>function extend(obj, src) {\n    Object.keys(src).forEach(function(key) { obj[key] = src[key]; });\n    return obj;\n}\n</code></pre>\n\n<p>This involves slightly less code and is a bit faster.</p>\n"},{"score":5,"body":"<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>let obj1 = {a:1, b:2};\r\nlet obj2 = {c:3, d:4};\r\nlet merged = {...obj1, ...obj2};\r\nconsole.log(merged);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":4,"body":"<p>ES2018/TypeScript: Many answers are OK but I've come up with a more elegant solution to this problem when you need to merge two objects <strong>without overwriting overlapping object keys</strong>.</p>\n\n<p>My function also accepts <strong>unlimited number of objects</strong> to merge as function arguments:</p>\n\n<p><em>(I'm using TypeScript notation here, feel free to delete the <code>:object[]</code> type in the function argument if you're using plain JavaScript).</em></p>\n\n<pre><code>const merge = (...objects: object[]) =&gt; {\n  return objects.reduce((prev, next) =&gt; {\n    Object.keys(prev).forEach(key =&gt; {\n      next[key] = { ...next[key], ...prev[key] }\n    })\n    return next\n  })\n}\n</code></pre>\n"},{"score":1,"body":"<p><em>merge two object using <strong>Object.assign</strong> and <strong>spread operator.</em></strong></p>\n\n<p><strong>Wrong way(Modify original object because targeting o1)</strong></p>\n\n<pre><code>var o1 = { X: 10 };\nvar o2 = { Y: 20 };\nvar o3 = { Z: 30 };\nvar merge = Object.assign(o1, o2, o3);\nconsole.log(merge)  // {X:10, Y:20, Z:30}\nconsole.log(o1)     // {X:10, Y:20, Z:30}\n</code></pre>\n\n<p><strong>Right ways</strong></p>\n\n<ul>\n<li><p>Object.assign({}, o1, o2, o3) <strong>==></strong> targeting new object</p></li>\n<li><p>{...o1, ...o2, ...o3} <strong>==></strong> spreading objects</p></li>\n</ul>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var o1 = { X: 10 };\r\nvar o2 = { Y: 20 };\r\nvar o3 = { Z: 30 };\r\n\r\nconsole.log('Does not modify original objects because target {}');\r\nvar merge = Object.assign({}, o1, o2, o3);\r\nconsole.log(merge); // { X: 10, Y: 20, Z: 30 }\r\nconsole.log(o1)\r\n\r\nconsole.log('Does not modify original objects')\r\nvar spreadMerge = {...o1, ...o2, ...o3};\r\nconsole.log(spreadMerge);\r\nconsole.log(o1);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":2,"body":"<p>It seems like this should be all you need:</p>\n\n<pre><code>var obj1 = { food: 'pizza', car: 'ford' }\nvar obj2 = { animal: 'dog' }\n\nvar obj1 = { ...obj1, ...obj2 }\n</code></pre>\n\n<p>After that obj1 should now have the following value:</p>\n\n<pre><code>{food: \"pizza\", car: \"ford\", animal: \"dog\"}\n</code></pre>\n"},{"score":2,"body":"<p><strong>shallow</strong></p>\n\n<pre><code>var obj = { name : \"Jacob\" , address : [\"America\"] }\nvar obj2 = { name : \"Shaun\" , address : [\"Honk Kong\"] }\n\nvar merged = Object.assign({} , obj,obj2 ); //shallow merge \nobj2.address[0] = \"new city\"\n</code></pre>\n\n<p>result.address[0] is changed to \"new city\" , i.e merged object is also changed. This is the problem with shallow merge.</p>\n\n<p><strong>deep</strong></p>\n\n<pre><code>var obj = { name : \"Jacob\" , address : [\"America\"] }\nvar obj2 = { name : \"Shaun\" , address : [\"Honk Kong\"] }\n\nvar result = Object.assign({} , JSON.parse(JSON.stringify(obj)),JSON.parse(JSON.stringify(obj2)) )\n\nobj2.address[0] = \"new city\"\n</code></pre>\n\n<p>result.address[0] is not changed</p>\n"},{"score":2,"body":"<p>You can use <code>Object.assign</code> method. For example:</p>\n<pre><code>var result = Object.assign(obj1, obj2);\n</code></pre>\n<p>Also, note that it creates a shallow copy of the object.</p>\n"},{"score":4,"body":"<blockquote>\n  <p>Use Spread operator which follows the ES6 version</p>\n</blockquote>\n\n<pre><code>var obj1 = { food: 'pizza', car: 'ford' }\nvar obj2 = { animal: 'dog' }\nlet result = {...obj1,...obj2};\nconsole.log(result)\n\noutput { food: 'pizza', car: 'ford', animal: 'dog' }\n</code></pre>\n"},{"score":0,"body":"<p>There are different ways to achieve this:</p>\n<pre><code>Object.assign(targetObj, sourceObj);\n\ntargetObj = {...targetObj, ...sourceObj};\n</code></pre>\n"},{"score":0,"body":"<pre><code>Object.assign(TargetObject, Obj1, Obj2, ...);\n</code></pre>\n"}],"score":2655}