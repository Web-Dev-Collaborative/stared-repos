{"body":"<p>Usually I would expect a <code>String.contains()</code> method, but there doesn't seem to be one. </p>\n\n<p>What is a reasonable way to check for this?</p>\n","title":"How to check whether a string contains a substring in JavaScript?","answers":[{"score":14214,"body":"<p>ECMAScript&nbsp;6  introduced <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\" rel=\"noreferrer\"><code>String.prototype.includes</code></a>:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const string = \"foo\";\r\nconst substring = \"oo\";\r\n\r\nconsole.log(string.includes(substring));</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><code>includes</code> <a href=\"https://caniuse.com/#feat=es6-string-includes\" rel=\"noreferrer\">doesn’t have Internet&nbsp;Explorer support</a>, though. In ECMAScript&nbsp;5 or older environments, use <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf\" rel=\"noreferrer\"><code>String.prototype.indexOf</code></a>, which returns -1 when a substring cannot be found:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var string = \"foo\";\r\nvar substring = \"oo\";\r\n\r\nconsole.log(string.indexOf(substring) !== -1);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":602,"body":"<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\" rel=\"noreferrer\">There is a <code>String.prototype.includes</code> in ES6</a>:</p>\n\n<pre><code>\"potato\".includes(\"to\");\n&gt; true\n</code></pre>\n\n<p>Note that this <a href=\"https://caniuse.com/?v=1#feat=es6-string-includes\" rel=\"noreferrer\">does not work in Internet Explorer or some other old browsers</a> with no or incomplete ES6 support. To make it work in old browsers, you may wish to use a transpiler like <a href=\"https://babeljs.io/\" rel=\"noreferrer\">Babel</a>, a shim library like <a href=\"https://github.com/paulmillr/es6-shim\" rel=\"noreferrer\">es6-shim</a>, or this <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes#Polyfill\" rel=\"noreferrer\">polyfill from MDN</a>:</p>\n\n<pre><code>if (!String.prototype.includes) {\n  String.prototype.includes = function(search, start) {\n    'use strict';\n    if (typeof start !== 'number') {\n      start = 0;\n    }\n\n    if (start + search.length &gt; this.length) {\n      return false;\n    } else {\n      return this.indexOf(search, start) !== -1;\n    }\n  };\n}\n</code></pre>\n"},{"score":64,"body":"<p>Another alternative is <a href=\"https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm\" rel=\"noreferrer\">KMP</a> (Knuth–Morris–Pratt).</p>\n\n<p>The KMP algorithm searches for a length-<em>m</em> substring in a length-<em>n</em> string in worst-case O(<em>n</em>+<em>m</em>) time, compared to a worst-case of O(<em>n</em>⋅<em>m</em>) for the naive algorithm, so using KMP may be reasonable if you care about worst-case time complexity.</p>\n\n<p>Here's a JavaScript implementation by Project Nayuki, taken from <a href=\"https://www.nayuki.io/res/knuth-morris-pratt-string-matching/kmp-string-matcher.js\" rel=\"noreferrer\">https://www.nayuki.io/res/knuth-morris-pratt-string-matching/kmp-string-matcher.js</a>:</p>\n\n<pre><code>// Searches for the given pattern string in the given text string using the Knuth-Morris-Pratt string matching algorithm.\n// If the pattern is found, this returns the index of the start of the earliest match in 'text'. Otherwise -1 is returned.\n</code></pre>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function kmpSearch(pattern, text) {\r\n  if (pattern.length == 0)\r\n    return 0; // Immediate match\r\n\r\n  // Compute longest suffix-prefix table\r\n  var lsp = [0]; // Base case\r\n  for (var i = 1; i &lt; pattern.length; i++) {\r\n    var j = lsp[i - 1]; // Start by assuming we're extending the previous LSP\r\n    while (j &gt; 0 &amp;&amp; pattern.charAt(i) != pattern.charAt(j))\r\n      j = lsp[j - 1];\r\n    if (pattern.charAt(i) == pattern.charAt(j))\r\n      j++;\r\n    lsp.push(j);\r\n  }\r\n\r\n  // Walk through text string\r\n  var j = 0; // Number of chars matched in pattern\r\n  for (var i = 0; i &lt; text.length; i++) {\r\n    while (j &gt; 0 &amp;&amp; text.charAt(i) != pattern.charAt(j))\r\n      j = lsp[j - 1]; // Fall back in the pattern\r\n    if (text.charAt(i) == pattern.charAt(j)) {\r\n      j++; // Next char matched, increment position\r\n      if (j == pattern.length)\r\n        return i - (j - 1);\r\n    }\r\n  }\r\n  return -1; // Not found\r\n}\r\n\r\nconsole.log(kmpSearch('ays', 'haystack') != -1) // true\r\nconsole.log(kmpSearch('asdf', 'haystack') != -1) // false</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"}],"score":7423}