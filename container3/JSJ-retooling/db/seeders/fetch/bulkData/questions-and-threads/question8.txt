{"body":"<p>Say I create an object as follows:</p>\n<pre><code>let myObject = {\n  &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,\n  &quot;method&quot;: &quot;newURI&quot;,\n  &quot;regex&quot;: &quot;^http://.*&quot;\n};\n</code></pre>\n<p>What is the best way to remove the property <code>regex</code> to end up with new <code>myObject</code> as follows?</p>\n<pre><code>let myObject = {\n  &quot;ircEvent&quot;: &quot;PRIVMSG&quot;,\n  &quot;method&quot;: &quot;newURI&quot;\n};\n</code></pre>\n","title":"How do I remove a property from a JavaScript object?","answers":[{"score":8566,"body":"<p>Like this:</p>\n\n<pre><code>delete myObject.regex;\n// or,\ndelete myObject['regex'];\n// or,\nvar prop = \"regex\";\ndelete myObject[prop];\n</code></pre>\n\n<p>Demo\n<div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var myObject = {\r\n    \"ircEvent\": \"PRIVMSG\",\r\n    \"method\": \"newURI\",\r\n    \"regex\": \"^http://.*\"\r\n};\r\ndelete myObject.regex;\r\n\r\nconsole.log(myObject);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>For anyone interested in reading more about it, Stack Overflow user <a href=\"https://stackoverflow.com/users/130652/kangax\">kangax</a> has written an incredibly in-depth blog post about the <code>delete</code> statement on their blog, <em><a href=\"http://perfectionkills.com/understanding-delete/\" rel=\"noreferrer\">Understanding delete</a></em>. It is highly recommended.</p>\n"},{"score":264,"body":"<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var myObject = {\"ircEvent\": \"PRIVMSG\", \"method\": \"newURI\", \"regex\": \"^http://.*\"};\r\n    \r\ndelete myObject.regex;\r\n\r\nconsole.log ( myObject.regex); // logs: undefined</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>This works in Firefox and Internet&nbsp;Explorer, and I think it works in all others.</p>\n"},{"score":237,"body":"<p>The <code>delete</code> operator is used to remove properties from objects.</p>\n\n<pre><code>const obj = { foo: \"bar\" }\ndelete obj.foo\nobj.hasOwnProperty(\"foo\") // false\n</code></pre>\n\n<p>Note that, for arrays, <strong>this is not the same as removing an element</strong>. To remove an element from an array, use <code>Array#splice</code> or <code>Array#pop</code>. For example:</p>\n\n<pre><code>arr // [0, 1, 2, 3, 4]\narr.splice(3,1); // 3\narr // [0, 1, 2, 4]\n</code></pre>\n\n<h1>Details</h1>\n\n<p><code>delete</code> in JavaScript has a different function to that of the keyword in C and C++: it does not directly free memory. Instead, its sole purpose is to remove properties from objects.</p>\n\n<p>For arrays, deleting a property corresponding to an index, creates a sparse array (ie. an array with a \"hole\" in it). Most browsers represent these missing array indices as \"empty\".</p>\n\n<pre><code>var array = [0, 1, 2, 3]\ndelete array[2] // [0, 1, empty, 3]\n</code></pre>\n\n<p>Note that <code>delete</code> does not relocate <code>array[3]</code> into <code>array[2]</code>.</p>\n\n<p>Different built-in functions in JavaScript handle sparse arrays differently.</p>\n\n<ul>\n<li><p><code>for...in</code> will skip the empty index completely. </p></li>\n<li><p>A traditional <code>for</code> loop will return <code>undefined</code> for the value at the index.</p></li>\n<li><p>Any method using <code>Symbol.iterator</code> will return <code>undefined</code> for the value at the index.</p></li>\n<li><p><code>forEach</code>, <code>map</code> and <code>reduce</code> will simply skip the missing index.</p></li>\n</ul>\n\n<p>So, the <code>delete</code> operator should not be used for the common use-case of removing elements from an array. Arrays have a dedicated methods for removing elements and reallocating memory: <code>Array#splice()</code> and <code>Array#pop</code>.</p>\n\n<h2>Array#splice(start[, deleteCount[, item1[, item2[, ...]]]])</h2>\n\n<p><code>Array#splice</code> mutates the array, and returns any removed indices. <code>deleteCount</code> elements are removed from index <code>start</code>, and <code>item1, item2... itemN</code> are inserted into the array from index <code>start</code>. If <code>deleteCount</code> is omitted then elements from startIndex are removed to the end of the array.</p>\n\n<pre><code>let a = [0,1,2,3,4]\na.splice(2,2) // returns the removed elements [2,3]\n// ...and `a` is now [0,1,4]\n</code></pre>\n\n<p>There is also a similarly named, but different, function on <code>Array.prototype</code>: <code>Array#slice</code>.</p>\n\n<h2>Array#slice([begin[, end]])</h2>\n\n<p><code>Array#slice</code> is non-destructive, and returns a new array containing the indicated indices from <code>start</code> to <code>end</code>. If <code>end</code> is left unspecified, it defaults to the end of the array. If <code>end</code> is positive, it specifies the zero-based <strong>non-inclusive</strong> index to stop at. If <code>end</code> is negative it, it specifies the index to stop at by counting back from the end of the array (eg. -1 will omit the final index). If <code>end &lt;= start</code>, the result is an empty array.</p>\n\n<pre><code>let a = [0,1,2,3,4]\nlet slices = [\n    a.slice(0,2),\n    a.slice(2,2),\n    a.slice(2,3),\n    a.slice(2,5) ]\n\n//   a           [0,1,2,3,4]\n//   slices[0]   [0 1]- - -   \n//   slices[1]    - - - - -\n//   slices[2]    - -[3]- -\n//   slices[3]    - -[2 4 5]\n</code></pre>\n\n<h1>Array#pop</h1>\n\n<p><code>Array#pop</code> removes the last element from an array, and returns that element. This operation changes the length of the array.</p>\n"},{"score":58,"body":"<p>The term you have used in your question title <code>Remove a property from a JavaScript object</code>, can be interpreted in some different ways. The one is to remove it for whole the memory and the list of object keys or the other is just to remove it from your object. As it has been mentioned in some other answers, the <code>delete</code> keyword is the main part. Let's say you have your object like:</p>\n\n<pre><code>myJSONObject = {\"ircEvent\": \"PRIVMSG\", \"method\": \"newURI\", \"regex\": \"^http://.*\"};\n</code></pre>\n\n<p>If you do:</p>\n\n<pre><code>console.log(Object.keys(myJSONObject));\n</code></pre>\n\n<p>the result would be:</p>\n\n<pre><code>[\"ircEvent\", \"method\", \"regex\"]\n</code></pre>\n\n<p>You can delete that specific key from your object keys like:</p>\n\n<pre><code>delete myJSONObject[\"regex\"];\n</code></pre>\n\n<p>Then your objects key using <code>Object.keys(myJSONObject)</code> would be:</p>\n\n<pre><code>[\"ircEvent\", \"method\"]\n</code></pre>\n\n<p>But the point is if you care about memory and you want to whole the object gets removed from the memory, it is recommended to set it to null before you delete the key:</p>\n\n<pre><code>myJSONObject[\"regex\"] = null;\ndelete myJSONObject[\"regex\"];\n</code></pre>\n\n<p>The other important point here is to be careful about your other references to the same object. For instance, if you create a variable like:</p>\n\n<pre><code>var regex = myJSONObject[\"regex\"];\n</code></pre>\n\n<p>Or add it as a new pointer to another object like:</p>\n\n<pre><code>var myOtherObject = {};\nmyOtherObject[\"regex\"] = myJSONObject[\"regex\"];\n</code></pre>\n\n<p>Then even if you remove it from your object <code>myJSONObject</code>, that specific object won't get deleted from the memory, since the <code>regex</code> variable and <code>myOtherObject[\"regex\"]</code> still have their values. Then how could we remove the object from the memory for sure?</p>\n\n<p>The answer would be to <strong>delete all the references you have in your code, pointed to that very object</strong> and also <strong>not use <code>var</code> statements to create new references to that object</strong>. This last point regarding <code>var</code> statements, is one of the most crucial issues that we are usually faced with, because using <code>var</code> statements would prevent the created object from getting removed.</p>\n\n<p>Which means in this case you won't be able to remove that object because you have created the <code>regex</code> variable via a <code>var</code> statement, and if you do:</p>\n\n<pre><code>delete regex; //False\n</code></pre>\n\n<p>The result would be <code>false</code>, which means that your delete statement haven't been executed as you expected. But if you had not created that variable before, and you only had <code>myOtherObject[\"regex\"]</code> as your last existing reference, you could have done this just by removing it like:</p>\n\n<pre><code>myOtherObject[\"regex\"] = null;\ndelete myOtherObject[\"regex\"];\n</code></pre>\n\n<p><strong>In other words, a JavaScript object gets killed as soon as there is no reference left in your code pointed to that object.</strong></p>\n\n<hr>\n\n<p><strong>Update:</strong>\nThanks to @AgentME:</p>\n\n<blockquote>\n  <p>Setting a property to null before deleting it doesn't accomplish\n  anything (unless the object has been sealed by Object.seal and the\n  delete fails. That's not usually the case unless you specifically\n  try).</p>\n</blockquote>\n\n<p>To get more info on <code>Object.seal</code>: <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal\" rel=\"noreferrer\">Object.seal()</a></p>\n"},{"score":982,"body":"<p>Objects in JavaScript can be thought of as maps between keys and values. The <code>delete</code> operator is used to remove these keys, more commonly known as object properties, one at a time.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var obj = {\r\n  myProperty: 1    \r\n}\r\nconsole.log(obj.hasOwnProperty('myProperty')) // true\r\ndelete obj.myProperty\r\nconsole.log(obj.hasOwnProperty('myProperty')) // false</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>The <code>delete</code> operator does not directly free memory, and it differs from simply assigning the value of <code>null</code> or <code>undefined</code> to a property, in that the property <em>itself</em> is removed from the object. Note that if the <em>value</em> of a deleted property was a reference type (an object), and another part of your program still holds a reference to that object, then that object will, of course, not be garbage collected until all references to it have disappeared.</p>\n\n<p><code>delete</code> will only work on properties whose descriptor marks them as configurable.</p>\n"},{"score":102,"body":"<p>Another alternative is to use the <a href=\"https://underscorejs.org\" rel=\"noreferrer\">Underscore.js</a> library. </p>\n\n<p>Note that <code>_.pick()</code> and <code>_.omit()</code> both return a copy of the object and don't directly modify the original object. Assigning the result to the original object should do the trick (not shown).</p>\n\n<p>Reference: <a href=\"http://underscorejs.org/#pick\" rel=\"noreferrer\">link</a> <strong>_.pick(object, *keys)</strong></p>\n\n<p>Return a copy of the object, filtered to only have values for the \nwhitelisted keys (or array of valid keys).</p>\n\n<pre><code>var myJSONObject = \n{\"ircEvent\": \"PRIVMSG\", \"method\": \"newURI\", \"regex\": \"^http://.*\"};\n\n_.pick(myJSONObject, \"ircEvent\", \"method\");\n=&gt; {\"ircEvent\": \"PRIVMSG\", \"method\": \"newURI\"};\n</code></pre>\n\n<p>Reference: <a href=\"http://underscorejs.org/#omit\" rel=\"noreferrer\">link</a> <strong>_.omit(object, *keys)</strong></p>\n\n<p>Return a copy of the object, filtered to omit the \nblacklisted keys (or array of keys).</p>\n\n<pre><code>var myJSONObject = \n{\"ircEvent\": \"PRIVMSG\", \"method\": \"newURI\", \"regex\": \"^http://.*\"};\n\n_.omit(myJSONObject, \"regex\");\n=&gt; {\"ircEvent\": \"PRIVMSG\", \"method\": \"newURI\"};\n</code></pre>\n\n<p>For arrays, <code>_.filter()</code> and <code>_.reject()</code> can be used in a similar manner. </p>\n"},{"score":22,"body":"<p>There are a lot of good answers here but I just want to chime in that when using delete to remove a property in JavaScript, it is often wise to first check if that property exists to prevent errors.</p>\n\n<p>E.g</p>\n\n<pre><code>var obj = {\"property\":\"value\", \"property2\":\"value\"};\n\nif (obj &amp;&amp; obj.hasOwnProperty(\"property2\")) {\n  delete obj.property2;\n} else {\n  //error handling\n}\n</code></pre>\n\n<p>Due to the dynamic nature of JavaScript there are often cases where you simply don't know if the property exists or not. Checking if obj exists before the &amp;&amp; also makes sure you don't throw an error due to calling the hasOwnProperty() function on an undefined object.</p>\n\n<p>Sorry if this didn't add to your specific use case but I believe this to be a good design to adapt when managing objects and their properties.</p>\n"},{"score":22,"body":"<p>This post is very old and I find it very helpful so I decided to share the unset function I wrote in case someone else see this post and think why it's not so simple as it in PHP unset function.</p>\n\n<p>The reason for writing this new <code>unset</code> function, is to keep the index of all other variables in this hash_map. Look at the following example, and see how the index of \"test2\" did not change after removing a value from the hash_map.</p>\n\n<pre><code>function unset(unsetKey, unsetArr, resort){\n  var tempArr = unsetArr;\n  var unsetArr = {};\n  delete tempArr[unsetKey];\n  if(resort){\n    j = -1;\n  }\n  for(i in tempArr){\n    if(typeof(tempArr[i]) !== 'undefined'){\n      if(resort){\n        j++;\n      }else{\n        j = i;\n      }\n      unsetArr[j] = tempArr[i];\n    }\n  }\n  return unsetArr;\n}\n\nvar unsetArr = ['test','deletedString','test2'];\n\nconsole.log(unset('1',unsetArr,true)); // output Object {0: \"test\", 1: \"test2\"}\nconsole.log(unset('1',unsetArr,false)); // output Object {0: \"test\", 2: \"test2\"}\n</code></pre>\n"},{"score":46,"body":"<p>ECMAScript 2015 (or ES6) came with built-in <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\">Reflect</a> object. It is possible to delete object property by calling <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/deleteProperty\">Reflect.deleteProperty()</a> function with target object and property key as parameters:</p>\n\n<pre><code>Reflect.deleteProperty(myJSONObject, 'regex');\n</code></pre>\n\n<p>which is equivalent to:</p>\n\n<pre><code>delete myJSONObject['regex'];\n</code></pre>\n\n<p>But if the property of the object is not configurable it cannot be deleted neither with deleteProperty function nor delete operator:</p>\n\n<pre><code>let obj = Object.freeze({ prop: \"value\" });\nlet success = Reflect.deleteProperty(obj, \"prop\");\nconsole.log(success); // false\nconsole.log(obj.prop); // value\n</code></pre>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">Object.freeze()</a> makes all properties of object not configurable (besides other things). <code>deleteProperty</code> function (as well as <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete\">delete operator</a>) returns <code>false</code> when tries to delete any of it's properties. If property is configurable it returns <code>true</code>, even if property does not exist.</p>\n\n<p>The difference between <code>delete</code> and <code>deleteProperty</code> is when using strict mode:</p>\n\n<pre><code>\"use strict\";\n\nlet obj = Object.freeze({ prop: \"value\" });\nReflect.deleteProperty(obj, \"prop\"); // false\ndelete obj[\"prop\"];\n// TypeError: property \"prop\" is non-configurable and can't be deleted\n</code></pre>\n"},{"score":34,"body":"<p>I personally use <a href=\"https://en.wikipedia.org/wiki/Underscore.js\" rel=\"noreferrer\">Underscore.js</a> or <a href=\"https://lodash.com\" rel=\"noreferrer\">Lodash</a> for object and array manipulation:</p>\n\n<pre><code>myObject = _.omit(myObject, 'regex');\n</code></pre>\n"},{"score":44,"body":"<p>Suppose you have an object that looks like this:</p>\n\n<pre><code>var Hogwarts = {\n    staff : [\n        'Argus Filch',\n        'Filius Flitwick',\n        'Gilderoy Lockhart',\n        'Minerva McGonagall',\n        'Poppy Pomfrey',\n        ...\n    ],\n    students : [\n        'Hannah Abbott',\n        'Katie Bell',\n        'Susan Bones',\n        'Terry Boot',\n        'Lavender Brown',\n        ...\n    ]\n};\n</code></pre>\n\n<h3>Deleting an object property</h3>\n\n<p>If you want to use the entire <code>staff</code> array, the proper way to do this, would be to do this:</p>\n\n<pre><code>delete Hogwarts.staff;\n</code></pre>\n\n<p>Alternatively, you could also do this:</p>\n\n<pre><code>delete Hogwarts['staff'];\n</code></pre>\n\n<p>Similarly, removing the entire students array would be done by calling <code>delete Hogwarts.students;</code> or <code>delete Hogwarts['students'];</code>.</p>\n\n<h3>Deleting an array index</h3>\n\n<p>Now, if you want to remove a single staff member or student, the procedure is a bit different, because both properties are arrays themselves.</p>\n\n<p>If you know the index of your staff member, you could simply do this:</p>\n\n<pre><code>Hogwarts.staff.splice(3, 1);\n</code></pre>\n\n<p>If you do not know the index, you'll also have to do an index search:</p>\n\n<pre><code>Hogwarts.staff.splice(Hogwarts.staff.indexOf('Minerva McGonnagall') - 1, 1);\n</code></pre>\n\n<hr>\n\n<h3>Note</h3>\n\n<p>While you technically can use <code>delete</code> for an array, using it would result in getting incorrect results when calling for example <code>Hogwarts.staff.length</code> later on. In other words, <code>delete</code> would remove the element, but it wouldn't update the value of <code>length</code> property. Using <code>delete</code> would also mess up your indexing.</p>\n\n<p>So, when deleting values from an object, always first consider whether you're dealing with object properties or whether you're dealing with array values, and choose the appropriate strategy based on that.</p>\n\n<p>If you want to experiment with this, you can use <a href=\"http://jsfiddle.net/cb57dusv/46/\"><strong>this Fiddle</strong></a> as a starting point.</p>\n"},{"score":13,"body":"<p>If you want to delete a property deeply nested in the object then you can use the following recursive function with path to the property as the second argument:</p>\n\n<pre><code>var deepObjectRemove = function(obj, path_to_key){\n    if(path_to_key.length === 1){\n        delete obj[path_to_key[0]];\n        return true;\n    }else{\n        if(obj[path_to_key[0]])\n            return deepObjectRemove(obj[path_to_key[0]], path_to_key.slice(1));\n        else\n            return false;\n    }\n};\n</code></pre>\n\n<p>Example: </p>\n\n<pre><code>var a = {\n    level1:{\n        level2:{\n            level3: {\n                level4: \"yolo\"\n            }\n        }\n    }\n};\n\ndeepObjectRemove(a, [\"level1\", \"level2\", \"level3\"]);\nconsole.log(a);\n\n//Prints {level1: {level2: {}}}\n</code></pre>\n"},{"score":16,"body":"<p>Try the following method. Assign the <code>Object</code> property value to <code>undefined</code>. Then <code>stringify</code> the object and <code>parse</code>.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code> var myObject = {\"ircEvent\": \"PRIVMSG\", \"method\": \"newURI\", \"regex\": \"^http://.*\"};\r\n\r\nmyObject.regex = undefined;\r\nmyObject = JSON.parse(JSON.stringify(myObject));\r\n\r\nconsole.log(myObject);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":227,"body":"<p>Old question, modern answer. Using object destructuring, an <a href=\"https://en.wikipedia.org/wiki/ECMAScript#6th_Edition_-_ECMAScript_2015\">ECMAScript&nbsp;6</a> feature, it's as simple as:</p>\n\n<pre><code>const { a, ...rest } = { a: 1, b: 2, c: 3 };\n</code></pre>\n\n<p>Or with the questions sample:</p>\n\n<pre><code>const myObject = {\"ircEvent\": \"PRIVMSG\", \"method\": \"newURI\", \"regex\": \"^http://.*\"};\nconst { regex, ...newObject } = myObject;\nconsole.log(newObject);\n</code></pre>\n\n<p><a href=\"https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=true&amp;presets=es2015%2Cstage-0&amp;experimental=true&amp;loose=true&amp;spec=false&amp;code=const%20myObject%20%3D%20%7B%22ircEvent%22%3A%20%22PRIVMSG%22%2C%20%22method%22%3A%20%22newURI%22%2C%20%22regex%22%3A%20%22%5Ehttp%3A%2F%2F.*%22%7D%3B%0Aconst%20%7B%20regex%2C%20...newObject%20%7D%20%3D%20myObject%3B%0Aconsole.log(newObject)%3B\">You can see it in action in the Babel try-out editor.</a></p>\n\n<hr>\n\n<p><strong>Edit:</strong></p>\n\n<p>To reassign to the same variable, use a <code>let</code>:</p>\n\n<pre><code>let myObject = {\"ircEvent\": \"PRIVMSG\", \"method\": \"newURI\", \"regex\": \"^http://.*\"};\n({ regex, ...myObject } = myObject);\nconsole.log(myObject);\n</code></pre>\n"},{"score":17,"body":"<p>Using <a href=\"http://ramdajs.com/docs/#dissoc\" rel=\"noreferrer\">ramda#dissoc</a> you will get a new object without the attribute <code>regex</code>:</p>\n\n<pre><code>const newObject = R.dissoc('regex', myObject);\n// newObject !== myObject\n</code></pre>\n\n<p>You can also use other functions to achieve the same effect - omit, pick, ...</p>\n"},{"score":25,"body":"<p>Another solution, using <strong><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\" rel=\"noreferrer\"><code>Array#reduce</code></a></strong>.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var myObject = {\r\n  \"ircEvent\": \"PRIVMSG\",\r\n  \"method\": \"newURI\",\r\n  \"regex\": \"^http://.*\"\r\n};\r\n\r\nmyObject = Object.keys(myObject).reduce(function(obj, key) {\r\n  if (key != \"regex\") {           //key you want to remove\r\n    obj[key] = myObject[key];\r\n  }\r\n  return obj;\r\n}, {});\r\n\r\nconsole.log(myObject);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>However, it will <strong>mutate</strong> the original object. If you want to create a new object <strong>without</strong> the specified key, just assign the reduce function to a new variable, e.g.: </p>\n\n<p>(ES6)</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const myObject = {\r\n  ircEvent: 'PRIVMSG',\r\n  method: 'newURI',\r\n  regex: '^http://.*',\r\n};\r\n\r\nconst myNewObject = Object.keys(myObject).reduce((obj, key) =&gt; {\r\n  key !== 'regex' ? obj[key] = myObject[key] : null;\r\n  return obj;\r\n}, {});\r\n\r\nconsole.log(myNewObject);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":28,"body":"<p>Using <strong>delete</strong> method is the best way to do that, as per MDN description, the delete operator removes a property from an object. So you can simply write:</p>\n\n<pre><code>delete myObject.regex;\n// OR\ndelete myObject['regex'];\n</code></pre>\n\n<blockquote>\n  <p>The delete operator removes a given property from an object. On\n  successful deletion, it will return true, else false will be returned.\n  However, it is important to consider the following scenarios:</p>\n  \n  <ul>\n  <li><p>If the property which you are trying to delete does not exist, delete\n  will not have any effect and will return true</p></li>\n  <li><p>If a property with the same name exists on the object's prototype\n  chain, then, after deletion, the object will use the property from the\n  prototype chain (in other words, delete only has an effect on own\n  properties).</p></li>\n  <li><p>Any property declared with var cannot be deleted from the global scope\n  or from a function's scope.</p></li>\n  <li><p>As such, delete cannot delete any functions in the global scope (whether this is part from a function definition or a function  (expression). </p></li>\n  <li><p>Functions which are part of an object (apart from the<br>\n  global scope) can be deleted with delete.</p></li>\n  <li><p>Any property declared with let or const cannot be deleted from the scope  within which they were defined. Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are created as non-configurable with methods like Object.defineProperty().</p></li>\n  </ul>\n</blockquote>\n\n<p>The following snippet gives another simple example:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var Employee = {\r\n      age: 28,\r\n      name: 'Alireza',\r\n      designation: 'developer'\r\n    }\r\n    \r\n    console.log(delete Employee.name);   // returns true\r\n    console.log(delete Employee.age);    // returns true\r\n    \r\n    // When trying to delete a property that does \r\n    // not exist, true is returned \r\n    console.log(delete Employee.salary); // returns true</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>For more info about and seeing more example, visit the link below:</p>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete\" rel=\"noreferrer\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete</a></p>\n"},{"score":9,"body":"<p>Dan's assertion that 'delete' is very slow and the benchmark he posted were doubted. So I carried out the test myself in Chrome 59. It does seem that 'delete' is about 30 times slower:</p>\n\n<pre><code>var iterationsTotal = 10000000;  // 10 million\nvar o;\nvar t1 = Date.now(),t2;\nfor (let i=0; i&lt;iterationsTotal; i++) {\n   o = {a:1,b:2,c:3,d:4,e:5};\n   delete o.a; delete o.b; delete o.c; delete o.d; delete o.e;\n}\nconsole.log ((t2=Date.now())-t1);  // 6135\nfor (let i=0; i&lt;iterationsTotal; i++) {\n   o = {a:1,b:2,c:3,d:4,e:5};\n   o.a = o.b = o.c = o.d = o.e = undefined;\n}\nconsole.log (Date.now()-t2);  // 205\n</code></pre>\n\n<p>Note that I purposedly carried out more than one 'delete' operations in one loop cycle to minimize the effect caused by the other operations.</p>\n"},{"score":8,"body":"<p>Using lodash</p>\n\n<pre><code>import omit from 'lodash/omit';\n\nconst prevObject = {test: false, test2: true};\n// Removes test2 key from previous object\nconst nextObject = omit(prevObject, 'test2');\n</code></pre>\n\n<p>Using Ramda</p>\n\n<pre><code>R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=&gt; {b: 2, c: 3}\n</code></pre>\n"},{"score":8,"body":"<h1>Object.assign() &amp; Object.keys() &amp; Array.map()</h1>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"true\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const obj = {\r\n    \"Filters\":[\r\n        {\r\n            \"FilterType\":\"between\",\r\n            \"Field\":\"BasicInformationRow.A0\",\r\n            \"MaxValue\":\"2017-10-01\",\r\n            \"MinValue\":\"2017-09-01\",\r\n            \"Value\":\"Filters value\"\r\n        }\r\n    ]\r\n};\r\n\r\nlet new_obj1 = Object.assign({}, obj.Filters[0]);\r\nlet new_obj2 = Object.assign({}, obj.Filters[0]);\r\n\r\n/*\r\n\r\n// old version\r\n\r\nlet shaped_obj1 = Object.keys(new_obj1).map(\r\n    (key, index) =&gt; {\r\n        switch (key) {\r\n            case \"MaxValue\":\r\n                delete new_obj1[\"MaxValue\"];\r\n                break;\r\n            case \"MinValue\":\r\n                delete new_obj1[\"MinValue\"];\r\n                break;\r\n        }\r\n        return new_obj1;\r\n    }\r\n)[0];\r\n\r\n\r\nlet shaped_obj2 = Object.keys(new_obj2).map(\r\n    (key, index) =&gt; {\r\n        if(key === \"Value\"){\r\n            delete new_obj2[\"Value\"];\r\n        }\r\n        return new_obj2;\r\n    }\r\n)[0];\r\n\r\n\r\n*/\r\n\r\n\r\n// new version!\r\n\r\nlet shaped_obj1 = Object.keys(new_obj1).forEach(\r\n    (key, index) =&gt; {\r\n        switch (key) {\r\n            case \"MaxValue\":\r\n                delete new_obj1[\"MaxValue\"];\r\n                break;\r\n            case \"MinValue\":\r\n                delete new_obj1[\"MinValue\"];\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n);\r\n\r\nlet shaped_obj2 = Object.keys(new_obj2).forEach(\r\n    (key, index) =&gt; {\r\n        if(key === \"Value\"){\r\n            delete new_obj2[\"Value\"];\r\n        }\r\n    }\r\n);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":5,"body":"<p>I have used <a href=\"https://lodash.com/docs/4.17.4#unset\" rel=\"noreferrer\">lodash \"unset\"</a> to make it happen for nested object also.. only this need to write small logic to get path of property key which expected by omit method.  </p>\n\n<ol>\n<li>Method which returns property path as array </li>\n</ol>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var a = {\"bool\":{\"must\":[{\"range\":{\"price_index.final_price\":{\"gt\":\"450\",\"lt\":\"500\"}}},{\"bool\":{\"should\":[{\"term\":{\"color_value.keyword\":\"Black\"}}]}}]}};\r\n\r\nfunction getPathOfKey(object,key,currentPath, t){\r\n     var currentPath = currentPath || [];\r\n\r\n    for(var i in object){\r\n\t\tif(i == key){\r\n        t = currentPath;\r\n      }\r\n      else if(typeof object[i] == \"object\"){\r\n        currentPath.push(i)\r\n       return getPathOfKey(object[i], key,currentPath)\r\n      }\r\n    }\r\n\tt.push(key);\r\n    return t;\r\n}\r\ndocument.getElementById(\"output\").innerHTML =JSON.stringify(getPathOfKey(a,\"price_index.final_price\"))</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;div id=\"output\"&gt; \r\n\r\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<ol>\n<li>Then just using <a href=\"https://lodash.com/docs/4.17.4#unset\" rel=\"noreferrer\">lodash unset</a> method remove property from object. </li>\n</ol>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var unset = require('lodash.unset');\r\nunset(a,getPathOfKey(a,\"price_index.final_price\"));</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":9,"body":"<h1>Property Removal in JavaScript</h1>\n\n<p>There are many different options presented on this page, not because most of the options are wrong—or because the answers are duplicates—but because the appropriate technique depends on the situation you're in and the goals of the tasks you and/or you team are trying to fulfill. To answer you question unequivocally, one needs to know:</p>\n\n<ol>\n<li>The version of ECMAScript you're targeting</li>\n<li>The range of object types you want to remove properties on and the type of property names you need to be able to omit (Strings only? Symbols? Weak references mapped from arbitrary objects? These have all been types of property pointers in JavaScript for years now)</li>\n<li>The programming ethos/patterns you and your team use. Do you favor functional approaches and mutation is verboten on your team, or do you employ wild west mutative object-oriented techniques?</li>\n<li>Are you looking to achieve this in pure JavaScript or are you willing &amp; able to use a 3rd-party library?</li>\n</ol>\n\n<p>Once those four queries have been answered, there are essentially four categories of \"property removal\" in JavaScript to chose from in order to meet your goals. They are:</p>\n\n<h2>Mutative object property deletion, unsafe</h2>\n\n<p>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference and aren't using stateless functional principles in your code. An example piece of syntax in this category:</p>\n\n<pre><code>'use strict'\nconst iLikeMutatingStuffDontI = { myNameIs: 'KIDDDDD!', [Symbol.for('amICool')]: true }\ndelete iLikeMutatingStuffDontI[Symbol.for('amICool')] // true\nObject.defineProperty({ myNameIs: 'KIDDDDD!', 'amICool', { value: true, configurable: false })\ndelete iLikeMutatingStuffDontI['amICool'] // throws\n</code></pre>\n\n<p>This category is the oldest, most straightforward &amp; most widely supported category of property removal. It supports <code>Symbol</code> &amp; array indexes in addition to strings and works in every version of JavaScript except for the very first release. However, it's mutative which violates some programming principles and has performance implications. It also can result in uncaught exceptions when used on <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete\" rel=\"noreferrer\">non-configurable properties in strict mode</a>.</p>\n\n<h2>Rest-based string property omission</h2>\n\n<p>This category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don't need to account for Symbol keys:</p>\n\n<pre><code>const foo = { name: 'KIDDDDD!', [Symbol.for('isCool')]: true }\nconst { name, ...coolio } = foo // coolio doesn't have \"name\"\nconst { isCool, ...coolio2 } = foo // coolio2 has everything from `foo` because `isCool` doesn't account for Symbols :(\n</code></pre>\n\n<h2>Mutative object property deletion, safe</h2>\n\n<p>This category is for operating on object literals or object instances when you want to retain/continue to use the original reference while guarding against exceptions being thrown on unconfigurable properties:</p>\n\n<pre><code>'use strict'\nconst iLikeMutatingStuffDontI = { myNameIs: 'KIDDDDD!', [Symbol.for('amICool')]: true }\nReflect.deleteProperty(iLikeMutatingStuffDontI, Symbol.for('amICool')) // true\nObject.defineProperty({ myNameIs: 'KIDDDDD!', 'amICool', { value: true, configurable: false })\nReflect.deleteProperty(iLikeMutatingStuffDontI, 'amICool') // false\n</code></pre>\n\n<p>In addition, while mutating objects in-place isn't stateless, you can use the functional nature of <code>Reflect.deleteProperty</code> to do partial application and other functional techniques that aren't possible with <code>delete</code> statements.</p>\n\n<h2>Syntax-based string property omission</h2>\n\n<p>This category is for operating on plain object or array instances in newer ECMAScript flavors when a non-mutative approach is desired and you don't need to account for Symbol keys:</p>\n\n<pre><code>const foo = { name: 'KIDDDDD!', [Symbol.for('isCool')]: true }\nconst { name, ...coolio } = foo // coolio doesn't have \"name\"\nconst { isCool, ...coolio2 } = foo // coolio2 has everything from `foo` because `isCool` doesn't account for Symbols :(\n</code></pre>\n\n<h2>Library-based property omission</h2>\n\n<p>This category is generally allows for greater functional flexibility, including accounting for Symbols &amp; omitting more than one property in one statement:</p>\n\n<pre><code>const o = require(\"lodash.omit\")\nconst foo = { [Symbol.for('a')]: 'abc', b: 'b', c: 'c' }\nconst bar = o(foo, 'a') // \"'a' undefined\"\nconst baz = o(foo, [ Symbol.for('a'), 'b' ]) // Symbol supported, more than one prop at a time, \"Symbol.for('a') undefined\"\n</code></pre>\n"},{"score":7,"body":"<p><strong>@johnstock</strong>, we can also use JavaScript's prototyping concept to add method to objects to delete any passed key available in calling object.</p>\n\n<p>Above answers are appreciated.</p>\n\n<pre><code>var myObject = {\n    \"ircEvent\": \"PRIVMSG\",\n    \"method\": \"newURI\",\n    \"regex\": \"^http://.*\"\n};\n\n// 1st and direct way \ndelete myObject.regex;  // delete myObject[\"regex\"]\nconsole.log(myObject); // { ircEvent: 'PRIVMSG', method: 'newURI' }\n\n // 2 way -  by using the concept of JavaScript's prototyping concept\nObject.prototype.removeFromObjectByKey = function(key) {\n     // If key exists, remove it and return true\n     if(this[key] !== undefined) {\n           delete this[key]\n           return true;\n     }\n     // Else return false\n     return false;\n}\n\nvar isRemoved = myObject.removeFromObjectByKey('method')\nconsole.log(myObject)  // { ircEvent: 'PRIVMSG' }\n\n// More examples\nvar obj = { a: 45, b: 56, c: 67}\nconsole.log(obj) // { a: 45, b: 56, c: 67 }\n\n// Remove key 'a' from obj\nisRemoved = obj.removeFromObjectByKey('a')\nconsole.log(isRemoved); //true\nconsole.log(obj); // { b: 56, c: 67 }\n\n// Remove key 'd' from obj which doesn't exist\nvar isRemoved = obj.removeFromObjectByKey('d')\nconsole.log(isRemoved); // false\nconsole.log(obj); // { b: 56, c: 67 }\n</code></pre>\n"},{"score":152,"body":"<h1><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\" rel=\"noreferrer\">Spread Syntax</a> (ES6)</h1>\n\n<p>To whoever needs it...</p>\n\n<p>To complete @Koen answer in this thread, in case you want to remove dynamic variable using the spread syntax, you can do it like so:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const key = 'a';\r\n        \r\nconst { [key]: foo, ...rest } = { a: 1, b: 2, c: 3 };\r\n\r\nconsole.log(foo);  // 1\r\nconsole.log(rest); // { b: 2, c: 3 }</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>* <em><code>foo</code> will be a new variable with the value of <code>a</code> (which is 1).</em></p>\n\n<p><br />\n<strong><em>EXTENDED ANSWER</em></strong> 😇<br />\nThere are few common ways to remove a property from an object.<br />Each one has it's own pros and cons (<a href=\"https://jsperf.com/delete-vs-undefined-vs-null/16\" rel=\"noreferrer\">check this performance comparison</a>):</p>\n\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete\" rel=\"noreferrer\"><strong><em>Delete Operator</em></strong></a><br />\nReadable and short, however, it might not be the best choice if you are operating on a large number of objects as its performance is not optimized.</p>\n\n<pre><code>delete obj[key];\n</code></pre>\n\n<p><br />\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment_Operators\" rel=\"noreferrer\"><strong><em>Reassignment</em></strong></a><br />\nMore than 2X faster than <code>delete</code>, however the property is <strong>not</strong> deleted and can be iterated.</p>\n\n<pre><code>obj[key] = null;\nobj[key] = false;\nobj[key] = undefined;\n</code></pre>\n\n<p><br />\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\" rel=\"noreferrer\"><strong><em>Spread Operator</em></strong></a><br />\nThis <code>ES6</code> operator allows us to return a brand new object, excluding any properties, without mutating the existing object. The downside is that it has the worse performance out of the above and not suggested to be used when you need to remove many properties at a time.</p>\n\n<pre><code>{ [key]: val, ...rest } = obj;\n</code></pre>\n"},{"score":36,"body":"<p><strong>To clone object without property:</strong></p>\n<p>For example:</p>\n<pre><code>let object = { a: 1, b: 2, c: 3 };   \n</code></pre>\n<p>And we need to delete <code>a</code>.</p>\n<ol>\n<li>With <strong>explicit prop key</strong>:</li>\n</ol>\n<pre><code>    const { a, ...rest } = object;\n    object = rest;\n</code></pre>\n<ol start=\"2\">\n<li>With <strong>variable prop key</strong>:</li>\n</ol>\n<pre><code>    const propKey = 'a';\n    const { [propKey]: propValue, ...rest } = object;\n    object = rest;\n</code></pre>\n<ol start=\"3\">\n<li>Cool <strong>arrow function</strong> 😎:</li>\n</ol>\n<pre><code>    const removePropery = (propKey, { [propKey]: propValue, ...rest }) =&gt; rest;\n\n    object = removePropery('a', object);\n</code></pre>\n<ol start=\"4\">\n<li>For <strong>multiple properties</strong></li>\n</ol>\n<pre><code>    const removeProperties = (object, ...keys) =&gt; Object.entries(object).reduce((prev, [key, value]) =&gt; ({...prev, ...(!keys.includes(key) &amp;&amp; { [key]: value }) }), {})\n</code></pre>\n<p><em><strong>Usage</strong></em></p>\n<pre><code>object = removeProperties(object, 'a', 'b') // result =&gt; { c: 3 }\n</code></pre>\n<p><em><strong>Or</strong></em></p>\n<pre><code>    const propsToRemove = ['a', 'b']\n    object = removeProperties(object, ...propsToRemove) // result =&gt; { c: 3 }\n</code></pre>\n"},{"score":6,"body":"<p>You can use filter like below</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var myObject = {\n    \"ircEvent\": \"PRIVMSG\",\n    \"method\": \"newURI\",\n    \"regex\": \"^http://.*\"\n};\n\n// way 1\n\nlet filter1 = {}\n  Object.keys({...myObject}).filter(d =&gt; {\n  if(d !== 'regex'){\n    filter1[d] = myObject[d];\n  }\n})\n\nconsole.log(filter1)\n\n// way 2\n\nlet filter2 = Object.fromEntries(Object.entries({...myObject}).filter(d =&gt; \nd[0] !== 'regex'\n))\n\nconsole.log(filter2)</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"},{"score":3,"body":"<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>let myObject = {\n    \"ircEvent\": \"PRIVMSG\",\n    \"method\": \"newURI\",\n    \"regex\": \"^http://.*\"\n};\n\n\nobj = Object.fromEntries(\n    Object.entries(myObject).filter(function (m){\n        return m[0] != \"regex\"/*or whatever key to delete*/\n    }\n))\n\nconsole.log(obj)</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>You can also just treat the object like <code>a2d</code> array using <code>Object.entries</code>, and use splice to remove an element as you would in a normal array, or simply filter through the object, as one would an array, and assign the reconstructed object back to the original variable</p>\n"},{"score":1,"body":"<p>If you don't want to modify the original object.</p>\n<p><strong>Remove a property without mutating the object</strong></p>\n<p>If mutability is a concern, you can create a completely new object by copying all the properties from the old, except the one you want to remove.</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>let myObject = {\n  \"ircEvent\": \"PRIVMSG\",\n  \"method\": \"newURI\",\n  \"regex\": \"^http://.*\"\n};\n\nlet prop = 'regex';\nconst updatedObject = Object.keys(myObject).reduce((object, key) =&gt; {\n  if (key !== prop) {\n    object[key] = myObject[key]\n  }\n  return object\n}, {})\n\nconsole.log(updatedObject);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n"}],"score":6367}