{"body":"<p>I'm trying to create globally-unique identifiers in JavaScript.  I'm not sure what routines are available on all browsers, how &quot;random&quot; and seeded the built-in random number generator is, etc.</p>\n<p>The GUID / UUID should be at least 32 characters and should stay in the ASCII range to avoid trouble when passing them around.</p>\n","title":"How to create a GUID / UUID","answers":[{"score":2438,"body":"<p>UUIDs (Universally Unique IDentifier), also known as GUIDs (Globally Unique IDentifier), according to <a href=\"https://www.ietf.org/rfc/rfc4122.txt\" rel=\"noreferrer\">RFC 4122</a>, are identifiers designed to provide certain uniqueness guarantees.</p>\n<p>While it is possible to implement an RFC-compliant UUIDs in a few lines of JavaScript code (e.g., see <a href=\"https://stackoverflow.com/a/2117523/109538\">@broofa's answer</a>, below) there are several common pitfalls:</p>\n<ul>\n<li>Invalid id format (UUIDs must be of the form &quot;<code>xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx</code>&quot;, where x is one of [0-9, a-f] <em>M</em> is one of [1-5], and <em>N</em> is [8, 9, a, or b]</li>\n<li>Use of a low-quality source of randomness (such as <code>Math.random</code>)</li>\n</ul>\n<p>Thus, developers writing code for production environments are encouraged to use a rigorous, well-maintained implementation such as the <a href=\"https://github.com/uuidjs/uuid\" rel=\"noreferrer\">uuid</a> module.</p>\n"},{"score":58,"body":"<p>From <a href=\"http://blog.shkedy.com/2007/01/createing-guids-with-client-side.html\" rel=\"nofollow noreferrer\">sagi shkedy's technical blog</a>:</p>\n<pre><code>function generateGuid() {\n  var result, i, j;\n  result = '';\n  for(j=0; j&lt;32; j++) {\n    if( j == 8 || j == 12 || j == 16 || j == 20)\n      result = result + '-';\n    i = Math.floor(Math.random()*16).toString(16).toUpperCase();\n    result = result + i;\n  }\n  return result;\n}\n</code></pre>\n<p>There are other methods that involve using an <a href=\"https://en.wikipedia.org/wiki/ActiveX\" rel=\"nofollow noreferrer\">ActiveX</a> control, but stay away from these!</p>\n<p>I thought it was worth pointing out that no GUID generator can guarantee unique keys (check the <a href=\"http://en.wikipedia.org/wiki/Globally_Unique_Identifier\" rel=\"nofollow noreferrer\">Wikipedia article</a>). There is always a chance of collisions. A GUID simply offers a large enough universe of keys to reduce the change of collisions to almost nil.</p>\n"},{"score":171,"body":"<p>Here's some code based on <a href=\"http://www.ietf.org/rfc/rfc4122.txt\" rel=\"noreferrer\">RFC 4122</a>, section 4.4 (Algorithms for Creating a UUID from Truly Random or Pseudo-Random Number).</p>\n\n<pre><code>function createUUID() {\n    // http://www.ietf.org/rfc/rfc4122.txt\n    var s = [];\n    var hexDigits = \"0123456789abcdef\";\n    for (var i = 0; i &lt; 36; i++) {\n        s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n    }\n    s[14] = \"4\";  // bits 12-15 of the time_hi_and_version field to 0010\n    s[19] = hexDigits.substr((s[19] &amp; 0x3) | 0x8, 1);  // bits 6-7 of the clock_seq_hi_and_reserved to 01\n    s[8] = s[13] = s[18] = s[23] = \"-\";\n\n    var uuid = s.join(\"\");\n    return uuid;\n}\n</code></pre>\n"},{"score":31,"body":"<p>This creates a version 4 UUID (created from pseudo random numbers):</p>\n<pre class=\"lang-js prettyprint-override\"><code>function uuid()\n{\n   var chars = '0123456789abcdef'.split('');\n\n   var uuid = [], rnd = Math.random, r;\n   uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n   uuid[14] = '4'; // version 4\n\n   for (var i = 0; i &lt; 36; i++)\n   {\n      if (!uuid[i])\n      {\n         r = 0 | rnd()*16;\n\n         uuid[i] = chars[(i == 19) ? (r &amp; 0x3) | 0x8 : r &amp; 0xf];\n      }\n   }\n\n   return uuid.join('');\n}\n</code></pre>\n<p>Here is a sample of the UUIDs generated:</p>\n<pre class=\"lang-none prettyprint-override\"><code>682db637-0f31-4847-9cdf-25ba9613a75c\n97d19478-3ab2-4aa1-b8cc-a1c3540f54aa\n2eed04c9-2692-456d-a0fd-51012f947136\n</code></pre>\n"},{"score":4397,"body":"<p>For an <a href=\"https://www.ietf.org/rfc/rfc4122.txt\" rel=\"noreferrer\">RFC4122</a> version 4 compliant solution, this one-liner(ish) solution is the most compact I could come up with:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r &amp; 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nconsole.log(uuidv4());</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p><strong>Update, 2015-06-02</strong>:  Be aware that UUID uniqueness relies heavily on the underlying random number generator (RNG).  The solution above uses <code>Math.random()</code> for brevity, however <code>Math.random()</code> is <em>not</em> guaranteed to be a high-quality RNG.  See Adam Hyland's <a href=\"http://bocoup.com/weblog/random-numbers/\" rel=\"noreferrer\">excellent writeup on Math.random()</a> for details.  For a more robust solution, consider using the <a href=\"https://github.com/uuidjs/uuid\" rel=\"noreferrer\">uuid module</a>, which uses higher quality RNG APIs.</p>\n<p><strong>Update, 2015-08-26</strong>: As a side-note, this <a href=\"https://gist.githubusercontent.com/aristus/f0c311df98d92e367df0\" rel=\"noreferrer\">gist</a> describes how to determine how many IDs can be generated before reaching a certain probability of collision.  For example, with 3.26x10<sup>15</sup> version 4 RFC4122 UUIDs you have a 1-in-a-million chance of collision.</p>\n<p><strong>Update, 2017-06-28</strong>: A <a href=\"https://v8project.blogspot.com/2015/12/theres-mathrandom-and-then-theres.html\" rel=\"noreferrer\">good article from Chrome developers</a> discussing the state of <code>Math.random</code> PRNG quality in Chrome, Firefox, and Safari.  tl;dr - As of late-2015 it's &quot;pretty good&quot;, but not cryptographic quality.  To address that issue, here's an updated version of the above solution that uses ES6, the <code>crypto</code> API, and <a href=\"https://gist.github.com/jed/982883\" rel=\"noreferrer\">a bit of JavaScript wizardry I can't take credit for</a>:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function uuidv4() {\n  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =&gt;\n    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16)\n  );\n}\n\nconsole.log(uuidv4());</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p><strong>Update, 2020-01-06</strong>: There is a <a href=\"https://github.com/tc39/proposal-uuid\" rel=\"noreferrer\">proposal in the works</a> for a standard <code>uuid</code> module as part of the JavaScript language</p>\n"},{"score":21,"body":"<pre><code>  // RFC 4122\n  //\n  // A UUID is 128 bits long\n  //\n  // String representation is five fields of 4, 2, 2, 2, and 6 bytes.\n  // Fields represented as lowercase, zero-filled, hexadecimal strings, and\n  // are separated by dash characters\n  //\n  // A version 4 UUID is generated by setting all but six bits to randomly\n  // chosen values\n  var uuid = [\n    Math.random().toString(16).slice(2, 10),\n    Math.random().toString(16).slice(2, 6),\n\n    // Set the four most significant bits (bits 12 through 15) of the\n    // time_hi_and_version field to the 4-bit version number from Section\n    // 4.1.3\n    (Math.random() * .0625 /* 0x.1 */ + .25 /* 0x.4 */).toString(16).slice(2, 6),\n\n    // Set the two most significant bits (bits 6 and 7) of the\n    // clock_seq_hi_and_reserved to zero and one, respectively\n    (Math.random() * .25 /* 0x.4 */ + .5 /* 0x.8 */).toString(16).slice(2, 6),\n\n    Math.random().toString(16).slice(2, 14)].join('-');\n</code></pre>\n"},{"score":62,"body":"<p>Here's a solution dated Oct. 9, 2011 from a comment by user <em>jed</em> at <a href=\"https://gist.github.com/982883\" rel=\"noreferrer\">https://gist.github.com/982883</a>:</p>\n\n<pre><code>UUIDv4 = function b(a){return a?(a^Math.random()*16&gt;&gt;a/4).toString(16):([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,b)}\n</code></pre>\n\n<p>This accomplishes the same goal as the <a href=\"https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\">current highest-rated answer</a>, but in 50+ fewer bytes by exploiting coercion, recursion, and exponential notation. For those curious how it works, here's the annotated form of an older version of the function:</p>\n\n<pre><code>UUIDv4 =\n\nfunction b(\n  a // placeholder\n){\n  return a // if the placeholder was passed, return\n    ? ( // a random number from 0 to 15\n      a ^ // unless b is 8,\n      Math.random() // in which case\n      * 16 // a random number from\n      &gt;&gt; a/4 // 8 to 11\n      ).toString(16) // in hexadecimal\n    : ( // or otherwise a concatenated string:\n      [1e7] + // 10000000 +\n      -1e3 + // -1000 +\n      -4e3 + // -4000 +\n      -8e3 + // -80000000 +\n      -1e11 // -100000000000,\n      ).replace( // replacing\n        /[018]/g, // zeroes, ones, and eights with\n        b // random hex digits\n      )\n}\n</code></pre>\n"},{"score":36,"body":"<pre><code>var uuid = function() {\n    var buf = new Uint32Array(4);\n    window.crypto.getRandomValues(buf);\n    var idx = -1;\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n        idx++;\n        var r = (buf[idx&gt;&gt;3] &gt;&gt; ((idx%8)*4))&amp;15;\n        var v = c == 'x' ? r : (r&amp;0x3|0x8);\n        return v.toString(16);\n    });\n};\n</code></pre>\n<p>EDIT:</p>\n<p>Revisited my project that was using this function and disliked the verbosity. - But needed proper randomness.</p>\n<p>A version based on Briguy37's answer and some bitwise operators to extract nibble sized windows from the buffer.</p>\n<p>Should adhere to the RFC Type 4 (random) schema, since I had Problems last time parsing non-compliant uuids with Java's UUID.</p>\n"},{"score":67,"body":"<p>Here is a combination of the <a href=\"https://stackoverflow.com/a/2117523/11236\">top voted answer</a>, with a workaround for <a href=\"https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript\">Chrome's collisions</a>:</p>\n\n<pre><code>generateGUID = (typeof(window.crypto) != 'undefined' &amp;&amp; \n                typeof(window.crypto.getRandomValues) != 'undefined') ?\n    function() {\n        // If we have a cryptographically secure PRNG, use that\n        // https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript\n        var buf = new Uint16Array(8);\n        window.crypto.getRandomValues(buf);\n        var S4 = function(num) {\n            var ret = num.toString(16);\n            while(ret.length &lt; 4){\n                ret = \"0\"+ret;\n            }\n            return ret;\n        };\n        return (S4(buf[0])+S4(buf[1])+\"-\"+S4(buf[2])+\"-\"+S4(buf[3])+\"-\"+S4(buf[4])+\"-\"+S4(buf[5])+S4(buf[6])+S4(buf[7]));\n    }\n\n    :\n\n    function() {\n        // Otherwise, just use Math.random\n        // https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            var r = Math.random()*16|0, v = c == 'x' ? r : (r&amp;0x3|0x8);\n            return v.toString(16);\n        });\n    };\n</code></pre>\n\n<p><a href=\"http://jsbin.com/uqives/3\" rel=\"noreferrer\">On jsbin</a> if you want to test it.</p>\n"},{"score":840,"body":"<p>I really like how clean <a href=\"https://stackoverflow.com/a/2117523/508537\">Broofa's answer</a> is, but it's unfortunate that <a href=\"https://stackoverflow.com/q/6906916/508537\">poor implementations of <code>Math.random</code></a> leave the chance for collision.  </p>\n\n<p>Here's a similar <a href=\"http://www.ietf.org/rfc/rfc4122.txt\" rel=\"noreferrer\">RFC4122</a> version 4 compliant solution that solves that issue by offsetting the first 13 hex numbers by a hex portion of the timestamp, and once depleted offsets by a hex portion of the microseconds since pageload.  That way, even if <code>Math.random</code> is on the same seed, both clients would have to generate the UUID the exact same number of microseconds since pageload (if high-perfomance time is supported) AND at the exact same millisecond (or 10,000+ years later) to get the same UUID:   </p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function generateUUID() { // Public Domain/MIT\r\n    var d = new Date().getTime();//Timestamp\r\n    var d2 = (performance &amp;&amp; performance.now &amp;&amp; (performance.now()*1000)) || 0;//Time in microseconds since page-load or 0 if unsupported\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n        var r = Math.random() * 16;//random number between 0 and 16\r\n        if(d &gt; 0){//Use timestamp until depleted\r\n            r = (d + r)%16 | 0;\r\n            d = Math.floor(d/16);\r\n        } else {//Use microseconds since page-load if supported\r\n            r = (d2 + r)%16 | 0;\r\n            d2 = Math.floor(d2/16);\r\n        }\r\n        return (c === 'x' ? r : (r &amp; 0x3 | 0x8)).toString(16);\r\n    });\r\n}\r\n\r\nconsole.log(generateUUID())</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p><br/>\n<a href=\"https://jsfiddle.net/briguy37/8eacgpnq/\" rel=\"noreferrer\">Here's a fiddle to test.</a></p>\n"},{"score":15,"body":"<p>Adjusted my own UUID/GUID generator with some extras <a href=\"http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx\" rel=\"noreferrer\">here</a>.</p>\n\n<p>I'm using <a href=\"http://baagoe.com/en/RandomMusings/javascript/\" rel=\"noreferrer\">the following Kybos</a> random number generator to be a bit more cryptographically sound.</p>\n\n<p>Below is my script with the Mash and Kybos methods from baagoe.com excluded.</p>\n\n<pre><code>//UUID/Guid Generator\n// use: UUID.create() or UUID.createSequential()\n// convenience:  UUID.empty, UUID.tryParse(string)\n(function(w){\n  // From http://baagoe.com/en/RandomMusings/javascript/\n  // Johannes BaagÃ¸e &lt;baagoe@baagoe.com&gt;, 2010\n  //function Mash() {...};\n\n  // From http://baagoe.com/en/RandomMusings/javascript/\n  //function Kybos() {...};\n\n  var rnd = Kybos();\n\n  //UUID/GUID Implementation from http://frugalcoder.us/post/2012/01/13/javascript-guid-uuid-generator.aspx\n  var UUID = {\n    \"empty\": \"00000000-0000-0000-0000-000000000000\"\n    ,\"parse\": function(input) {\n      var ret = input.toString().trim().toLowerCase().replace(/^[\\s\\r\\n]+|[\\{\\}]|[\\s\\r\\n]+$/g, \"\");\n      if ((/[a-f0-9]{8}\\-[a-f0-9]{4}\\-[a-f0-9]{4}\\-[a-f0-9]{4}\\-[a-f0-9]{12}/).test(ret))\n        return ret;\n      else\n        throw new Error(\"Unable to parse UUID\");\n    }\n    ,\"createSequential\": function() {\n      var ret = new Date().valueOf().toString(16).replace(\"-\",\"\")\n      for (;ret.length &lt; 12; ret = \"0\" + ret);\n      ret = ret.substr(ret.length-12,12); //only least significant part\n      for (;ret.length &lt; 32;ret += Math.floor(rnd() * 0xffffffff).toString(16));\n      return [ret.substr(0,8), ret.substr(8,4), \"4\" + ret.substr(12,3), \"89AB\"[Math.floor(Math.random()*4)] + ret.substr(16,3),  ret.substr(20,12)].join(\"-\");\n    }\n    ,\"create\": function() {\n      var ret = \"\";\n      for (;ret.length &lt; 32;ret += Math.floor(rnd() * 0xffffffff).toString(16));\n      return [ret.substr(0,8), ret.substr(8,4), \"4\" + ret.substr(12,3), \"89AB\"[Math.floor(Math.random()*4)] + ret.substr(16,3),  ret.substr(20,12)].join(\"-\");\n    }\n    ,\"random\": function() {\n      return rnd();\n    }\n    ,\"tryParse\": function(input) {\n      try {\n        return UUID.parse(input);\n      } catch(ex) {\n        return UUID.empty;\n      }\n    }\n  };\n  UUID[\"new\"] = UUID.create;\n\n  w.UUID = w.Guid = UUID;\n}(window || this));</code></pre>\n"},{"score":12,"body":"<p>The better way:</p>\n\n<pre><code>function(\n  a,b                // placeholders\n){\n  for(               // loop :)\n      b=a='';        // b - result , a - numeric variable\n      a++&lt;36;        // \n      b+=a*51&amp;52  // if \"a\" is not 9 or 14 or 19 or 24\n                  ?  //  return a random number or 4\n         (\n           a^15      // if \"a\" is not 15\n              ?      // genetate a random number from 0 to 15\n           8^Math.random()*\n           (a^20?16:4)  // unless \"a\" is 20, in which case a random number from 8 to 11\n              :\n           4            //  otherwise 4\n           ).toString(16)\n                  :\n         '-'            //  in other cases (if \"a\" is 9,14,19,24) insert \"-\"\n      );\n  return b\n }\n</code></pre>\n\n<p>Minimized:</p>\n\n<pre><code>function(a,b){for(b=a='';a++&lt;36;b+=a*51&amp;52?(a^15?8^Math.random()*(a^20?16:4):4).toString(16):'-');return b}\n</code></pre>\n"},{"score":27,"body":"<p>JavaScript project on GitHub - <a href=\"https://github.com/LiosK/UUID.js\">https://github.com/LiosK/UUID.js</a></p>\n\n<blockquote>\n  <p><strong>UUID.js The RFC-compliant UUID generator for JavaScript.</strong></p>\n  \n  <p>See RFC 4122 <a href=\"http://www.ietf.org/rfc/rfc4122.txt\">http://www.ietf.org/rfc/rfc4122.txt</a>.</p>\n  \n  <p><strong>Features Generates RFC 4122 compliant UUIDs.</strong></p>\n  \n  <p>Version 4 UUIDs (UUIDs from random numbers) and version 1 UUIDs\n  (time-based UUIDs) are available.</p>\n  \n  <p>UUID object allows a variety of access to the UUID including access to\n  the UUID fields.</p>\n  \n  <p>Low timestamp resolution of JavaScript is compensated by random\n  numbers.</p>\n</blockquote>\n"},{"score":69,"body":"<p>Here is a totally non-compliant but very performant implementation to generate an ASCII-safe GUID-like unique identifier.</p>\n\n<pre><code>function generateQuickGuid() {\n    return Math.random().toString(36).substring(2, 15) +\n        Math.random().toString(36).substring(2, 15);\n}\n</code></pre>\n\n<p>Generates 26 [a-z0-9] characters, yielding a UID that is both shorter and more unique than RFC compliant GUIDs. Dashes can be trivially added if human-readability matters.</p>\n\n<p>Here are usage examples and timings for this function and several of this question's other answers. The timing was performed under Chrome m25, 10 million iterations each.</p>\n\n<pre><code>&gt;&gt;&gt; generateQuickGuid()\n\"nvcjf1hs7tf8yyk4lmlijqkuo9\"\n\"yq6gipxqta4kui8z05tgh9qeel\"\n\"36dh5sec7zdj90sk2rx7pjswi2\"\nruntime: 32.5s\n\n&gt;&gt;&gt; GUID() // John Millikin\n\"7a342ca2-e79f-528e-6302-8f901b0b6888\"\nruntime: 57.8s\n\n&gt;&gt;&gt; regexGuid() // broofa\n\"396e0c46-09e4-4b19-97db-bd423774a4b3\"\nruntime: 91.2s\n\n&gt;&gt;&gt; createUUID() // Kevin Hakanson\n\"403aa1ab-9f70-44ec-bc08-5d5ac56bd8a5\"\nruntime: 65.9s\n\n&gt;&gt;&gt; UUIDv4() // Jed Schmidt\n\"f4d7d31f-fa83-431a-b30c-3e6cc37cc6ee\"\nruntime: 282.4s\n\n&gt;&gt;&gt; Math.uuid() // broofa\n\"5BD52F55-E68F-40FC-93C2-90EE069CE545\"\nruntime: 225.8s\n\n&gt;&gt;&gt; Math.uuidFast() // broofa\n\"6CB97A68-23A2-473E-B75B-11263781BBE6\"\nruntime: 92.0s\n\n&gt;&gt;&gt; Math.uuidCompact() // broofa\n\"3d7b7a06-0a67-4b67-825c-e5c43ff8c1e8\"\nruntime: 229.0s\n\n&gt;&gt;&gt; bitwiseGUID() // jablko\n\"baeaa2f-7587-4ff1-af23-eeab3e92\"\nruntime: 79.6s\n\n&gt;&gt;&gt;&gt; betterWayGUID() // Andrea Turri\n\"383585b0-9753-498d-99c3-416582e9662c\"\nruntime: 60.0s\n\n&gt;&gt;&gt;&gt; UUID() // John Fowler\n\"855f997b-4369-4cdb-b7c9-7142ceaf39e8\"\nruntime: 62.2s\n</code></pre>\n\n<p>Here is the timing code.</p>\n\n<pre><code>var r;\nconsole.time('t'); \nfor (var i = 0; i &lt; 10000000; i++) { \n    r = FuncToTest(); \n};\nconsole.timeEnd('t');\n</code></pre>\n"},{"score":15,"body":"<p>For those wanting an rfc4122 version 4 compliant solution with speed considerations (few calls to Math.random()):</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var rand = Math.random;\r\n\r\nfunction UUID() {\r\n    var nbr, randStr = \"\";\r\n    do {\r\n        randStr += (nbr = rand()).toString(16).substr(3, 6);\r\n    } while (randStr.length &lt; 30);\r\n    return (\r\n        randStr.substr(0, 8) + \"-\" +\r\n        randStr.substr(8, 4) + \"-4\" +\r\n        randStr.substr(12, 3) + \"-\" +\r\n        ((nbr*4|0)+8).toString(16) + // [89ab]\r\n        randStr.substr(15, 3) + \"-\" +\r\n        randStr.substr(18, 12)\r\n    );\r\n}\r\n\r\nconsole.log( UUID() );</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>The above function should have a decent balance between speed and randomness.</p>\n"},{"score":31,"body":"<p>Simple JavaScript module as a combination of best answers in this thread.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var crypto = window.crypto || window.msCrypto || null; // IE11 fix\r\n\r\nvar Guid = Guid || (function() {\r\n\r\n  var EMPTY = '00000000-0000-0000-0000-000000000000';\r\n\r\n  var _padLeft = function(paddingString, width, replacementChar) {\r\n    return paddingString.length &gt;= width ? paddingString : _padLeft(replacementChar + paddingString, width, replacementChar || ' ');\r\n  };\r\n\r\n  var _s4 = function(number) {\r\n    var hexadecimalResult = number.toString(16);\r\n    return _padLeft(hexadecimalResult, 4, '0');\r\n  };\r\n\r\n  var _cryptoGuid = function() {\r\n    var buffer = new window.Uint16Array(8);\r\n    window.crypto.getRandomValues(buffer);\r\n    return [_s4(buffer[0]) + _s4(buffer[1]), _s4(buffer[2]), _s4(buffer[3]), _s4(buffer[4]), _s4(buffer[5]) + _s4(buffer[6]) + _s4(buffer[7])].join('-');\r\n  };\r\n\r\n  var _guid = function() {\r\n    var currentDateMilliseconds = new Date().getTime();\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(currentChar) {\r\n      var randomChar = (currentDateMilliseconds + Math.random() * 16) % 16 | 0;\r\n      currentDateMilliseconds = Math.floor(currentDateMilliseconds / 16);\r\n      return (currentChar === 'x' ? randomChar : (randomChar &amp; 0x7 | 0x8)).toString(16);\r\n    });\r\n  };\r\n\r\n  var create = function() {\r\n    var hasCrypto = crypto != 'undefined' &amp;&amp; crypto !== null,\r\n      hasRandomValues = typeof(window.crypto.getRandomValues) != 'undefined';\r\n    return (hasCrypto &amp;&amp; hasRandomValues) ? _cryptoGuid() : _guid();\r\n  };\r\n\r\n  return {\r\n    newGuid: create,\r\n    empty: EMPTY\r\n  };\r\n})();\r\n\r\n// DEMO: Create and show GUID\r\nconsole.log(Guid.newGuid());</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Usage: </p>\n\n<blockquote>\n  <blockquote>\n    <p><strong>Guid.newGuid()</strong></p>\n    \n    <p>\"c6c2d12f-d76b-5739-e551-07e6de5b0807\"</p>\n    \n    <p><strong>Guid.empty</strong></p>\n    \n    <p>\"00000000-0000-0000-0000-000000000000\"</p>\n  </blockquote>\n</blockquote>\n"},{"score":96,"body":"<p>Fastest GUID like string generator method in the format <code>XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX</code>. This does not generate standard-compliant GUID.</p>\n\n<p>Ten million executions of this implementation take just 32.5 seconds, which is the fastest I've ever seen in a browser (the only solution without loops/iterations).</p>\n\n<p>The function is as simple as:</p>\n\n<pre><code>/**\n * Generates a GUID string.\n * @returns {string} The generated GUID.\n * @example af8a8416-6e18-a307-bd9c-f2c947bbb3aa\n * @author Slavik Meltser.\n * @link http://slavik.meltser.info/?p=142\n */\nfunction guid() {\n    function _p8(s) {\n        var p = (Math.random().toString(16)+\"000000000\").substr(2,8);\n        return s ? \"-\" + p.substr(0,4) + \"-\" + p.substr(4,4) : p ;\n    }\n    return _p8() + _p8(true) + _p8(true) + _p8();\n}\n</code></pre>\n\n<p>To test the performance, you can run this code:</p>\n\n<pre><code>console.time('t'); \nfor (var i = 0; i &lt; 10000000; i++) { \n    guid(); \n};\nconsole.timeEnd('t');\n</code></pre>\n\n<p>I'm sure most of you will understand what I did there, but maybe there is at least one person that will need an explanation:</p>\n\n<p><strong>The algorithm:</strong></p>\n\n<ul>\n<li>The <code>Math.random()</code> function returns a decimal number between 0 and 1 with 16 digits after the decimal fraction point (for\nexample <code>0.4363923368509859</code>).</li>\n<li>Then we take this number and convert\nit to a string with base 16 (from the example above we'll get\n<code>0.6fb7687f</code>).<br>\n<code>Math.random().toString(16)</code>.</li>\n<li>Then we cut off the <code>0.</code> prefix (<code>0.6fb7687f</code> =>\n<code>6fb7687f</code>) and get a string with eight hexadecimal\ncharacters long.<br>\n<code>(Math.random().toString(16).substr(2,8)</code>.</li>\n<li>Sometimes the <code>Math.random()</code> function will return\nshorter number (for example <code>0.4363</code>), due to zeros at the end (from the example above, actually the number is <code>0.4363000000000000</code>). That's why I'm appending to this string <code>\"000000000\"</code> (a string with nine zeros) and then cutting it off with <code>substr()</code> function to make it nine characters exactly (filling zeros to the right).</li>\n<li>The reason for adding exactly nine zeros is because of the worse case scenario, which is when the <code>Math.random()</code> function will return exactly 0 or 1 (probability of 1/10^16 for each one of them). That's why we needed to add nine zeros to it (<code>\"0\"+\"000000000\"</code> or <code>\"1\"+\"000000000\"</code>), and then cutting it off from the second index (3rd character) with a length of eight characters. For the rest of the cases, the addition of zeros will not harm the result because it is cutting it off anyway.<br>\n<code>Math.random().toString(16)+\"000000000\").substr(2,8)</code>.</li>\n</ul>\n\n<p><strong>The assembly:</strong></p>\n\n<ul>\n<li>The GUID is in the following format <code>XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX</code>.</li>\n<li>I divided the GUID into 4 pieces, each piece divided into 2 types (or formats): <code>XXXXXXXX</code> and <code>-XXXX-XXXX</code>.</li>\n<li>Now I'm building the GUID using these 2 types to assemble the GUID with call 4 pieces, as follows: <code>XXXXXXXX</code> <code>-XXXX-XXXX</code> <code>-XXXX-XXXX</code> <code>XXXXXXXX</code>.</li>\n<li>To differ between these two types, I added a flag parameter to a pair creator function <code>_p8(s)</code>, the <code>s</code> parameter tells the function whether to add dashes or not.</li>\n<li>Eventually we build the GUID with the following chaining: <code>_p8() + _p8(true) + _p8(true) + _p8()</code>, and return it.</li>\n</ul>\n\n<p><a href=\"http://slavik.meltser.info/the-efficient-way-to-create-guid-uuid-in-javascript/\" rel=\"noreferrer\">Link to this post on my blog</a></p>\n\n<p><strong>Enjoy! :-)</strong></p>\n"},{"score":11,"body":"<p>I know, it is an old question. Just for completeness, if your environment is SharePoint, there is a utility function called <code>SP.Guid.newGuid</code> (<a href=\"http://msdn.microsoft.com/en-us/library/ee659495%28v=office.14%29.aspx\">msdn link</a>) which creates a new guid. This function is inside the sp.init.js file. If you rewrite this function (to remove some other dependencies from other private functions), it looks like this:</p>\n\n<pre><code>var newGuid = function () {\n    var result = '';\n    var hexcodes = \"0123456789abcdef\".split(\"\");\n\n    for (var index = 0; index &lt; 32; index++) {\n        var value = Math.floor(Math.random() * 16);\n\n        switch (index) {\n        case 8:\n            result += '-';\n            break;\n        case 12:\n            value = 4;\n            result += '-';\n            break;\n        case 16:\n            value = value &amp; 3 | 8;\n            result += '-';\n            break;\n        case 20:\n            result += '-';\n            break;\n        }\n        result += hexcodes[value];\n    }\n    return result;\n};\n</code></pre>\n"},{"score":6,"body":"<p>It is important that to use well tested code that is maintained by more than 1 contributors instead of whipping your own stuff for this. This is one of the places where you probably want to prefer most stable code than shortest possible clever version that works in X browser but doesn't take in to account idiosyncrasies of Y which would often lead to very hard to investigate bugs than manifests only randomly for some users. Personally I use uuid-js at <a href=\"https://github.com/aurigadl/uuid-js\">https://github.com/aurigadl/uuid-js</a> which bower enabled so I can take updates easily.</p>\n"},{"score":449,"body":"<p>broofa's answer is pretty slick, indeed - impressively clever, really...  rfc4122 compliant, somewhat readable, and compact.  Awesome!</p>\n\n<p>But if you're looking at that regular expression, those many <code>replace()</code> callbacks, <code>toString()</code>'s and <code>Math.random()</code> function calls (where he's only using 4 bits of the result and wasting the rest), you may start to wonder about performance.  Indeed, joelpt even decided to toss out RFC for generic GUID speed with <code>generateQuickGUID</code>.</p>\n\n<p><strong>But, can we get speed <em>and</em> RFC compliance?  I say, YES!</strong>  Can we maintain readability?  Well...  Not really, but it's easy if you follow along.</p>\n\n<p>But first, my results, compared to broofa, <code>guid</code> (the accepted answer), and the non-rfc-compliant <code>generateQuickGuid</code>:</p>\n\n<pre><code>                  Desktop   Android\n           broofa: 1617ms   12869ms\n               e1:  636ms    5778ms\n               e2:  606ms    4754ms\n               e3:  364ms    3003ms\n               e4:  329ms    2015ms\n               e5:  147ms    1156ms\n               e6:  146ms    1035ms\n               e7:  105ms     726ms\n             guid:  962ms   10762ms\ngenerateQuickGuid:  292ms    2961ms\n  - Note: 500k iterations, results will vary by browser/cpu.\n</code></pre>\n\n<p>So by my 6th iteration of optimizations, I beat the most popular answer by over <strong>12X</strong>, the accepted answer by over <strong>9X</strong>, and the fast-non-compliant answer by <strong>2-3X</strong>.  And I'm still rfc4122 compliant.</p>\n\n<p>Interested in how?  I've put the full source on <a href=\"http://jsfiddle.net/jcward/7hyaC/3/\" rel=\"noreferrer\">http://jsfiddle.net/jcward/7hyaC/3/</a> and on <a href=\"http://jsperf.com/uuid-generator-opt/4\" rel=\"noreferrer\">http://jsperf.com/uuid-generator-opt/4</a></p>\n\n<p>For an explanation, let's start with broofa's code:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function broofa() {\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\r\n        var r = Math.random()*16|0, v = c == 'x' ? r : (r&amp;0x3|0x8);\r\n        return v.toString(16);\r\n    });\r\n}\r\n\r\nconsole.log(broofa())</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>So it replaces <code>x</code> with any random hex digit, <code>y</code> with random data (except forcing the top 2 bits to <code>10</code> per the RFC spec), and the regex doesn't match the <code>-</code> or <code>4</code> characters, so he doesn't have to deal with them.  Very, very slick.</p>\n\n<p>The first thing to know is that function calls are expensive, as are regular expressions (though he only uses 1, it has 32 callbacks, one for each match, and in each of the 32 callbacks it calls Math.random() and v.toString(16)).</p>\n\n<p>The first step toward performance is to eliminate the RegEx and its callback functions and use a simple loop instead.  This means we have to deal with the <code>-</code> and <code>4</code> characters whereas broofa did not.  Also, note that we can use String Array indexing to keep his slick String template architecture:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function e1() {\r\n    var u='',i=0;\r\n    while(i++&lt;36) {\r\n        var c='xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'[i-1],r=Math.random()*16|0,v=c=='x'?r:(r&amp;0x3|0x8);\r\n        u+=(c=='-'||c=='4')?c:v.toString(16)\r\n    }\r\n    return u;\r\n}\r\n\r\nconsole.log(e1())</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Basically, the same inner logic, except we check for <code>-</code> or <code>4</code>, and using a while loop (instead of <code>replace()</code> callbacks) gets us an almost 3X improvement!</p>\n\n<p>The next step is a small one on the desktop but makes a decent difference on mobile.  Let's make fewer Math.random() calls and utilize all those random bits instead of throwing 87% of them away with a random buffer that gets shifted out each iteration.  Let's also move that template definition out of the loop, just in case it helps:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function e2() {\r\n    var u='',m='xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx',i=0,rb=Math.random()*0xffffffff|0;\r\n    while(i++&lt;36) {\r\n        var c=m[i-1],r=rb&amp;0xf,v=c=='x'?r:(r&amp;0x3|0x8);\r\n        u+=(c=='-'||c=='4')?c:v.toString(16);rb=i%8==0?Math.random()*0xffffffff|0:rb&gt;&gt;4\r\n    }\r\n    return u\r\n}\r\n\r\nconsole.log(e2())</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>This saves us 10-30% depending on platform.  Not bad.  But the next big step gets rid of the toString function calls altogether with an optimization classic - the look-up table.  A simple 16-element lookup table will perform the job of toString(16) in much less time:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function e3() {\r\n    var h='0123456789abcdef';\r\n    var k='xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\r\n    /* same as e4() below */\r\n}\r\nfunction e4() {\r\n    var h=['0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'];\r\n    var k=['x','x','x','x','x','x','x','x','-','x','x','x','x','-','4','x','x','x','-','y','x','x','x','-','x','x','x','x','x','x','x','x','x','x','x','x'];\r\n    var u='',i=0,rb=Math.random()*0xffffffff|0;\r\n    while(i++&lt;36) {\r\n        var c=k[i-1],r=rb&amp;0xf,v=c=='x'?r:(r&amp;0x3|0x8);\r\n        u+=(c=='-'||c=='4')?c:h[v];rb=i%8==0?Math.random()*0xffffffff|0:rb&gt;&gt;4\r\n    }\r\n    return u\r\n}\r\n\r\nconsole.log(e4())</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>The next optimization is another classic.  Since we're only handling 4-bits of output in each loop iteration, let's cut the number of loops in half and process 8-bits each iteration.  This is tricky since we still have to handle the RFC compliant bit positions, but it's not too hard.  We then have to make a larger lookup table (16x16, or 256) to store 0x00 - 0xff, and we build it only once, outside the e5() function.</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var lut = []; for (var i=0; i&lt;256; i++) { lut[i] = (i&lt;16?'0':'')+(i).toString(16); }\r\nfunction e5() {\r\n    var k=['x','x','x','x','-','x','x','-','4','x','-','y','x','-','x','x','x','x','x','x'];\r\n    var u='',i=0,rb=Math.random()*0xffffffff|0;\r\n    while(i++&lt;20) {\r\n        var c=k[i-1],r=rb&amp;0xff,v=c=='x'?r:(c=='y'?(r&amp;0x3f|0x80):(r&amp;0xf|0x40));\r\n        u+=(c=='-')?c:lut[v];rb=i%4==0?Math.random()*0xffffffff|0:rb&gt;&gt;8\r\n    }\r\n    return u\r\n}\r\n\r\nconsole.log(e5())</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>I tried an e6() that processes 16-bits at a time, still using the 256-element LUT, and it showed the diminishing returns of optimization.  Though it had fewer iterations, the inner logic was complicated by the increased processing, and it performed the same on desktop, and only ~10% faster on mobile.</p>\n\n<p>The final optimization technique to apply - unroll the loop.  Since we're looping a fixed number of times, we can technically write this all out by hand.  I tried this once with a single random variable r that I kept re-assigning, and performance tanked.  But with four variables assigned random data up front, then using the lookup table, and applying the proper RFC bits, this version smokes them all:</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>var lut = []; for (var i=0; i&lt;256; i++) { lut[i] = (i&lt;16?'0':'')+(i).toString(16); }\r\nfunction e7()\r\n{\r\n    var d0 = Math.random()*0xffffffff|0;\r\n    var d1 = Math.random()*0xffffffff|0;\r\n    var d2 = Math.random()*0xffffffff|0;\r\n    var d3 = Math.random()*0xffffffff|0;\r\n    return lut[d0&amp;0xff]+lut[d0&gt;&gt;8&amp;0xff]+lut[d0&gt;&gt;16&amp;0xff]+lut[d0&gt;&gt;24&amp;0xff]+'-'+\r\n    lut[d1&amp;0xff]+lut[d1&gt;&gt;8&amp;0xff]+'-'+lut[d1&gt;&gt;16&amp;0x0f|0x40]+lut[d1&gt;&gt;24&amp;0xff]+'-'+\r\n    lut[d2&amp;0x3f|0x80]+lut[d2&gt;&gt;8&amp;0xff]+'-'+lut[d2&gt;&gt;16&amp;0xff]+lut[d2&gt;&gt;24&amp;0xff]+\r\n    lut[d3&amp;0xff]+lut[d3&gt;&gt;8&amp;0xff]+lut[d3&gt;&gt;16&amp;0xff]+lut[d3&gt;&gt;24&amp;0xff];\r\n}\r\n\r\nconsole.log(e7())</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<p>Modualized:  <a href=\"http://jcward.com/UUID.js\" rel=\"noreferrer\">http://jcward.com/UUID.js</a> - <code>UUID.generate()</code></p>\n\n<p>The funny thing is, generating 16 bytes of random data is the easy part.  The whole trick is expressing it in String format with RFC compliance, and it's most tightly accomplished with 16 bytes of random data, an unrolled loop and lookup table.</p>\n\n<p>I hope my logic is correct -- it's very easy to make a mistake in this kind of tedious bit-work.  But the outputs look good to me.  I hope you enjoyed this mad ride through code optimization!</p>\n\n<p><strong>Be advised:</strong> my primary goal was to show and teach potential optimization strategies.  Other answers cover important topics such as collisions and truly random numbers, which are important for generating good UUIDs.</p>\n"},{"score":11,"body":"<p>This one is based on date, and add a random suffix to \"ensure\" uniqueness.\nWorks well for css identifiers.\nIt always returns something like and is easy to hack:</p>\n\n<p>uid-139410573297741</p>\n\n<pre><code>var getUniqueId = function (prefix) {\n            var d = new Date().getTime();\n            d += (parseInt(Math.random() * 100)).toString();\n            if (undefined === prefix) {\n                prefix = 'uid-';\n            }\n            d = prefix + d;\n            return d;\n        };\n</code></pre>\n"},{"score":4,"body":"<p>I'm using this below function, hope it may be useful.</p>\n\n<pre><code>    function NewGuid()\n         {\n           var sGuid=\"\";\n           for (var i=0; i&lt;32; i++)\n            {\n              sGuid+=Math.floor(Math.random()*0xF).toString(0xF);\n            }\n           return sGuid;\n         }\n</code></pre>\n"},{"score":2,"body":"<p>For my use-case, I required id generation that was guaranteed to be unique globally; without exception. I struggled with the problem for a while, and came up with a solution called tuid (Truly Unique ID). It generates an id with the first 32 characters being system-generated and the remaining digits representing milliseconds since epoch. In situations where I need to generate id's on client-side javascript, it works well. Have a look:</p>\n\n<p><a href=\"https://github.com/mongoh/tuid\" rel=\"nofollow\">https://github.com/mongoh/tuid</a></p>\n"},{"score":28,"body":"<p>Well, this has a bunch of answers already, but unfortunately there's not a \"true\" random in the bunch. The version below is an adaptation of broofa's answer, but updated to include a \"true\" random function that uses crypto libraries where available, and the Alea() function as a fallback.</p>\n\n<pre><code>  Math.log2 = Math.log2 || function(n){ return Math.log(n) / Math.log(2); }\n  Math.trueRandom = (function() {\n  var crypt = window.crypto || window.msCrypto;\n\n  if (crypt &amp;&amp; crypt.getRandomValues) {\n      // if we have a crypto library, use it\n      var random = function(min, max) {\n          var rval = 0;\n          var range = max - min;\n          if (range &lt; 2) {\n              return min;\n          }\n\n          var bits_needed = Math.ceil(Math.log2(range));\n          if (bits_needed &gt; 53) {\n            throw new Exception(\"We cannot generate numbers larger than 53 bits.\");\n          }\n          var bytes_needed = Math.ceil(bits_needed / 8);\n          var mask = Math.pow(2, bits_needed) - 1;\n          // 7776 -&gt; (2^13 = 8192) -1 == 8191 or 0x00001111 11111111\n\n          // Create byte array and fill with N random numbers\n          var byteArray = new Uint8Array(bytes_needed);\n          crypt.getRandomValues(byteArray);\n\n          var p = (bytes_needed - 1) * 8;\n          for(var i = 0; i &lt; bytes_needed; i++ ) {\n              rval += byteArray[i] * Math.pow(2, p);\n              p -= 8;\n          }\n\n          // Use &amp; to apply the mask and reduce the number of recursive lookups\n          rval = rval &amp; mask;\n\n          if (rval &gt;= range) {\n              // Integer out of acceptable range\n              return random(min, max);\n          }\n          // Return an integer that falls within the range\n          return min + rval;\n      }\n      return function() {\n          var r = random(0, 1000000000) / 1000000000;\n          return r;\n      };\n  } else {\n      // From https://web.archive.org/web/20120502223108/http://baagoe.com/en/RandomMusings/javascript/\n      // Johannes BaagÃ¸e &lt;baagoe@baagoe.com&gt;, 2010\n      function Mash() {\n          var n = 0xefc8249d;\n\n          var mash = function(data) {\n              data = data.toString();\n              for (var i = 0; i &lt; data.length; i++) {\n                  n += data.charCodeAt(i);\n                  var h = 0.02519603282416938 * n;\n                  n = h &gt;&gt;&gt; 0;\n                  h -= n;\n                  h *= n;\n                  n = h &gt;&gt;&gt; 0;\n                  h -= n;\n                  n += h * 0x100000000; // 2^32\n              }\n              return (n &gt;&gt;&gt; 0) * 2.3283064365386963e-10; // 2^-32\n          };\n\n          mash.version = 'Mash 0.9';\n          return mash;\n      }\n\n      // From http://baagoe.com/en/RandomMusings/javascript/\n      function Alea() {\n          return (function(args) {\n              // Johannes BaagÃ¸e &lt;baagoe@baagoe.com&gt;, 2010\n              var s0 = 0;\n              var s1 = 0;\n              var s2 = 0;\n              var c = 1;\n\n              if (args.length == 0) {\n                  args = [+new Date()];\n              }\n              var mash = Mash();\n              s0 = mash(' ');\n              s1 = mash(' ');\n              s2 = mash(' ');\n\n              for (var i = 0; i &lt; args.length; i++) {\n                  s0 -= mash(args[i]);\n                  if (s0 &lt; 0) {\n                      s0 += 1;\n                  }\n                  s1 -= mash(args[i]);\n                  if (s1 &lt; 0) {\n                      s1 += 1;\n                  }\n                  s2 -= mash(args[i]);\n                  if (s2 &lt; 0) {\n                      s2 += 1;\n                  }\n              }\n              mash = null;\n\n              var random = function() {\n                  var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n                  s0 = s1;\n                  s1 = s2;\n                  return s2 = t - (c = t | 0);\n              };\n              random.uint32 = function() {\n                  return random() * 0x100000000; // 2^32\n              };\n              random.fract53 = function() {\n                  return random() +\n                      (random() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\n              };\n              random.version = 'Alea 0.9';\n              random.args = args;\n              return random;\n\n          }(Array.prototype.slice.call(arguments)));\n      };\n      return Alea();\n  }\n}());\n\nMath.guid = function() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c)    {\n      var r = Math.trueRandom() * 16 | 0,\n          v = c == 'x' ? r : (r &amp; 0x3 | 0x8);\n      return v.toString(16);\n  });\n};\n</code></pre>\n"},{"score":16,"body":"<p>I wanted to understand broofa's answer, so I expanded it and added comments:</p>\n\n<pre><code>var uuid = function () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(\n        /[xy]/g,\n        function (match) {\n            /*\n            * Create a random nibble. The two clever bits of this code:\n            *\n            * - Bitwise operations will truncate floating point numbers\n            * - For a bitwise OR of any x, x | 0 = x\n            *\n            * So:\n            *\n            * Math.random * 16\n            *\n            * creates a random floating point number\n            * between 0 (inclusive) and 16 (exclusive) and\n            *\n            * | 0\n            *\n            * truncates the floating point number into an integer.\n            */\n            var randomNibble = Math.random() * 16 | 0;\n\n            /*\n            * Resolves the variant field. If the variant field (delineated\n            * as y in the initial string) is matched, the nibble must\n            * match the mask (where x is a do-not-care bit):\n            *\n            * 10xx\n            *\n            * This is achieved by performing the following operations in\n            * sequence (where x is an intermediate result):\n            *\n            * - x &amp; 0x3, which is equivalent to x % 3\n            * - x | 0x8, which is equivalent to x + 8\n            *\n            * This results in a nibble between 8 inclusive and 11 exclusive,\n            * (or 1000 and 1011 in binary), all of which satisfy the variant\n            * field mask above.\n            */\n            var nibble = (match == 'y') ?\n                (randomNibble &amp; 0x3 | 0x8) :\n                randomNibble;\n\n            /*\n            * Ensure the nibble integer is encoded as base 16 (hexadecimal).\n            */\n            return nibble.toString(16);\n        }\n    );\n};\n</code></pre>\n"},{"score":4,"body":"<p>A simple solution to generate unique identification is to use time token and add random number to it. I prefer to prefix it with \"uuid-\".<br /><br />\nBelow function will generate random string of type: <strong>uuid-14d93eb1b9b4533e6</strong>. One doesn't need to generate 32 chars random string. 16 char random string is more than sufficient in this case to provide the unique UUIDs in javascript.</p>\n\n<pre>\nvar createUUID = function() {\n  return\"uuid-\"+((new Date).getTime().toString(16)+Math.floor(1E7*Math.random()).toString(16));\n}\n</pre>\n"},{"score":11,"body":"<p>Simple code that uses <code>crypto.getRandomValues(a)</code> on <a href=\"http://caniuse.com/#search=getRandomValues\" rel=\"noreferrer\">supported browsers</a> (IE11+, iOS7+, FF21+, Chrome, Android Chrome). Avoids using <code>Math.random()</code> because that can cause collisions (for example 20 collisions for 4000 generated uuids in a real situation by <a href=\"https://stackoverflow.com/questions/6906916/collisions-when-generating-uuids-in-javascript\">Muxa</a>).</p>\n\n<pre><code>function uuid() {\n    function randomDigit() {\n        if (crypto &amp;&amp; crypto.getRandomValues) {\n            var rands = new Uint8Array(1);\n            crypto.getRandomValues(rands);\n            return (rands[0] % 16).toString(16);\n        } else {\n            return ((Math.random() * 16) | 0).toString(16);\n        }\n    }\n    var crypto = window.crypto || window.msCrypto;\n    return 'xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx'.replace(/x/g, randomDigit);\n}\n</code></pre>\n\n<p>Notes:</p>\n\n<ul>\n<li>Optimised for code readability not speed, so suitable for say a few hundred uuid's per second. Generates about 10000 uuid() per second in Chromium on my laptop using <a href=\"http://jsbin.com/fuwigo/1\" rel=\"noreferrer\">http://jsbin.com/fuwigo/1</a> to measure performance.</li>\n<li>Only uses 8 for \"y\" because that simplifies code readability (y is allowed to be 8, 9, A or B).</li>\n</ul>\n"},{"score":0,"body":"<p>Just thought I'd post yet another way of doing the same thing.</p>\n\n<pre><code>function guid() {\n  var chars = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"];\n  var str = \"\";\n  for(var i=0;i&lt;36;i++) {\n    var str = str + ((i == 8 || i == 13 || i == 18 || i == 23) ? \"-\" : chars[Math.floor(Math.random()*chars.length)]);\n  };\n  return str;\n}\n</code></pre>\n"},{"score":46,"body":"<p>You can use node-uuid (<a href=\"https://github.com/kelektiv/node-uuid\" rel=\"noreferrer\">https://github.com/kelektiv/node-uuid</a>)</p>\n\n<p>Simple, fast generation of <a href=\"http://www.ietf.org/rfc/rfc4122.txt\" rel=\"noreferrer\">RFC4122</a> UUIDS.</p>\n\n<p>Features:</p>\n\n<ul>\n<li>Generate RFC4122 version 1 or version 4 UUIDs</li>\n<li>Runs in node.js and browsers.</li>\n<li>Cryptographically strong random # generation on supporting platforms.</li>\n<li>Small footprint (Want something smaller? <a href=\"https://gist.github.com/982883\" rel=\"noreferrer\">Check this out!</a>)</li>\n</ul>\n\n<hr>\n\n<p><strong>Install Using NPM:</strong></p>\n\n<pre><code>npm install uuid\n</code></pre>\n\n<hr>\n\n<p><strong>Or Using uuid via browser:</strong></p>\n\n<p>Download Raw File (uuid v1): <a href=\"https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js\" rel=\"noreferrer\">https://raw.githubusercontent.com/kelektiv/node-uuid/master/v1.js</a>\nDownload Raw File (uuid v4): <a href=\"https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js\" rel=\"noreferrer\">https://raw.githubusercontent.com/kelektiv/node-uuid/master/v4.js</a></p>\n\n<hr>\n\n<p>Want even smaller? Check this out: <a href=\"https://gist.github.com/jed/982883\" rel=\"noreferrer\">https://gist.github.com/jed/982883</a></p>\n\n<hr>\n\n<p><strong>Usage:</strong></p>\n\n<pre><code>// Generate a v1 UUID (time-based)\nconst uuidV1 = require('uuid/v1');\nuuidV1(); // -&gt; '6c84fb90-12c4-11e1-840d-7b25c5ee775a'\n\n// Generate a v4 UUID (random)\nconst uuidV4 = require('uuid/v4');\nuuidV4(); // -&gt; '110ec58a-a0f2-4ac4-8393-c866d813b8d1'\n\n// Generate a v5 UUID (namespace)\nconst uuidV5 = require('uuid/v5');\n\n// ... using predefined DNS namespace (for domain names)\nuuidV5('hello.example.com', v5.DNS)); // -&gt; 'fdda765f-fc57-5604-a269-52a7df8164ec'\n\n// ... using predefined URL namespace (for, well, URLs)\nuuidV5('http://example.com/hello', v5.URL); // -&gt; '3bbcee75-cecc-5b56-8031-b6641c1ed1f1'\n\n// ... using a custom namespace\nconst MY_NAMESPACE = '(previously generated unique uuid string)';\nuuidV5('hello', MY_NAMESPACE); // -&gt; '90123e1c-7512-523e-bb28-76fab9f2f73d'\n</code></pre>\n\n<hr>\n\n<p><strong>ES6:</strong></p>\n\n<pre><code>import uuid from 'uuid/v4';\nconst id = uuid();\n</code></pre>\n"},{"score":4,"body":"<p>You could use the npm package <em>guid</em>, a guid generator and validator.</p>\n\n<p><a href=\"https://www.npmjs.com/package/guid\" rel=\"nofollow noreferrer\">https://www.npmjs.com/package/guid</a></p>\n\n<p>Example:</p>\n\n<pre><code>Guid.raw();\n// -&gt; '6fdf6ffc-ed77-94fa-407e-a7b86ed9e59d'\n</code></pre>\n\n<p><strong>UPDATE:</strong> This package has been deprecated. Use <strong>uuid</strong> instead. </p>\n\n<p><a href=\"https://www.npmjs.com/package/uuid\" rel=\"nofollow noreferrer\">https://www.npmjs.com/package/uuid</a></p>\n\n<p>Example: </p>\n\n<pre><code>const uuidv4 = require('uuid/v4');\nuuidv4(); // ⇨ '10ba038e-48da-487b-96e8-8d3b99b6d18a'\n</code></pre>\n"},{"score":2,"body":"<p>Just in case anyone dropping by google is seeking a small utility library, ShortId (<a href=\"https://www.npmjs.com/package/shortid\" rel=\"nofollow\">https://www.npmjs.com/package/shortid</a>) meets all the requirements of this question. It allows specifying allowed characters and length, and guarantees non-sequential, non-repeating strings.</p>\n\n<p>To make this more of a real answer, the core of that library uses the following logic to produce its short ids:</p>\n\n<pre><code>function encode(lookup, number) {\n    var loopCounter = 0;\n    var done;\n\n    var str = '';\n\n    while (!done) {\n        str = str + lookup( ( (number &gt;&gt; (4 * loopCounter)) &amp; 0x0f ) | randomByte() );\n        done = number &lt; (Math.pow(16, loopCounter + 1 ) );\n        loopCounter++;\n    }\n    return str;\n}\n\n/** Generates the short id */\nfunction generate() {\n\n    var str = '';\n\n    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);\n\n    if (seconds === previousSeconds) {\n        counter++;\n    } else {\n        counter = 0;\n        previousSeconds = seconds;\n    }\n\n    str = str + encode(alphabet.lookup, version);\n    str = str + encode(alphabet.lookup, clusterWorkerId);\n    if (counter &gt; 0) {\n        str = str + encode(alphabet.lookup, counter);\n    }\n    str = str + encode(alphabet.lookup, seconds);\n\n    return str;\n}\n</code></pre>\n\n<p>I have not edited this to reflect <em>only</em> the most basic parts of this approach, so the above code includes some additional logic from the library. If you are curious about everything it is doing, take a look at the source: <a href=\"https://github.com/dylang/shortid/tree/master/lib\" rel=\"nofollow\">https://github.com/dylang/shortid/tree/master/lib</a></p>\n"},{"score":2,"body":"<p>Hi here is an working example it generates 32-digit Unique UUID.   </p>\n\n<pre><code>function generateUUID() {\n      var d = new Date();\n      var k = d.getTime();\n     var str = k.toString(16).slice(1)\n    var UUID= 'xxxx-xxxx-4xxx-yxxx-xzx'.replace(/[xy]/g, function (c)\n      {\n        var r = Math.random() * 16 | 0;\n        v = c == 'x' ? r : (r &amp; 3 | 8);\n        return v.toString(16);\n      });\n      var newString = UUID.replace(/[z]/, str)\n      return newString;\n    }\n    var x = generateUUID()\n    console.log(x,x.length)\n</code></pre>\n"},{"score":3,"body":"<p>I found this script useful for creating GUIDs in JavaScript</p>\n\n<p><a href=\"https://github.com/addui/GUIDJS\" rel=\"nofollow\">https://github.com/addui/GUIDJS</a></p>\n\n<pre><code>var myGuid = GUID();\n</code></pre>\n"},{"score":0,"body":"<p>This may be of use to someone...</p>\n\n<pre><code>var d = new Date().valueOf();\nvar n = d.toString();\nvar result = '';\nvar length = 32;\nvar p = 0;\nvar chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\nfor (var i = length; i &gt; 0; --i){\n    result += ((i &amp; 1) &amp;&amp; n.charAt(p) ? '&lt;b&gt;' + n.charAt(p) + '&lt;/b&gt;' : chars[Math.floor(Math.random() * chars.length)]);\n    if(i &amp; 1) p++;\n};\n</code></pre>\n\n<p><a href=\"https://jsfiddle.net/j0evrdf1/1/\" rel=\"nofollow\">https://jsfiddle.net/j0evrdf1/1/</a></p>\n"},{"score":0,"body":"<pre><code>function randomHex(length) {\n    var random_string = '';\n    if(!length){\n        length = 1;\n    }\n    for(var i=0; i&lt;length; i+=1){\n        random_string += Math.floor(Math.random() * 15).toString(16);\n    }\n    return random_string;\n}\n\nfunction guid() {\n    return randomHex(8);\n}\n</code></pre>\n"},{"score":3,"body":"<p>Here you can find a very small function that generates uuids <a href=\"https://gist.github.com/jed/982883\" rel=\"nofollow\">https://gist.github.com/jed/982883</a></p>\n\n<p>One of the final versions is:</p>\n\n<pre><code>function b(\n  a                  // placeholder\n){\n  var cryptoObj = window.crypto || window.msCrypto; // for IE 11\n  return a           // if the placeholder was passed, return\n    ? (              // a random number from 0 to 15\n      a ^            // unless b is 8,\n      cryptoObj.getRandomValues(new Uint8Array(1))[0]  // in which case\n      % 16           // a random number from\n      &gt;&gt; a/4         // 8 to 11\n      ).toString(16) // in hexadecimal\n    : (              // or otherwise a concatenated string:\n      [1e7] +        // 10000000 +\n      -1e3 +         // -1000 +\n      -4e3 +         // -4000 +\n      -8e3 +         // -80000000 +\n      -1e11          // -100000000000,\n      ).replace(     // replacing\n        /[018]/g,    // zeroes, ones, and eights with\n        b            // random hex digits\n      )\n}\n</code></pre>\n"},{"score":12,"body":"<p>If you just need a random 128 bit string in no particular format you can use:</p>\n\n<pre><code>function uuid() {\n    return crypto.getRandomValues(new Uint32Array(4)).join('-');\n}\n</code></pre>\n\n<p>Which will return something like <code>2350143528-4164020887-938913176-2513998651</code>.</p>\n"},{"score":168,"body":"<pre><code>let uniqueId = Date.now().toString(36) + Math.random().toString(36).substring(2);\n</code></pre>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>document.getElementById(\"unique\").innerHTML =\n  Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;div id=\"unique\"&gt;\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>If ID's are generated more than 1 millisecond apart, they are 100% unique.</p>\n<p>If two ID's are generated at shorter intervals, and assuming that the random method is truly random, this would generate ID's that are 99.99999999999999% likely to be globally unique (collision in 1 of 10^15)</p>\n<p>You can increase this number by adding more digits, but to generate 100% unique ID's you will need to use a global counter.</p>\n<p>if you need RFC compatibility, this formatting will pass as a valid version 4 GUID:</p>\n<pre><code>let u = Date.now().toString(16) + Math.random().toString(16) + '0'.repeat(16);\nlet guid = [u.substr(0,8), u.substr(8,4), '4000-8' + u.substr(13,3), u.substr(16,12)].join('-');\n</code></pre>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"true\" data-console=\"false\" data-babel=\"false\">\r\n<div class=\"snippet-code snippet-currently-hidden\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>let u = Date.now().toString(16)+Math.random().toString(16)+'0'.repeat(16);\nlet guid = [u.substr(0,8), u.substr(8,4), '4000-8' + u.substr(13,3), u.substr(16,12)].join('-');\ndocument.getElementById(\"unique\").innerHTML = guid;</code></pre>\r\n<pre class=\"snippet-code-html lang-html prettyprint-override\"><code>&lt;div id=\"unique\"&gt;\n&lt;/div&gt;</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>Edit: The above code follow the intention, but not the letter of the RFC. Among other discrepancies it's a few random digits short. (Add more random digits if you need it) The upside is that this it's really fast :)\nYou can <a href=\"https://www.freecodeformat.com/validate-uuid-guid.php\" rel=\"noreferrer\">test validity of your GUID here</a></p>\n"},{"score":13,"body":"<p>ES6 sample</p>\n\n<pre><code>const guid=()=&gt; {\n  const s4=()=&gt; Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);     \n  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4() + s4() + s4()}`;\n}\n</code></pre>\n"},{"score":12,"body":"<p>Just another more readable variant with just two mutations.</p>\n\n<pre><code>function uuid4()\n{\n  function hex (s, b)\n  {\n    return s +\n      (b &gt;&gt;&gt; 4   ).toString (16) +  // high nibble\n      (b &amp; 0b1111).toString (16);   // low nibble\n  }\n\n  let r = crypto.getRandomValues (new Uint8Array (16));\n\n  r[6] = r[6] &gt;&gt;&gt; 4 | 0b01000000; // Set type 4: 0100\n  r[8] = r[8] &gt;&gt;&gt; 3 | 0b10000000; // Set variant: 100\n\n  return r.slice ( 0,  4).reduce (hex, '' ) +\n         r.slice ( 4,  6).reduce (hex, '-') +\n         r.slice ( 6,  8).reduce (hex, '-') +\n         r.slice ( 8, 10).reduce (hex, '-') +\n         r.slice (10, 16).reduce (hex, '-');\n}\n</code></pre>\n"},{"score":3,"body":"<p>For those who are using Javascript on Windows (e.g. WScript / CScript / MSHTA). One can use <code>ActiveX</code>. Specifically, the <code>Scriptlet.Typelib</code> object:</p>\n\n<pre><code>WScript.Echo((new ActiveXObject(\"Scriptlet.TypeLib\")).Guid)\n</code></pre>\n\n<p>Note that this answer only works on the technologies I listed, it will not work any browser, not even Microsoft Edge! So, your mileage will vary with this answer.</p>\n"},{"score":3,"body":"<p>Based on the work of broofa, I've added some more randomness by adding the timestamp to <code>math.random()</code></p>\n<p>Hope it might help</p>\n<pre><code>function uuidv4() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = parseFloat('0.' + Math.random().toString().replace('0.', '') + new Date().getTime()) * 16 | 0,\n            v = c == 'x' ? r : (r &amp; 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\n</code></pre>\n"},{"score":0,"body":"<p>For science. I haven't seen anyone do this yet... its not v4 compliant, but could easily be altered to be. Its just an example of extending the <em>Uint8Array</em> type, and using <em>crypto.getRandomValues()</em> to generate the uuid byte values.</p>\n\n<pre><code>class uuid extends Uint8Array {\n        constructor() {\n            super(16)\n            /* not v4, just some random bytes */\n            window.crypto.getRandomValues(this)\n        }\n        toString() {\n            let id = new String()\n            for (let i = 0; i &lt; this.length; i++) {\n                /*convert uint8 to hex string */\n                let hex = this[i].toString(16).toUpperCase()\n\n                /*add zero padding*/\n                while (hex.length &lt; 2) {\n                    hex = String(0).concat(hex)\n                }\n                id += hex\n\n                /* add dashes */\n                if (i == 4 || i == 6 || i == 8 || i == 10 || i == 16){\n                    id += '-'\n                }\n            }\n            return id\n        }\n    }\n</code></pre>\n"},{"score":5,"body":"<p>I couldn't find any answer that uses a single 16-octet <code>TypedArray</code> and a <code>DataView</code>, so I think the following solution for generating a version 4 UUID per <a href=\"https://www.ietf.org/rfc/rfc4122.txt\" rel=\"nofollow noreferrer\">the RFC</a> will stand on its own here:</p>\n\n<pre><code>function uuid4() {\n    const ho = (n, p) =&gt; n.toString(16).padStart(p, 0); /// Return the hexadecimal text representation of number `n`, padded with zeroes to be of length `p`\n    const view = new DataView(new ArrayBuffer(16)); /// Create a view backed by a 16-byte buffer\n    crypto.getRandomValues(new Uint8Array(view.buffer)); /// Fill the buffer with random data\n    view.setUint8(6, (view.getUint8(6) &amp; 0xf) | 0x40); /// Patch the 6th byte to reflect a version 4 UUID\n    view.setUint8(8, (view.getUint8(8) &amp; 0x3f) | 0x80); /// Patch the 8th byte to reflect a variant 1 UUID (version 4 UUIDs are)\n    return `${ho(view.getUint32(0), 8)}-${ho(view.getUint16(4), 4)}-${ho(view.getUint16(6), 4)}-${ho(view.getUint16(8), 4)}-${ho(view.getUint32(10), 8)}${ho(view.getUint16(14), 4)}`; /// Compile the canonical textual form from the array data\n}\n</code></pre>\n\n<p>I prefer it because it only relies on functions available to the standard ECMAScript platform.</p>\n\n<p>Take note of the fact that at the time of writing this, <code>getRandomValues</code> is not something implemented for the <code>crypto</code> object in Node.js. However, it has the equivalent <code>randomBytes</code> function which may be used instead.</p>\n"},{"score":8,"body":"<p>OK, using <strong>uuid</strong> package, it support for <strong>version 1, 3, 4 and 5 UUIDs</strong> do:</p>\n\n<pre><code>yarn add uuid\n</code></pre>\n\n<p>and then:</p>\n\n<pre><code>const uuidv1 = require('uuid/v1');\nuuidv1(); // ⇨ '45745c60-7b1a-11e8-9c9c-2d42b21b1a3e'\n</code></pre>\n\n<p>You can also do it with fully-specified options:</p>\n\n<pre><code>const v1options = {\n  node: [0x01, 0x23, 0x45, 0x67, 0x89, 0xab],\n  clockseq: 0x1234,\n  msecs: new Date('2011-11-01').getTime(),\n  nsecs: 5678\n};\nuuidv1(v1options); // ⇨ '710b962e-041c-11e1-9234-0123456789ab'\n</code></pre>\n\n<p>For more info, visit the npm page <a href=\"https://www.npmjs.com/package/uuid\" rel=\"noreferrer\">here</a></p>\n"},{"score":2,"body":"<p>We can use replace and crypto.getRandomValues to get an output like this :</p>\n\n<p><code>xxxxxxxx-xxxx-4xxx-xxxx-xxxxxxxxxxxx</code></p>\n\n<p><a href=\"https://i.stack.imgur.com/OJWv4.png\" rel=\"nofollow noreferrer\"><img src=\"https://i.stack.imgur.com/OJWv4.png\" alt=\"enter image description here\"></a></p>\n\n<p>If we are looking for an opti solution, we have to replace <code>crypto.getRandomValues(new Uint8Array(1))[0]</code> by an array(32).</p>\n\n<pre><code>const uuidv4 = () =&gt;\n  ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt;\n    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16)\n  );\n\nconsole.log(uuidv4());\n</code></pre>\n\n<p>To get this code :</p>\n\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>function uuidv4() {\r\n  let bytes = window.crypto.getRandomValues(new Uint8Array(32));\r\n  const randomBytes = () =&gt; (bytes = bytes.slice(1)) &amp;&amp; bytes[0];\r\n\r\n  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =&gt; \r\n      (c ^ randomBytes() &amp; 15 &gt;&gt; c / 4).toString(16)\r\n    );\r\n}\r\n\r\n\r\nfor (var i = 0; i &lt; 10; i++)\r\n  console.log(uuidv4());</code></pre>\r\n</div>\r\n</div>\r\n</p>\n\n<h1>Collision :</h1>\n\n<p>We can do like google analytics and add a timestamp with : <code>uuidv4() + \".\" + (+new Date())</code>.</p>\n"},{"score":2,"body":"<p>The UUID currently has a proposal for addition to the standard library and can be supported here <a href=\"https://github.com/tc39/proposal-uuid\" rel=\"nofollow noreferrer\">https://github.com/tc39/proposal-uuid</a> </p>\n\n<p>The proposal encompasses having UUID as the following:</p>\n\n<pre><code>// We're not yet certain as to how the API will be accessed (whether it's in the global, or a\n// future built-in module), and this will be part of the investigative process as we continue\n// working on the proposal.\nuuid(); // \"52e6953d-edbe-4953-be2e-65ed3836b2f0\"\n</code></pre>\n\n<p>This implemtation follows the same layout as the V4 random uuid generation found here: <a href=\"https://www.npmjs.com/package/uuid\" rel=\"nofollow noreferrer\">https://www.npmjs.com/package/uuid</a></p>\n\n<pre><code>const uuidv4 = require('uuid/v4');\nuuidv4(); // ⇨ '1b9d6bcd-bbfd-4b2d-9b5d-ab8dfbbd4bed'\n</code></pre>\n\n<p>I think it's noteworthy to understand how much bandwidth could be saved by this having an official implementation in the standard library. The authors of the proposal have also noted: </p>\n\n<p>The 12 kb uuid module is downloaded from npm > 62,000,000 times a month (June 2019); making it available in the standard library eventually saves TBs of bandwidth globally. If we continue to address user needs, such as uuid, with the standard library, bandwidth savings add up.</p>\n"},{"score":2,"body":"<p>A typescript version of broofa's update from 2017-06-28, based on <code>crypto</code> API:</p>\n\n<pre><code>function genUUID() {\n        // Reference: https://stackoverflow.com/a/2117523/709884\n        return (\"10000000-1000-4000-8000-100000000000\").replace(/[018]/g, s =&gt; {\n            const c = Number.parseInt(s, 10)\n            return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] &amp; 15 &gt;&gt; c / 4).toString(16)\n        })\n}\n</code></pre>\n\n<p>Reasons:</p>\n\n<ul>\n<li>Use of <code>+</code> between <code>number[]</code> and <code>number</code> isn't valid</li>\n<li>The conversion from <code>string</code> to <code>number</code> has to be explicit</li>\n</ul>\n"},{"score":3,"body":"<p>Old question, so this might never float to the top, but I've built on everything mentioned here to produce something twice as fast, portable all environments, including node, and upgraded from Math.random() to crypto-strength randomness. You might not think uuid needs crypto strength, but what that means is even less chance of a collision, which is the entire point of a uuid.</p>\n\n<pre><code>function random() {\n    const\n        fourBytesOn = 0xffffffff, // 4 bytes, all 32 bits on: 4294967295\n        c = typeof crypto === \"object\"\n            ? crypto // node or most browsers\n            : typeof msCrypto === \"object\" // stinky non-standard IE\n                ? msCrypto // eslint-disable-line no-undef\n                : null; // what old or bad environment are we running in?\n        return c\n            ? c.randomBytes\n                ? parseInt(c.randomBytes(4).toString(\"hex\"), 16) / (fourBytesOn + 1) - Number.EPSILON // node\n                : c.getRandomValues(new Uint32Array(1))[0] / (fourBytesOn + 1) - Number.EPSILON // browsers\n            : Math.random();\n}\n\nfunction uuidV4() { // eslint-disable-line complexity\n    // if possible, generate a single random value, 128 bits (16 bytes) in length\n    // in an environment where that is not possible, generate and make use of 4 32-bit (4-byte) random values\n    // use crypto-grade randomness when available, else Math.random()\n    const\n        c = typeof crypto === \"object\"\n            ? crypto // node or most browsers\n            : typeof msCrypto === \"object\" // stinky non-standard IE\n                ? msCrypto // eslint-disable-line no-undef\n            : null; // what old or bad environment are we running in?\n    let\n        byteArray = c\n            ? c.randomBytes\n                ? c.randomBytes(16) // node\n                : c.getRandomValues(new Uint8Array(16)) // browsers\n            : null,\n        uuid = [ ];\n\n    /* eslint-disable no-bitwise */\n    if ( ! byteArray) { // no support for generating 16 random bytes in one shot -- this will be slower\n        const\n            int = [\n                random() * 0xffffffff | 0,\n                random() * 0xffffffff | 0,\n                random() * 0xffffffff | 0,\n                random() * 0xffffffff | 0\n            ];\n        byteArray = [ ];\n        for (let i = 0; i &lt; 256; i++) {\n            byteArray[i] = int[i &lt; 4 ? 0 : i &lt; 8 ? 1 : i &lt; 12 ? 2 : 3] &gt;&gt; i % 4 * 8 &amp; 0xff;\n        }\n    }\n    byteArray[6] = byteArray[6] &amp; 0x0f | 0x40; // always 4, per RFC, indicating the version\n    byteArray[8] = byteArray[8] &amp; 0x3f | 0x80; // constrained to [89ab], per RFC for version 4\n    for (let i = 0; i &lt; 16; ++i) {\n        uuid[i] = (byteArray[i] &lt; 16 ? \"0\" : \"\") + byteArray[i].toString(16);\n    }\n    uuid =\n        uuid[ 0] + uuid[ 1] + uuid[ 2] + uuid[ 3] + \"-\" +\n        uuid[ 4] + uuid[ 5]                       + \"-\" +\n        uuid[ 6] + uuid[ 7]                       + \"-\" +\n        uuid[ 8] + uuid[ 9]                       + \"-\" +\n        uuid[10] + uuid[11] + uuid[12] + uuid[13] + uuid[14] + uuid[15];\n    return uuid;\n    /* eslint-enable no-bitwise */\n}\n</code></pre>\n"},{"score":1,"body":"<p>Don't use <strong>Math.random</strong> in anycase since it generated a non-cryptographic source of random numbers</p>\n\n<p>Solution below using <strong>crypto.getRandomValues</strong></p>\n\n<pre><code>function uuidv4() {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) =&gt; {\n    // tslint:disable-next-line: no-bitwise\n    const r =\n      (window.crypto.getRandomValues(new Uint32Array(1))[0] *\n        Math.pow(2, -32) * 16) |\n      0;\n    // tslint:disable-next-line: no-bitwise\n    const v = c === \"x\" ? r : (r &amp; 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n</code></pre>\n\n<p>This <a href=\"https://help.semmle.com/wiki/display/JS/Insecure+randomness\" rel=\"nofollow noreferrer\">link</a> helps your to understand the Insecure Randomness thrown by Fortify Scanner</p>\n"},{"score":11,"body":"<p>The native <code>URL.createObjectURL</code> is generating an uuid. You can take advantage of this.</p>\n\n<pre class=\"lang-js prettyprint-override\"><code>function uuid() {\n  const url = URL.createObjectURL(new Blob())\n  const [id] = url.toString().split('/').reverse()\n  URL.revokeObjectURL(url)\n  return id\n}\n</code></pre>\n"},{"score":4,"body":"<p>Because i can, i thought i should share my solution, since it is a very fascinating problem and it has so many solutions.</p>\n<p>It works for nodejs too, if you replace <code>let buffer = new Uint8Array(); crypto.getRandomValues</code> with <code>let buffer = crypto.randomBytes(16)</code></p>\n<p>I hope it helps somebody.\nIt should beat most regex solutions in performance.</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>const hex = '0123456789ABCDEF'\n\nlet generateToken = function() {\n    let buffer = new Uint8Array(16)\n    \n    crypto.getRandomValues(buffer)\n\n    buffer[6] = 0x40 | (buffer[6] &amp; 0xF)\n    buffer[8] = 0x80 | (buffer[8] &amp; 0xF)\n\n    let segments = []\n\n    for (let i = 0; i &lt; 16; ++i) {\n        segments.push(hex[(buffer[i] &gt;&gt; 4 &amp; 0xF)])\n        segments.push(hex[(buffer[i] &gt;&gt; 0 &amp; 0xF)])\n\n        if (i == 3 || i == 5 || i == 7 || i == 9) {\n            segments.push('-')\n        }\n    }\n\n    return segments.join('')\n}\n\nfor (let i = 0; i &lt; 100; ++i) {\n  console.log(generateToken())\n}</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>Performance charts, everybody loves them: <a href=\"https://jsbench.me/zikcgk6woj/1\" rel=\"nofollow noreferrer\">jsbench</a></p>\n<p>Have fun and thank you for all the other solutions, some served my quite long.</p>\n"},{"score":0,"body":"<pre><code>var guid = createMyGuid();\n\nfunction createMyGuid()  \n{  \n   return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {  \n      var r = Math.random()*16|0, v = c === 'x' ? r : (r&amp;0x3|0x8);  \n      return v.toString(16);  \n   });  \n}\n</code></pre>\n"},{"score":1,"body":"<p><strong>UUID with timestamp built in (emitter/parser)</strong><br />\nI will also post my simple approach to generating a valid UUID v4 with very strong uniqueness and fast runtime. The basic idea is not new, but approach is different. I use a timestamp in milliseconds from the <code>date.now()</code> (in Node.js library, which I'll point later, I use nanoseconds timestamp from <code>process.hrtime.bigint()</code>), and then add a random 5 digit number (<code>10000-90000</code>) to the end of the timestamp string. After merging the strings, I just form a valid UUID from digits and a pair of special characters, so that my UUID consists only of digits and a few non-numeric characters. Please check it out below:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>/*\n * uuid-timestamp (emitter)\n * UUID v4 based on timestamp\n *\n * Created by tarkh\n * tarkh.com (C) 2020\n */\nconst uuidEmit = () =&gt; {\n  // Get now time\n  const n = Date.now();\n  // Generate random\n  const r = Math.random();\n  // Stringify now time and generate additional random number\n  const s = String(n) + String(~~(r*9e4)+1e4);\n  // Form UUID and return it\n  return `${s.slice(0,8)}-${s.slice(8,12)}-4${s.slice(12,15)}-${[8,9,'a','b'][~~(r*3)]}${s.slice(15,18)}-${s.slice(s.length-12)}`;\n};\n\n// Generate 5 UUIDs\nconsole.log(`${uuidEmit()}\n${uuidEmit()}\n${uuidEmit()}\n${uuidEmit()}\n${uuidEmit()}`);</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p>Looking at the results, you obviously see that the first part of UUIDs is the same, and then comes randomness. This is because I inserted the timestamp into the UUID linearly. The code will produce a new UUID every millisecond (nanosecond in Node.js library) + add a random 5-digit number to the end, so we end up with very approximate collision probability around 1 in 10 million per second. If we use Node.js library, our very approximate collision probability goes to 1 in 10 billion per second.</p>\n<p><strong>Timestamp built into the UUID</strong><br />\nSince we insert a timestamp into the UUID linearly, we get a feature (good or bad - depends on the task) - ability to easily extract this timestamp back from the UUID. This way we can understand when UUID was released:</p>\n<p><div class=\"snippet\" data-lang=\"js\" data-hide=\"false\" data-console=\"true\" data-babel=\"false\">\r\n<div class=\"snippet-code\">\r\n<pre class=\"snippet-code-js lang-js prettyprint-override\"><code>/*\n * uuid-timestamp (parser)\n * UUID v4 based on timestamp\n *\n * Created by tarkh\n * tarkh.com (C) 2020\n */\nconst uuidParse = (uuid) =&gt; {\n  // Get current timestamp string length\n  let tl = String(Date.now()).length;\n  // Strip out timestamp from UUID\n  let ts = '';\n  let i = -1;\n  while(tl--) {\n    i++;\n    if(i===8||i===13||i===14||i===18||i===19||i===23) {\n      tl++;\n      continue;\n    }\n    ts += uuid[i];\n  }\n  return Number(ts);\n};\n\n// Get the timestamp when UUID was emitted\nconst time = uuidParse('15970688-7109-4530-8114-887109530114');\n\n// Covert timestamp to date and print it\nconsole.log(new Date(time).toUTCString());</code></pre>\r\n</div>\r\n</div>\r\n</p>\n<p><strong>Node.js</strong><br />\nNPM version of my code above available as <a href=\"https://www.npmjs.com/package/uuid-timestamp\" rel=\"nofollow noreferrer\">Node.js module</a>. This version is even more powerful in generating unique values, because instead of millisecond timestamp it uses <code>nanoseconds</code> from combination of system time and <code>process.hrtime.bigint()</code> diff.</p>\n<p><strong>Benchmarks</strong><br />\nAt the end of my post, I want to do some performance tests based on some of the answers from this topic. Of course, my decision is not the fastest, but it certainly takes the top positions.<br />\n<a href=\"https://jsben.ch/bvtX3\" rel=\"nofollow noreferrer\">Check jsBench here</a></p>\n"},{"score":1,"body":"<p>Necromancing.</p>\n<p>Effectively, a Guid, or UUID as it is called in non-microsoft-circles, is just a 128-Bit cryptographic random number, with the uuid version number (1-5) being at a fixed location byte.</p>\n<p>So when you just generate a bunch of random numbers betwween 0 and 65535 and hex-encode them, like this:</p>\n<pre><code>function guid()\n{\n    function s4()\n    {\n        return Math.floor(Math.random() * 65536).toString(16).padStart(4, '0')\n    } // End Function s4 \n\n    return s4() + s4() + '-' + s4() + '-' + &quot;4&quot; + s4().substr(1) + '-' + s4() + '-' + s4() + s4() + s4();\n} // End Function guid \n</code></pre>\n<p>you get a valid GUID, but due to the random-implementation, it's not cryptographically secure.</p>\n<p>To generate a cryptographically secure GUID, you need to use window.crypto (or window.msCrypto for Internet Exploder).</p>\n<p>That goes like this:</p>\n<pre><code>function cryptGuid()\n{ \n    var array = new Uint16Array(8);\n    (window.crypto || window.msCrypto).getRandomValues(array);\n    var dataView = new DataView(array.buffer);\n    \n    var parts = [];\n\n    for(var i = 0; i &lt; array.length; ++i)\n    {\n        // 0&amp;1,2,3,4,5-7 dataView.getUint16(0-7)\n        if(i&gt;1 &amp;&amp; i&lt;6) parts.push(&quot;-&quot;);\n        parts.push(dataView.getUint16(i).toString(16).padStart(4, '0'));\n    }\n\n    parts[5] = &quot;4&quot; + parts[5].substr(1);\n    // console.log(parts);\n    return parts.join('').toUpperCase();// .toLowerCase();\n}\n\ncryptGuid();\n</code></pre>\n<p>Plus you have to decide, if you return the number as lower-or upper-case character string.\nCertain software require lowercase characters (e.g. Reporting Service), while others generate uppercase characters (SQL-Server).</p>\n"},{"score":0,"body":"<p>There are many correct answers here, but sadly, included code samples are quite cryptic and difficult to understand.  This is how I create version 4 (random) UUIDs.</p>\n<p>Note that following pieces of code make use of binary literals for improved readability, thus require ECMAScript 6.</p>\n<h3>Node version</h3>\n<pre class=\"lang-js prettyprint-override\"><code>function uuid4() {\n  let array = new Uint8Array(16)\n  crypto.randomFillSync(array)\n\n  // manipulate 9th byte\n  array[8] &amp;= 0b00111111 // clear first two bits\n  array[8] |= 0b10000000 // set first two bits to 10\n\n  // manipulate 7th byte\n  array[6] &amp;= 0b00001111 // clear first four bits\n  array[6] |= 0b01000000 // set first four bits to 0100\n\n  const pattern = &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&quot;\n  let idx = 0\n\n  return pattern.replace(\n    /XX/g,\n    () =&gt; array[idx++].toString(16).padStart(2, &quot;0&quot;), // padStart ensures leading zero, if needed\n  )\n}\n</code></pre>\n<h3>Browser version</h3>\n<p>Only the 2nd line is different.</p>\n<pre class=\"lang-js prettyprint-override\"><code>function uuid4() {\n  let array = new Uint8Array(16)\n  crypto.getRandomValues(array)\n\n  // manipulate 9th byte\n  array[8] &amp;= 0b00111111 // clear first two bits\n  array[8] |= 0b10000000 // set first two bits to 10\n\n  // manipulate 7th byte\n  array[6] &amp;= 0b00001111 // clear first four bits\n  array[6] |= 0b01000000 // set first four bits to 0100\n\n  const pattern = &quot;XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&quot;\n  let idx = 0\n\n  return pattern.replace(\n    /XX/g,\n    () =&gt; array[idx++].toString(16).padStart(2, &quot;0&quot;), // padStart ensures leading zero, if needed\n  )\n}\n</code></pre>\n<h3>Tests</h3>\n<p>And finally, corresponding tests (Jasmine).</p>\n<pre class=\"lang-js prettyprint-override\"><code>describe(&quot;.uuid4()&quot;, function() {\n  it(&quot;returns a UUIDv4 string&quot;, function() {\n    const uuidPattern = &quot;XXXXXXXX-XXXX-4XXX-YXXX-XXXXXXXXXXXX&quot;\n    const uuidPatternRx = new RegExp(uuidPattern.\n      replaceAll(&quot;X&quot;, &quot;[0-9a-f]&quot;).\n      replaceAll(&quot;Y&quot;, &quot;[89ab]&quot;))\n\n    for (let attempt = 0; attempt &lt; 1000; attempt++) {\n      let retval = uuid4()\n      expect(retval.length).toEqual(36)\n      expect(retval).toMatch(uuidPatternRx)\n    }\n  })\n})\n</code></pre>\n<h3>UUID v4 explained</h3>\n<p>A very good explanation of UUID version 4 is here: <a href=\"https://www.cryptosys.net/pki/uuid-rfc4122.html\" rel=\"nofollow noreferrer\">https://www.cryptosys.net/pki/uuid-rfc4122.html</a>.</p>\n<h3>Final notes</h3>\n<p>Also, there are plenty of third-party packages.  However, as long as you have just basic needs, I don't recommend them.  Really, there is not much to win and pretty much to lose.  Authors may pursue for tiniest bits of performance, &quot;fix&quot; things which aren't supposed to be fixed, and when it comes to security, it is a risky idea.  Similarly, they may introduce other bugs or incompatibilities.  Careful updates require time.</p>\n"}],"score":4380}